(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('@material-ui/core/Typography'), require('@material-ui/styles'), require('@material-ui/core/Button'), require('@material-ui/core/Toolbar'), require('@material-ui/core/IconButton'), require('react-dom'), require('@material-ui/core/SvgIcon'), require('@material-ui/core/DialogActions'), require('@material-ui/core/DialogContent'), require('@material-ui/core/Dialog'), require('@material-ui/core/Popover'), require('@material-ui/core/TextField'), require('@material-ui/core/InputAdornment'), require('@material-ui/core/Tab'), require('@material-ui/core/Tabs'), require('@material-ui/core/Paper')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', '@material-ui/core/Typography', '@material-ui/styles', '@material-ui/core/Button', '@material-ui/core/Toolbar', '@material-ui/core/IconButton', 'react-dom', '@material-ui/core/SvgIcon', '@material-ui/core/DialogActions', '@material-ui/core/DialogContent', '@material-ui/core/Dialog', '@material-ui/core/Popover', '@material-ui/core/TextField', '@material-ui/core/InputAdornment', '@material-ui/core/Tab', '@material-ui/core/Tabs', '@material-ui/core/Paper'], factory) :
    (global = global || self, factory(global['@material-ui/pickers'] = {}, global.React, global.PropTypes, global['material-ui'].Typography, global['material-ui'].styles, global['material-ui'].Button, global['material-ui'].Toolbar, global['material-ui'].IconButton, global.ReactDOM, global['material-ui'].SvgIcon, global['material-ui'].DialogActions, global['material-ui'].DialogContent, global['material-ui'].Dialog, global['material-ui'].Popover, global['material-ui'].TextField, global['material-ui'].InputAdornment, global['material-ui'].Tab, global['material-ui'].Tabs, global['material-ui'].Paper));
}(this, function (exports, React, PropTypes, Typography$2, styles$1O, Button$1, Toolbar$2, IconButton$2, ReactDOM, SvgIcon$2, DialogActions$1, DialogContent$1, Dialog$1, Popover$2, TextField$1, InputAdornment$1, Tab$1, Tabs$1, Paper$2) { 'use strict';

    var React__default = 'default' in React ? React['default'] : React;
    var PropTypes__default = 'default' in PropTypes ? PropTypes['default'] : PropTypes;
    Typography$2 = Typography$2 && Typography$2.hasOwnProperty('default') ? Typography$2['default'] : Typography$2;
    Button$1 = Button$1 && Button$1.hasOwnProperty('default') ? Button$1['default'] : Button$1;
    Toolbar$2 = Toolbar$2 && Toolbar$2.hasOwnProperty('default') ? Toolbar$2['default'] : Toolbar$2;
    IconButton$2 = IconButton$2 && IconButton$2.hasOwnProperty('default') ? IconButton$2['default'] : IconButton$2;
    var ReactDOM__default = 'default' in ReactDOM ? ReactDOM['default'] : ReactDOM;
    SvgIcon$2 = SvgIcon$2 && SvgIcon$2.hasOwnProperty('default') ? SvgIcon$2['default'] : SvgIcon$2;
    DialogActions$1 = DialogActions$1 && DialogActions$1.hasOwnProperty('default') ? DialogActions$1['default'] : DialogActions$1;
    DialogContent$1 = DialogContent$1 && DialogContent$1.hasOwnProperty('default') ? DialogContent$1['default'] : DialogContent$1;
    Dialog$1 = Dialog$1 && Dialog$1.hasOwnProperty('default') ? Dialog$1['default'] : Dialog$1;
    Popover$2 = Popover$2 && Popover$2.hasOwnProperty('default') ? Popover$2['default'] : Popover$2;
    TextField$1 = TextField$1 && TextField$1.hasOwnProperty('default') ? TextField$1['default'] : TextField$1;
    InputAdornment$1 = InputAdornment$1 && InputAdornment$1.hasOwnProperty('default') ? InputAdornment$1['default'] : InputAdornment$1;
    Tab$1 = Tab$1 && Tab$1.hasOwnProperty('default') ? Tab$1['default'] : Tab$1;
    Tabs$1 = Tabs$1 && Tabs$1.hasOwnProperty('default') ? Tabs$1['default'] : Tabs$1;
    Paper$2 = Paper$2 && Paper$2.hasOwnProperty('default') ? Paper$2['default'] : Paper$2;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    var MuiPickersContext = React.createContext(null);

    var MuiPickersUtilsProvider =
    /** @class */
    function (_super) {
      __extends(MuiPickersUtilsProvider, _super);

      function MuiPickersUtilsProvider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.state = {
          utils: null
        };
        return _this;
      }

      MuiPickersUtilsProvider.getDerivedStateFromProps = function (_a) {
        var locale = _a.locale,
            libInstance = _a.libInstance,
            Utils = _a.utils;
        return {
          utils: new Utils({
            locale: locale,
            instance: libInstance
          })
        };
      };

      MuiPickersUtilsProvider.prototype.render = function () {
        return React.createElement(MuiPickersContext.Provider, {
          value: this.state.utils,
          children: this.props.children
        });
      };

      MuiPickersUtilsProvider.propTypes = {
        utils: PropTypes.func.isRequired,
        locale: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
        children: PropTypes.oneOfType([PropTypes.element.isRequired, PropTypes.arrayOf(PropTypes.element.isRequired)]).isRequired,
        moment: PropTypes.func
      };
      return MuiPickersUtilsProvider;
    }(React.Component);

    var checkUtils = function (utils) {
      if (!utils) {
        // tslint:disable-next-line
        throw new Error('Can not find utils in context. You either a) forgot to wrap your component tree in MuiPickersUtilsProvider; or b) mixed named and direct file imports.  Recommendation: use named imports from the module index.');
      }
    };
    function useUtils() {
      var utils = React.useContext(MuiPickersContext);
      checkUtils(utils);
      return utils;
    }

    function toVal(mix) {
    	var k, y, str='';
    	if (mix) {
    		if (typeof mix === 'object') {
    			if (!!mix.push) {
    				for (k=0; k < mix.length; k++) {
    					if (mix[k] && (y = toVal(mix[k]))) {
    						str && (str += ' ');
    						str += y;
    					}
    				}
    			} else {
    				for (k in mix) {
    					if (mix[k] && (y = toVal(k))) {
    						str && (str += ' ');
    						str += y;
    					}
    				}
    			}
    		} else if (typeof mix !== 'boolean' && !mix.call) {
    			str && (str += ' ');
    			str += mix;
    		}
    	}
    	return str;
    }

    function clsx () {
    	var i=0, x, str='';
    	while (i < arguments.length) {
    		if (x = toVal(arguments[i++])) {
    			str && (str += ' ');
    			str += x;
    		}
    	}
    	return str;
    }

    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var warning = function() {};

    {
      var printWarning = function printWarning(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = 'Warning: ' +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === undefined) {
          throw new Error(
              '`warning(condition, format, ...args)` requires a warning ' +
              'message argument'
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }

    var warning_1 = warning;

    /* eslint-disable no-use-before-define */
    /**
     * Returns a number whose value is limited to the given range.
     *
     * @param {number} value The value to be clamped
     * @param {number} min The lower boundary of the output range
     * @param {number} max The upper boundary of the output range
     * @returns {number} A number in the range [min, max]
     */

    function clamp(value) {
      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      warning_1(value >= min && value <= max, "Material-UI: the value provided ".concat(value, " is out of range [").concat(min, ", ").concat(max, "]."));

      if (value < min) {
        return min;
      }

      if (value > max) {
        return max;
      }

      return value;
    }
    /**
     * Converts a color from CSS hex format to CSS rgb format.
     *
     * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
     * @returns {string} A CSS rgb color string
     */


    function hexToRgb(color) {
      color = color.substr(1);
      var re = new RegExp(".{1,".concat(color.length / 3, "}"), 'g');
      var colors = color.match(re);

      if (colors && colors[0].length === 1) {
        colors = colors.map(function (n) {
          return n + n;
        });
      }

      return colors ? "rgb(".concat(colors.map(function (n) {
        return parseInt(n, 16);
      }).join(', '), ")") : '';
    }
    /**
     * Converts a color from hsl format to rgb format.
     *
     * @param {string} color - HSL color values
     * @returns {string} rgb color values
     */

    function hslToRgb(color) {
      color = decomposeColor(color);
      var _color = color,
          values = _color.values;
      var h = values[0];
      var s = values[1] / 100;
      var l = values[2] / 100;
      var a = s * Math.min(l, 1 - l);

      var f = function f(n) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      };

      var type = 'rgb';
      var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];

      if (color.type === 'hsla') {
        type += 'a';
        rgb.push(values[3]);
      }

      return recomposeColor({
        type: type,
        values: rgb
      });
    }
    /**
     * Returns an object with the type and values of a color.
     *
     * Note: Does not support rgb % values.
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @returns {object} - A MUI color object: {type: string, values: number[]}
     */

    function decomposeColor(color) {
      // Idempotent
      if (color.type) {
        return color;
      }

      if (color.charAt(0) === '#') {
        return decomposeColor(hexToRgb(color));
      }

      var marker = color.indexOf('(');
      var type = color.substring(0, marker);

      if (['rgb', 'rgba', 'hsl', 'hsla'].indexOf(type) === -1) {
        throw new Error(["Material-UI: unsupported `".concat(color, "` color."), 'We support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla().'].join('\n'));
      }

      var values = color.substring(marker + 1, color.length - 1).split(',');
      values = values.map(function (value) {
        return parseFloat(value);
      });
      return {
        type: type,
        values: values
      };
    }
    /**
     * Converts a color object with type and values to a string.
     *
     * @param {object} color - Decomposed color
     * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
     * @param {array} color.values - [n,n,n] or [n,n,n,n]
     * @returns {string} A CSS color string
     */

    function recomposeColor(color) {
      var type = color.type;
      var values = color.values;

      if (type.indexOf('rgb') !== -1) {
        // Only convert the first 3 values to int (i.e. not alpha)
        values = values.map(function (n, i) {
          return i < 3 ? parseInt(n, 10) : n;
        });
      } else if (type.indexOf('hsl') !== -1) {
        values[1] = "".concat(values[1], "%");
        values[2] = "".concat(values[2], "%");
      }

      return "".concat(type, "(").concat(values.join(', '), ")");
    }
    /**
     * Calculates the contrast ratio between two colors.
     *
     * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
     *
     * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @returns {number} A contrast ratio value in the range 0 - 21.
     */

    function getContrastRatio(foreground, background) {
      var lumA = getLuminance(foreground);
      var lumB = getLuminance(background);
      return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    /**
     * The relative brightness of any point in a color space,
     * normalized to 0 for darkest black and 1 for lightest white.
     *
     * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @returns {number} The relative brightness of the color in the range 0 - 1
     */

    function getLuminance(color) {
      color = decomposeColor(color);
      var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
      rgb = rgb.map(function (val) {
        val /= 255; // normalized

        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
      }); // Truncate at 3 digits

      return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    /**
     * Darken or lighten a color, depending on its luminance.
     * Light colors are darkened, dark colors are lightened.
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
     * @returns {string} A CSS color string. Hex input values are returned as rgb
     */

    function emphasize(color) {
      var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;
      return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
    }
    /**
     * Set the absolute transparency of a color.
     * Any existing alpha values are overwritten.
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @param {number} value - value to set the alpha channel to in the range 0 -1
     * @returns {string} A CSS color string. Hex input values are returned as rgb
     */

    function fade(color, value) {
      color = decomposeColor(color);
      value = clamp(value);

      if (color.type === 'rgb' || color.type === 'hsl') {
        color.type += 'a';
      }

      color.values[3] = value;
      return recomposeColor(color);
    }
    /**
     * Darkens a color.
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @param {number} coefficient - multiplier in the range 0 - 1
     * @returns {string} A CSS color string. Hex input values are returned as rgb
     */

    function darken(color, coefficient) {
      color = decomposeColor(color);
      coefficient = clamp(coefficient);

      if (color.type.indexOf('hsl') !== -1) {
        color.values[2] *= 1 - coefficient;
      } else if (color.type.indexOf('rgb') !== -1) {
        for (var i = 0; i < 3; i += 1) {
          color.values[i] *= 1 - coefficient;
        }
      }

      return recomposeColor(color);
    }
    /**
     * Lightens a color.
     *
     * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
     * @param {number} coefficient - multiplier in the range 0 - 1
     * @returns {string} A CSS color string. Hex input values are returned as rgb
     */

    function lighten(color, coefficient) {
      color = decomposeColor(color);
      coefficient = clamp(coefficient);

      if (color.type.indexOf('hsl') !== -1) {
        color.values[2] += (100 - color.values[2]) * coefficient;
      } else if (color.type.indexOf('rgb') !== -1) {
        for (var i = 0; i < 3; i += 1) {
          color.values[i] += (255 - color.values[i]) * coefficient;
        }
      }

      return recomposeColor(color);
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var defineProperty = _defineProperty;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    module.exports = _extends;
    });

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    var objectWithoutProperties = _objectWithoutProperties;

    var umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    	module.exports = factory();
    }(commonjsGlobal, (function () {
    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		Object.keys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	Object.keys(source).forEach(function(key) {
    		if (!options.isMergeableObject(source[key]) || !target[key]) {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		} else {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    return deepmerge_1;

    })));
    });

    /*!
     * isobject <https://github.com/jonschlinkert/isobject>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */

    var isobject = function isObject(val) {
      return val != null && typeof val === 'object' && Array.isArray(val) === false;
    };

    function isObjectObject(o) {
      return isobject(o) === true
        && Object.prototype.toString.call(o) === '[object Object]';
    }

    var isPlainObject = function isPlainObject(o) {
      var ctor,prot;

      if (isObjectObject(o) === false) return false;

      // If has modified constructor
      ctor = o.constructor;
      if (typeof ctor !== 'function') return false;

      // If has modified prototype
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;

      // If constructor does not have an Object-specific method
      if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }

      // Most likely a plain Object
      return true;
    };

    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    var keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.

    function createBreakpoints(breakpoints) {
      var _breakpoints$values = breakpoints.values,
          values = _breakpoints$values === void 0 ? {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920
      } : _breakpoints$values,
          _breakpoints$unit = breakpoints.unit,
          unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit,
          _breakpoints$step = breakpoints.step,
          step = _breakpoints$step === void 0 ? 5 : _breakpoints$step,
          other = objectWithoutProperties(breakpoints, ["values", "unit", "step"]);

      function up(key) {
        var value = typeof values[key] === 'number' ? values[key] : key;
        return "@media (min-width:".concat(value).concat(unit, ")");
      }

      function down(key) {
        var endIndex = keys.indexOf(key) + 1;
        var upperbound = values[keys[endIndex]];

        if (endIndex === keys.length) {
          // xl down applies to all sizes
          return up('xs');
        }

        var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;
        return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
      }

      function between(start, end) {
        var endIndex = keys.indexOf(end) + 1;

        if (endIndex === keys.length) {
          return up(start);
        }

        return "@media (min-width:".concat(values[start]).concat(unit, ") and ") + "(max-width:".concat(values[keys[endIndex]] - step / 100).concat(unit, ")");
      }

      function only(key) {
        return between(key, key);
      }

      function width(key) {
        return values[key];
      }

      return _extends_1({
        keys: keys,
        values: values,
        up: up,
        down: down,
        between: between,
        only: only,
        width: width
      }, other);
    }

    // import warning from 'warning';
    function createMixins(breakpoints, spacing, mixins) {
      var _toolbar;

      return _extends_1({
        gutters: function gutters() {
          var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          // To deprecate in v4.1
          //       warning(
          //         false,
          //         [
          //           'Material-UI: theme.mixins.gutters() is deprecated.',
          //           'You can use the source of the mixin directly:',
          //           `
          // paddingLeft: theme.spacing(2),
          // paddingRight: theme.spacing(2),
          // [theme.breakpoints.up('sm')]: {
          //   paddingLeft: theme.spacing(3),
          //   paddingRight: theme.spacing(3),
          // },
          // `,
          //         ].join('\n'),
          //       );
          return _extends_1({
            paddingLeft: spacing(2),
            paddingRight: spacing(2)
          }, styles, defineProperty({}, breakpoints.up('sm'), _extends_1({
            paddingLeft: spacing(3),
            paddingRight: spacing(3)
          }, styles[breakpoints.up('sm')])));
        },
        toolbar: (_toolbar = {
          minHeight: 56
        }, defineProperty(_toolbar, "".concat(breakpoints.up('xs'), " and (orientation: landscape)"), {
          minHeight: 48
        }), defineProperty(_toolbar, breakpoints.up('sm'), {
          minHeight: 64
        }), _toolbar)
      }, mixins);
    }

    var indigo = {
      50: '#e8eaf6',
      100: '#c5cae9',
      200: '#9fa8da',
      300: '#7986cb',
      400: '#5c6bc0',
      500: '#3f51b5',
      600: '#3949ab',
      700: '#303f9f',
      800: '#283593',
      900: '#1a237e',
      A100: '#8c9eff',
      A200: '#536dfe',
      A400: '#3d5afe',
      A700: '#304ffe'
    };

    var pink = {
      50: '#fce4ec',
      100: '#f8bbd0',
      200: '#f48fb1',
      300: '#f06292',
      400: '#ec407a',
      500: '#e91e63',
      600: '#d81b60',
      700: '#c2185b',
      800: '#ad1457',
      900: '#880e4f',
      A100: '#ff80ab',
      A200: '#ff4081',
      A400: '#f50057',
      A700: '#c51162'
    };

    var grey = {
      50: '#fafafa',
      100: '#f5f5f5',
      200: '#eeeeee',
      300: '#e0e0e0',
      400: '#bdbdbd',
      500: '#9e9e9e',
      600: '#757575',
      700: '#616161',
      800: '#424242',
      900: '#212121',
      A100: '#d5d5d5',
      A200: '#aaaaaa',
      A400: '#303030',
      A700: '#616161'
    };

    var red = {
      50: '#ffebee',
      100: '#ffcdd2',
      200: '#ef9a9a',
      300: '#e57373',
      400: '#ef5350',
      500: '#f44336',
      600: '#e53935',
      700: '#d32f2f',
      800: '#c62828',
      900: '#b71c1c',
      A100: '#ff8a80',
      A200: '#ff5252',
      A400: '#ff1744',
      A700: '#d50000'
    };

    var common = {
      black: '#000',
      white: '#fff'
    };

    var light = {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: 'rgba(0, 0, 0, 0.87)',
        // Secondary text.
        secondary: 'rgba(0, 0, 0, 0.54)',
        // Disabled text have even lower visual prominence.
        disabled: 'rgba(0, 0, 0, 0.38)',
        // Text hints.
        hint: 'rgba(0, 0, 0, 0.38)'
      },
      // The color used to divide different elements.
      divider: 'rgba(0, 0, 0, 0.12)',
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common.white,
        default: grey[50]
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: 'rgba(0, 0, 0, 0.54)',
        // The color of an hovered action.
        hover: 'rgba(0, 0, 0, 0.08)',
        hoverOpacity: 0.08,
        // The color of a selected action.
        selected: 'rgba(0, 0, 0, 0.14)',
        // The color of a disabled action.
        disabled: 'rgba(0, 0, 0, 0.26)',
        // The background color of a disabled action.
        disabledBackground: 'rgba(0, 0, 0, 0.12)'
      }
    };
    var dark = {
      text: {
        primary: common.white,
        secondary: 'rgba(255, 255, 255, 0.7)',
        disabled: 'rgba(255, 255, 255, 0.5)',
        hint: 'rgba(255, 255, 255, 0.5)',
        icon: 'rgba(255, 255, 255, 0.5)'
      },
      divider: 'rgba(255, 255, 255, 0.12)',
      background: {
        paper: grey[800],
        default: '#303030'
      },
      action: {
        active: common.white,
        hover: 'rgba(255, 255, 255, 0.1)',
        hoverOpacity: 0.1,
        selected: 'rgba(255, 255, 255, 0.2)',
        disabled: 'rgba(255, 255, 255, 0.3)',
        disabledBackground: 'rgba(255, 255, 255, 0.12)'
      }
    };

    function addLightOrDark(intent, direction, shade, tonalOffset) {
      if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
          intent[direction] = intent[shade];
        } else if (direction === 'light') {
          intent.light = lighten(intent.main, tonalOffset);
        } else if (direction === 'dark') {
          intent.dark = darken(intent.main, tonalOffset * 1.5);
        }
      }
    }

    function createPalette(palette) {
      var _palette$primary = palette.primary,
          primary = _palette$primary === void 0 ? {
        light: indigo[300],
        main: indigo[500],
        dark: indigo[700]
      } : _palette$primary,
          _palette$secondary = palette.secondary,
          secondary = _palette$secondary === void 0 ? {
        light: pink.A200,
        main: pink.A400,
        dark: pink.A700
      } : _palette$secondary,
          _palette$error = palette.error,
          error = _palette$error === void 0 ? {
        light: red[300],
        main: red[500],
        dark: red[700]
      } : _palette$error,
          _palette$type = palette.type,
          type = _palette$type === void 0 ? 'light' : _palette$type,
          _palette$contrastThre = palette.contrastThreshold,
          contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,
          _palette$tonalOffset = palette.tonalOffset,
          tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,
          other = objectWithoutProperties(palette, ["primary", "secondary", "error", "type", "contrastThreshold", "tonalOffset"]); // Use the same logic as
      // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
      // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54


      function getContrastText(background) {
        warning_1(background, "Material-UI: missing background argument in getContrastText(".concat(background, ")."));
        var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;

        {
          var contrast = getContrastRatio(background, contrastText);
          warning_1(contrast >= 3, ["Material-UI: the contrast ratio of ".concat(contrast, ":1 for ").concat(contrastText, " on ").concat(background), 'falls below the WACG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
        }

        return contrastText;
      }

      function augmentColor(color) {
        var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
        var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
        var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
        color = _extends_1({}, color);

        if (!color.main && color[mainShade]) {
          color.main = color[mainShade];
        }

        if (!color.main) {
          throw new Error(['Material-UI: the color provided to augmentColor(color) is invalid.', "The color object needs to have a `main` property or a `".concat(mainShade, "` property.")].join('\n'));
        }

        addLightOrDark(color, 'light', lightShade, tonalOffset);
        addLightOrDark(color, 'dark', darkShade, tonalOffset);

        if (!color.contrastText) {
          color.contrastText = getContrastText(color.main);
        }

        return color;
      }

      var types = {
        dark: dark,
        light: light
      };
      warning_1(types[type], "Material-UI: the palette type `".concat(type, "` is not supported."));
      var paletteOutput = umd(_extends_1({
        // A collection of common colors.
        common: common,
        // The palette type, can be light or dark.
        type: type,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor(primary),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor(error),
        // The grey colors.
        grey: grey,
        // Used by `getContrastText()` to maximize the contrast between the background and
        // the text.
        contrastThreshold: contrastThreshold,
        // Take a background color and return the color of the text to maximize the contrast.
        getContrastText: getContrastText,
        // Generate a rich color object.
        augmentColor: augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset: tonalOffset
      }, types[type]), other, {
        clone: false // No need to clone deep

      });
      return paletteOutput;
    }

    function round(value) {
      return Math.round(value * 1e5) / 1e5;
    }

    var caseAllCaps = {
      textTransform: 'uppercase'
    };
    var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    /**
     * @see @link{https://material.io/design/typography/the-type-system.html}
     * @see @link{https://material.io/design/typography/understanding-typography.html}
     */

    function createTypography(palette, typography) {
      var _ref = typeof typography === 'function' ? typography(palette) : typography,
          _ref$fontFamily = _ref.fontFamily,
          fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily,
          _ref$fontSize = _ref.fontSize,
          fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize,
          _ref$fontWeightLight = _ref.fontWeightLight,
          fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight,
          _ref$fontWeightRegula = _ref.fontWeightRegular,
          fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula,
          _ref$fontWeightMedium = _ref.fontWeightMedium,
          fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium,
          _ref$htmlFontSize = _ref.htmlFontSize,
          htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize,
          allVariants = _ref.allVariants,
          other = objectWithoutProperties(_ref, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "htmlFontSize", "allVariants"]);

      var coef = fontSize / 14;

      var pxToRem = function pxToRem(size) {
        return "".concat(size / htmlFontSize * coef, "rem");
      };

      var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {
        return _extends_1({
          // color: palette.text.primary,
          fontFamily: fontFamily,
          fontWeight: fontWeight,
          fontSize: pxToRem(size),
          // Unitless following http://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
          lineHeight: lineHeight
        }, fontFamily === defaultFontFamily ? {
          letterSpacing: "".concat(round(letterSpacing / size), "em")
        } : {}, casing, allVariants);
      };

      var variants = {
        h1: buildVariant(fontWeightLight, 96, 1, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.04, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.17, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.33, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
      };
      return umd(_extends_1({
        htmlFontSize: htmlFontSize,
        pxToRem: pxToRem,
        round: round,
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontWeightLight: fontWeightLight,
        fontWeightRegular: fontWeightRegular,
        fontWeightMedium: fontWeightMedium
      }, variants), other, {
        clone: false // No need to clone deep

      });
    }

    var shadowKeyUmbraOpacity = 0.2;
    var shadowKeyPenumbraOpacity = 0.14;
    var shadowAmbientShadowOpacity = 0.12;

    function createShadow() {
      return ["".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"), "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"), "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")].join(',');
    }

    var shadows = ['none', createShadow(0, 1, 3, 0, 0, 1, 1, 0, 0, 2, 1, -1), createShadow(0, 1, 5, 0, 0, 2, 2, 0, 0, 3, 1, -2), createShadow(0, 1, 8, 0, 0, 3, 4, 0, 0, 3, 3, -2), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];

    var shape = {
      borderRadius: 4
    };

    var warnOnce;
    function createSpacing() {
      var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;

      // Already transformed.
      if (spacingInput.mui) {
        return spacingInput;
      } // All components align to an 8dp square baseline grid for mobile, tablet, and desktop.
      // https://material.io/design/layout/understanding-layout.html#pixel-density


      var transform;

      if (typeof spacingInput === 'function') {
        transform = spacingInput;
      } else {
        warning_1(typeof spacingInput === 'number', ["Material-UI: the `theme.spacing` value (".concat(spacingInput, ") is invalid."), 'It should be a number or a function.'].join('\n'));

        transform = function transform(factor) {
          warning_1(typeof factor === 'number', "Expected spacing argument to be a number, got ".concat(factor));
          return spacingInput * factor;
        };
      }

      var spacing = function spacing() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        warning_1(args.length <= 4, "Too many arguments, expected [1, 4], got ".concat(args.length));

        if (args.length === 1) {
          return transform(args[0]);
        }

        return args.map(function (factor) {
          var output = transform(factor);
          return typeof output === 'number' ? "".concat(output, "px") : output;
        }).join(' ');
      }; // Backward compatibility, to remove in v5.


      Object.defineProperty(spacing, 'unit', {
        get: function get() {
          {
            warning_1(warnOnce && "development" !== 'test', ['Material-UI: theme.spacing.unit usage has been deprecated.', 'It will be removed in v5.', 'You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.', '', 'You can use the `https://github.com/mui-org/material-ui/tree/master/packages/material-ui-codemod/README.md#theme-spacing-api` migration helper to make the process smoother.'].join('\n'));
            warnOnce = true;
          }

          return spacingInput;
        }
      });
      spacing.mui = true;
      return spacing;
    }

    // to learn the context in which each easing should be used.

    var easing = {
      // This is the most common easing curve.
      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
    }; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
    // to learn when use what timing

    var duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195
    };
    var formatMs = function formatMs(milliseconds) {
      return "".concat(Math.round(milliseconds), "ms");
    };
    var isString = function isString(value) {
      return typeof value === 'string';
    };
    var isNumber = function isNumber(value) {
      return !isNaN(parseFloat(value));
    };
    /**
     * @param {string|Array} props
     * @param {object} param
     * @param {string} param.prop
     * @param {number} param.duration
     * @param {string} param.easing
     * @param {number} param.delay
     */

    var transitions = {
      easing: easing,
      duration: duration,
      create: function create() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['all'];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var _options$duration = options.duration,
            durationOption = _options$duration === void 0 ? duration.standard : _options$duration,
            _options$easing = options.easing,
            easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing,
            _options$delay = options.delay,
            delay = _options$delay === void 0 ? 0 : _options$delay,
            other = objectWithoutProperties(options, ["duration", "easing", "delay"]);

        warning_1(isString(props) || Array.isArray(props), 'Material-UI: argument "props" must be a string or Array.');
        warning_1(isNumber(durationOption) || isString(durationOption), "Material-UI: argument \"duration\" must be a number or a string but found ".concat(durationOption, "."));
        warning_1(isString(easingOption), 'Material-UI: argument "easing" must be a string.');
        warning_1(isNumber(delay) || isString(delay), 'Material-UI: argument "delay" must be a number or a string.');
        warning_1(Object.keys(other).length === 0, "Material-UI: unrecognized argument(s) [".concat(Object.keys(other).join(','), "]"));
        return (Array.isArray(props) ? props : [props]).map(function (animatedProp) {
          return "".concat(animatedProp, " ").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === 'string' ? delay : formatMs(delay));
        }).join(',');
      },
      getAutoHeightDuration: function getAutoHeightDuration(height) {
        if (!height) {
          return 0;
        }

        var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

        return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
      }
    };

    // We need to centralize the zIndex definitions as they work
    // like global values in the browser.
    var zIndex = {
      mobileStepper: 1000,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };

    function createMuiTheme() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _options$breakpoints = options.breakpoints,
          breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints,
          _options$mixins = options.mixins,
          mixinsInput = _options$mixins === void 0 ? {} : _options$mixins,
          _options$palette = options.palette,
          paletteInput = _options$palette === void 0 ? {} : _options$palette,
          shadowsInput = options.shadows,
          spacingInput = options.spacing,
          _options$typography = options.typography,
          typographyInput = _options$typography === void 0 ? {} : _options$typography,
          other = objectWithoutProperties(options, ["breakpoints", "mixins", "palette", "shadows", "spacing", "typography"]);

      var palette = createPalette(paletteInput);
      var breakpoints = createBreakpoints(breakpointsInput);
      var spacing = createSpacing(spacingInput);

      var muiTheme = _extends_1({
        breakpoints: breakpoints,
        direction: 'ltr',
        mixins: createMixins(breakpoints, spacing, mixinsInput),
        overrides: {},
        // Inject custom styles
        palette: palette,
        props: {},
        // Inject custom properties
        shadows: shadowsInput || shadows,
        typography: createTypography(palette, typographyInput),
        spacing: spacing
      }, umd({
        shape: shape,
        transitions: transitions,
        zIndex: zIndex
      }, other, {
        isMergeableObject: isPlainObject
      }));

      {
        var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected'];

        var traverse = function traverse(node, parentKey) {
          var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var key; // eslint-disable-next-line guard-for-in, no-restricted-syntax

          for (key in node) {
            var child = node[key];

            if (depth === 1) {
              if (key.indexOf('Mui') === 0 && child) {
                traverse(child, key, depth + 1);
              }
            } else if (pseudoClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
              warning_1(false, ["Material-UI: the `".concat(parentKey, "` component increases ") + "the CSS specificity of the `".concat(key, "` internal state."), 'You can not override it like this: ', JSON.stringify(node, null, 2), '', 'Instead, you need to use the $ruleName syntax:', JSON.stringify({
                root: defineProperty({}, "&$".concat(key), child)
              }, null, 2), '', 'https://material-ui.com/customization/components/#pseudo-classes'].join('\n')); // Remove the style to prevent global conflicts.

              node[key] = {};
            }
          }
        };

        traverse(muiTheme.overrides);
      }

      warning_1(muiTheme.shadows.length === 25, 'Material-UI: the shadows array provided to createMuiTheme should support 25 elevations.');
      return muiTheme;
    }

    // import warning from 'warning';
    // To remove in v5

    function createStyles(styles) {
      // warning(
      //   warnOnce,
      //   [
      //     'Material-UI: createStyles from @material-ui/core/styles is deprecated.',
      //     'Please use @material-ui/styles/createStyles',
      //   ].join('\n'),
      // );
      // warnOnce = true;
      return styles$1O.createStyles(styles);
    }

    var defaultTheme = createMuiTheme();

    function makeStyles(stylesOrCreator) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return styles$1O.makeStyles(stylesOrCreator, _extends_1({
        defaultTheme: defaultTheme
      }, options));
    }

    var styled = function styled(Component) {
      var componentCreator = styles$1O.styled(Component);
      return function (style, options) {
        return componentCreator(style, _extends_1({
          defaultTheme: defaultTheme
        }, options));
      };
    };

    function useTheme() {
      return styles$1O.useTheme() || defaultTheme;
    }

    function withStyles(stylesOrCreator, options) {
      return styles$1O.withStyles(stylesOrCreator, _extends_1({
        defaultTheme: defaultTheme
      }, options));
    }

    var withTheme = styles$1O.withThemeCreator({
      defaultTheme: defaultTheme
    });

    var useStyles = makeStyles(function (theme) {
      var textColor = theme.palette.type === 'light' ? theme.palette.primary.contrastText : theme.palette.getContrastText(theme.palette.background.default);
      return {
        toolbarTxt: {
          color: fade(textColor, 0.54)
        },
        toolbarBtnSelected: {
          color: textColor
        }
      };
    }, {
      name: 'MuiPickersToolbarText'
    });

    var ToolbarText = function (_a) {
      var _b;

      var selected = _a.selected,
          label = _a.label,
          _c = _a.className,
          className = _c === void 0 ? null : _c,
          other = __rest(_a, ["selected", "label", "className"]);

      var classes = useStyles();
      return React.createElement(Typography$2, __assign({
        children: label,
        className: clsx(classes.toolbarTxt, className, (_b = {}, _b[classes.toolbarBtnSelected] = selected, _b))
      }, other));
    };

    var ToolbarButton = function (_a) {
      var classes = _a.classes,
          _b = _a.className,
          className = _b === void 0 ? null : _b,
          label = _a.label,
          selected = _a.selected,
          variant = _a.variant,
          typographyClassName = _a.typographyClassName,
          other = __rest(_a, ["classes", "className", "label", "selected", "variant", "typographyClassName"]);

      return React.createElement(Button$1, __assign({
        variant: "text",
        className: clsx(classes.toolbarBtn, className)
      }, other), React.createElement(ToolbarText, {
        className: typographyClassName,
        variant: variant,
        label: label,
        selected: selected
      }));
    };

    ToolbarButton.propTypes = {
      selected: PropTypes.bool.isRequired,
      label: PropTypes.string.isRequired,
      classes: PropTypes.any.isRequired,
      className: PropTypes.string,
      innerRef: PropTypes.any
    };
    ToolbarButton.defaultProps = {
      className: ''
    };
    var styles = createStyles({
      toolbarBtn: {
        padding: 0,
        minWidth: '16px',
        textTransform: 'none'
      }
    });
    var ToolbarButton$1 = withStyles(styles, {
      name: 'MuiPickersToolbarButton'
    })(ToolbarButton);

    var PickerToolbar = function (_a) {
      var children = _a.children,
          _b = _a.className,
          className = _b === void 0 ? null : _b,
          classes = _a.classes,
          other = __rest(_a, ["children", "className", "classes"]);

      return React.createElement(Toolbar$2, __assign({
        className: clsx(classes.toolbar, className)
      }, other), children);
    };

    var styles$1 = function (theme) {
      return createStyles({
        toolbar: {
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'flex-start',
          justifyContent: 'center',
          height: 100,
          backgroundColor: theme.palette.type === 'light' ? theme.palette.primary.main : theme.palette.background.default
        }
      });
    };
    var PickerToolbar$1 = withStyles(styles$1, {
      name: 'MuiPickersToolbar'
    })(PickerToolbar);

    var findClosestEnabledDate = function (_a) {
      var date = _a.date,
          utils = _a.utils,
          minDate = _a.minDate,
          maxDate = _a.maxDate,
          disableFuture = _a.disableFuture,
          disablePast = _a.disablePast,
          shouldDisableDate = _a.shouldDisableDate;
      var today = utils.startOfDay(utils.date());

      if (disablePast && utils.isBefore(minDate, today)) {
        minDate = today;
      }

      if (disableFuture && utils.isAfter(maxDate, today)) {
        maxDate = today;
      }

      var forward = date;
      var backward = date;

      if (utils.isBefore(date, minDate)) {
        forward = utils.date(minDate);
        backward = null;
      }

      if (utils.isAfter(date, maxDate)) {
        if (backward) {
          backward = utils.date(maxDate);
        }

        forward = null;
      }

      while (forward || backward) {
        if (forward && utils.isAfter(forward, maxDate)) {
          forward = null;
        }

        if (backward && utils.isBefore(backward, minDate)) {
          backward = null;
        }

        if (forward) {
          if (!shouldDisableDate(forward)) {
            return forward;
          }

          forward = utils.addDays(forward, 1);
        }

        if (backward) {
          if (!shouldDisableDate(backward)) {
            return backward;
          }

          backward = utils.addDays(backward, -1);
        }
      }

      return null;
    };
    var isYearOnlyView = function (views) {
      return views.length === 1 && views[0] === 'year';
    };
    var isYearAndMonthViews = function (views) {
      return views.length === 2 && views.includes('month') && views.includes('year');
    };
    var getFormatByViews = function (views, utils) {
      if (isYearOnlyView(views)) {
        return utils.yearFormat;
      }

      if (isYearAndMonthViews(views)) {
        return utils.yearMonthFormat;
      }

      return utils.dateFormat;
    };

    var useStyles$1 = makeStyles({
      toolbarCenter: {
        flexDirection: 'row',
        alignItems: 'center'
      }
    }, {
      name: 'MuiPickersDatePickerRoot'
    });
    var DatePickerToolbar = function (_a) {
      var _b;

      var date = _a.date,
          views = _a.views,
          setOpenView = _a.setOpenView,
          openView = _a.openView;
      var utils = useUtils();
      var classes = useStyles$1();
      var isYearOnly = React.useMemo(function () {
        return isYearOnlyView(views);
      }, [views]);
      var isYearAndMonth = React.useMemo(function () {
        return isYearAndMonthViews(views);
      }, [views]);
      return React.createElement(PickerToolbar$1, {
        className: clsx((_b = {}, _b[classes.toolbarCenter] = isYearOnly, _b))
      }, React.createElement(ToolbarButton$1, {
        variant: isYearOnly ? 'h3' : 'subtitle1',
        onClick: function () {
          return setOpenView('year');
        },
        selected: openView === 'year',
        label: utils.getYearText(date)
      }), !isYearOnly && !isYearAndMonth && React.createElement(ToolbarButton$1, {
        variant: "h4",
        onClick: function () {
          return setOpenView('date');
        },
        selected: openView === 'date',
        label: utils.getDatePickerHeaderText(date)
      }), isYearAndMonth && React.createElement(ToolbarButton$1, {
        variant: "h4",
        onClick: function () {
          return setOpenView('month');
        },
        selected: openView === 'month',
        label: utils.getMonthText(date)
      }));
    };

    var date = PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.number, PropTypes.instanceOf(Date)]);
    var datePickerView = PropTypes.oneOf(['year', 'month', 'day']);
    /* eslint-disable @typescript-eslint/no-object-literal-type-assertion */

    var timePickerDefaultProps = {
      ampm: true,
      invalidDateMessage: 'Invalid Time Format'
    };
    var datePickerDefaultProps = {
      minDate: new Date('1900-01-01'),
      maxDate: new Date('2100-01-01'),
      invalidDateMessage: 'Invalid Date Format',
      minDateMessage: 'Date should not be before minimal date',
      maxDateMessage: 'Date should not be after maximal date',
      allowKeyboardControl: true
    };
    var dateTimePickerDefaultProps = __assign({}, timePickerDefaultProps, datePickerDefaultProps, {
      showTabs: true
    });

    var useStyles$2 = makeStyles(function (theme) {
      return {
        day: {
          width: 36,
          height: 36,
          fontSize: theme.typography.caption.fontSize,
          margin: '0 2px',
          color: theme.palette.text.primary,
          fontWeight: theme.typography.fontWeightMedium,
          padding: 0
        },
        hidden: {
          opacity: 0,
          pointerEvents: 'none'
        },
        current: {
          color: theme.palette.primary.main,
          fontWeight: 600
        },
        daySelected: {
          color: theme.palette.primary.contrastText,
          backgroundColor: theme.palette.primary.main,
          fontWeight: theme.typography.fontWeightMedium,
          '&:hover': {
            backgroundColor: theme.palette.primary.main
          }
        },
        dayDisabled: {
          pointerEvents: 'none',
          color: theme.palette.text.hint
        }
      };
    }, {
      name: 'MuiPickersDay'
    });
    var Day = function (_a) {
      var _b;

      var children = _a.children,
          disabled = _a.disabled,
          hidden = _a.hidden,
          current = _a.current,
          selected = _a.selected,
          other = __rest(_a, ["children", "disabled", "hidden", "current", "selected"]);

      var classes = useStyles$2();
      var className = clsx(classes.day, (_b = {}, _b[classes.hidden] = hidden, _b[classes.current] = current, _b[classes.daySelected] = selected, _b[classes.dayDisabled] = disabled, _b));
      return React.createElement(IconButton$2, __assign({
        className: className,
        tabIndex: hidden || disabled ? -1 : 0
      }, other), React.createElement(Typography$2, {
        variant: "body2",
        color: "inherit"
      }, children));
    };
    Day.displayName = 'Day';
    Day.propTypes = {
      current: PropTypes.bool,
      disabled: PropTypes.bool,
      hidden: PropTypes.bool,
      selected: PropTypes.bool
    };
    Day.defaultProps = {
      disabled: false,
      hidden: false,
      current: false,
      selected: false
    };

    var DayWrapper = function (_a) {
      var children = _a.children,
          value = _a.value,
          disabled = _a.disabled,
          onSelect = _a.onSelect,
          dayInCurrentMonth = _a.dayInCurrentMonth,
          other = __rest(_a, ["children", "value", "disabled", "onSelect", "dayInCurrentMonth"]);

      var handleClick = React.useCallback(function () {
        return onSelect(value);
      }, [onSelect, value]);
      return React.createElement("div", __assign({
        role: "presentation",
        onClick: dayInCurrentMonth && !disabled ? handleClick : undefined,
        onKeyPress: dayInCurrentMonth && !disabled ? handleClick : undefined
      }, other), children);
    };

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    var interopRequireDefault = createCommonjsModule(function (module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    module.exports = _interopRequireDefault;
    });

    unwrapExports(interopRequireDefault);

    var hasClass_1 = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports.default = hasClass;

    function hasClass(element, className) {
      if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }

    module.exports = exports["default"];
    });

    unwrapExports(hasClass_1);

    var addClass_1 = createCommonjsModule(function (module, exports) {



    exports.__esModule = true;
    exports.default = addClass;

    var _hasClass = interopRequireDefault(hasClass_1);

    function addClass(element, className) {
      if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
    }

    module.exports = exports["default"];
    });

    var addOneClass = unwrapExports(addClass_1);

    function replaceClassName(origClass, classToRemove) {
      return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
    }

    var removeClass = function removeClass(element, className) {
      if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
    };

    var config = {
      disabled: false
    };

    var timeoutsShape = PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
      enter: PropTypes__default.number,
      exit: PropTypes__default.number,
      appear: PropTypes__default.number
    }).isRequired]);
    var classNamesShape = PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.shape({
      enter: PropTypes__default.string,
      exit: PropTypes__default.string,
      active: PropTypes__default.string
    }), PropTypes__default.shape({
      enter: PropTypes__default.string,
      enterDone: PropTypes__default.string,
      enterActive: PropTypes__default.string,
      exit: PropTypes__default.string,
      exitDone: PropTypes__default.string,
      exitActive: PropTypes__default.string
    })]);

    var TransitionGroupContext = React__default.createContext(null);

    var UNMOUNTED = 'unmounted';
    var EXITED = 'exited';
    var ENTERING = 'entering';
    var ENTERED = 'entered';
    var EXITING = 'exiting';
    /**
     * The Transition component lets you describe a transition from one component
     * state to another _over time_ with a simple declarative API. Most commonly
     * it's used to animate the mounting and unmounting of a component, but can also
     * be used to describe in-place transition states as well.
     *
     * ---
     *
     * **Note**: `Transition` is a platform-agnostic base component. If you're using
     * transitions in CSS, you'll probably want to use
     * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
     * instead. It inherits all the features of `Transition`, but contains
     * additional features necessary to play nice with CSS transitions (hence the
     * name of the component).
     *
     * ---
     *
     * By default the `Transition` component does not alter the behavior of the
     * component it renders, it only tracks "enter" and "exit" states for the
     * components. It's up to you to give meaning and effect to those states. For
     * example we can add styles to a component when it enters or exits:
     *
     * ```jsx
     * import { Transition } from 'react-transition-group';
     *
     * const duration = 300;
     *
     * const defaultStyle = {
     *   transition: `opacity ${duration}ms ease-in-out`,
     *   opacity: 0,
     * }
     *
     * const transitionStyles = {
     *   entering: { opacity: 1 },
     *   entered:  { opacity: 1 },
     *   exiting:  { opacity: 0 },
     *   exited:  { opacity: 0 },
     * };
     *
     * const Fade = ({ in: inProp }) => (
     *   <Transition in={inProp} timeout={duration}>
     *     {state => (
     *       <div style={{
     *         ...defaultStyle,
     *         ...transitionStyles[state]
     *       }}>
     *         I'm a fade Transition!
     *       </div>
     *     )}
     *   </Transition>
     * );
     * ```
     *
     * There are 4 main states a Transition can be in:
     *  - `'entering'`
     *  - `'entered'`
     *  - `'exiting'`
     *  - `'exited'`
     *
     * Transition state is toggled via the `in` prop. When `true` the component
     * begins the "Enter" stage. During this stage, the component will shift from
     * its current transition state, to `'entering'` for the duration of the
     * transition and then to the `'entered'` stage once it's complete. Let's take
     * the following example (we'll use the
     * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <Transition in={inProp} timeout={500}>
     *         {state => (
     *           // ...
     *         )}
     *       </Transition>
     *       <button onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the button is clicked the component will shift to the `'entering'` state
     * and stay there for 500ms (the value of `timeout`) before it finally switches
     * to `'entered'`.
     *
     * When `in` is `false` the same thing happens except the state moves from
     * `'exiting'` to `'exited'`.
     */

    var Transition =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(Transition, _React$Component);

      function Transition(props, context) {
        var _this;

        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;

        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }

        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }

      Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;

        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }

        return null;
      }; // getSnapshotBeforeUpdate(prevProps) {
      //   let nextStatus = null
      //   if (prevProps !== this.props) {
      //     const { status } = this.state
      //     if (this.props.in) {
      //       if (status !== ENTERING && status !== ENTERED) {
      //         nextStatus = ENTERING
      //       }
      //     } else {
      //       if (status === ENTERING || status === ENTERED) {
      //         nextStatus = EXITING
      //       }
      //     }
      //   }
      //   return { nextStatus }
      // }


      var _proto = Transition.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;

        if (prevProps !== this.props) {
          var status = this.state.status;

          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }

        this.updateStatus(false, nextStatus);
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };

      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;

        if (timeout != null && typeof timeout !== 'number') {
          exit = timeout.exit;
          enter = timeout.enter; // TODO: remove fallback for next major

          appear = timeout.appear !== undefined ? timeout.appear : enter;
        }

        return {
          exit: exit,
          enter: enter,
          appear: appear
        };
      };

      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }

        if (nextStatus !== null) {
          // nextStatus will always be ENTERING or EXITING.
          this.cancelNextCallback();
          var node = ReactDOM__default.findDOMNode(this);

          if (nextStatus === ENTERING) {
            this.performEnter(node, mounting);
          } else {
            this.performExit(node);
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };

      _proto.performEnter = function performEnter(node, mounting) {
        var _this2 = this;

        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
        // if we are mounting and running this it means appear _must_ be set

        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(node);
          });
          return;
        }

        this.props.onEnter(node, appearing);
        this.safeSetState({
          status: ENTERING
        }, function () {
          _this2.props.onEntering(node, appearing);

          _this2.onTransitionEnd(node, enterTimeout, function () {
            _this2.safeSetState({
              status: ENTERED
            }, function () {
              _this2.props.onEntered(node, appearing);
            });
          });
        });
      };

      _proto.performExit = function performExit(node) {
        var _this3 = this;

        var exit = this.props.exit;
        var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(node);
          });
          return;
        }

        this.props.onExit(node);
        this.safeSetState({
          status: EXITING
        }, function () {
          _this3.props.onExiting(node);

          _this3.onTransitionEnd(node, timeouts.exit, function () {
            _this3.safeSetState({
              status: EXITED
            }, function () {
              _this3.props.onExited(node);
            });
          });
        });
      };

      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };

      _proto.safeSetState = function safeSetState(nextState, callback) {
        // This shouldn't be necessary, but there are weird race conditions with
        // setState callbacks and unmounting in testing, so always make sure that
        // we can cancel any pending setState callbacks after we unmount.
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };

      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;

        var active = true;

        this.nextCallback = function (event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };

        this.nextCallback.cancel = function () {
          active = false;
        };

        return this.nextCallback;
      };

      _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
        this.setNextCallback(handler);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

        if (!node || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }

        if (this.props.addEndListener) {
          this.props.addEndListener(node, this.nextCallback);
        }

        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };

      _proto.render = function render() {
        var status = this.state.status;

        if (status === UNMOUNTED) {
          return null;
        }

        var _this$props = this.props,
            children = _this$props.children,
            childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children"]); // filter props for Transtition


        delete childProps.in;
        delete childProps.mountOnEnter;
        delete childProps.unmountOnExit;
        delete childProps.appear;
        delete childProps.enter;
        delete childProps.exit;
        delete childProps.timeout;
        delete childProps.addEndListener;
        delete childProps.onEnter;
        delete childProps.onEntering;
        delete childProps.onEntered;
        delete childProps.onExit;
        delete childProps.onExiting;
        delete childProps.onExited;

        if (typeof children === 'function') {
          // allows for nested Transitions
          return React__default.createElement(TransitionGroupContext.Provider, {
            value: null
          }, children(status, childProps));
        }

        var child = React__default.Children.only(children);
        return (// allows for nested Transitions
          React__default.createElement(TransitionGroupContext.Provider, {
            value: null
          }, React__default.cloneElement(child, childProps))
        );
      };

      return Transition;
    }(React__default.Component);

    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {
      /**
       * A `function` child can be used instead of a React element. This function is
       * called with the current transition status (`'entering'`, `'entered'`,
       * `'exiting'`, `'exited'`), which can be used to apply context
       * specific props to a component.
       *
       * ```jsx
       * <Transition in={this.state.in} timeout={150}>
       *   {state => (
       *     <MyComponent className={`fade fade-${state}`} />
       *   )}
       * </Transition>
       * ```
       */
      children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

      /**
       * Show the component; triggers the enter or exit states
       */
      in: PropTypes.bool,

      /**
       * By default the child component is mounted immediately along with
       * the parent `Transition` component. If you want to "lazy mount" the component on the
       * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
       * mounted, even on "exited", unless you also specify `unmountOnExit`.
       */
      mountOnEnter: PropTypes.bool,

      /**
       * By default the child component stays mounted after it reaches the `'exited'` state.
       * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
       */
      unmountOnExit: PropTypes.bool,

      /**
       * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
       * If you want to transition on the first mount set `appear` to `true`, and the
       * component will transition in as soon as the `<Transition>` mounts.
       *
       * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
       */
      appear: PropTypes.bool,

      /**
       * Enable or disable enter transitions.
       */
      enter: PropTypes.bool,

      /**
       * Enable or disable exit transitions.
       */
      exit: PropTypes.bool,

      /**
       * The duration of the transition, in milliseconds.
       * Required unless `addEndListener` is provided.
       *
       * You may specify a single timeout for all transitions:
       *
       * ```jsx
       * timeout={500}
       * ```
       *
       * or individually:
       *
       * ```jsx
       * timeout={{
       *  appear: 500,
       *  enter: 300,
       *  exit: 500,
       * }}
       * ```
       *
       * - `appear` defaults to the value of `enter`
       * - `enter` defaults to `0`
       * - `exit` defaults to `0`
       *
       * @type {number | { enter?: number, exit?: number, appear?: number }}
       */
      timeout: function timeout(props) {
        var pt = timeoutsShape;
        if (!props.addEndListener) pt = pt.isRequired;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return pt.apply(void 0, [props].concat(args));
      },

      /**
       * Add a custom transition end trigger. Called with the transitioning
       * DOM node and a `done` callback. Allows for more fine grained transition end
       * logic. **Note:** Timeouts are still used as a fallback if provided.
       *
       * ```jsx
       * addEndListener={(node, done) => {
       *   // use the css transitionend event to mark the finish of a transition
       *   node.addEventListener('transitionend', done, false);
       * }}
       * ```
       */
      addEndListener: PropTypes.func,

      /**
       * Callback fired before the "entering" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * @type Function(node: HtmlElement, isAppearing: bool) -> void
       */
      onEnter: PropTypes.func,

      /**
       * Callback fired after the "entering" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntering: PropTypes.func,

      /**
       * Callback fired after the "entered" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * @type Function(node: HtmlElement, isAppearing: bool) -> void
       */
      onEntered: PropTypes.func,

      /**
       * Callback fired before the "exiting" status is applied.
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExit: PropTypes.func,

      /**
       * Callback fired after the "exiting" status is applied.
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExiting: PropTypes.func,

      /**
       * Callback fired after the "exited" status is applied.
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExited: PropTypes.func // Name the function so it is clearer in the documentation

    };

    function noop() {}

    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop,
      onEntering: noop,
      onEntered: noop,
      onExit: noop,
      onExiting: noop,
      onExited: noop
    };
    Transition.UNMOUNTED = 0;
    Transition.EXITED = 1;
    Transition.ENTERING = 2;
    Transition.ENTERED = 3;
    Transition.EXITING = 4;

    var _addClass = function addClass(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return addOneClass(node, c);
      });
    };

    var removeClass$1 = function removeClass$1(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return removeClass(node, c);
      });
    };
    /**
     * A transition component inspired by the excellent
     * [ng-animate](http://www.nganimate.org/) library, you should use it if you're
     * using CSS transitions or animations. It's built upon the
     * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
     * component, so it inherits all of its props.
     *
     * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
     * and `exit` states of the transition. The first class is applied and then a
     * second `*-active` class in order to activate the CSS transition. After the
     * transition, matching `*-done` class names are applied to persist the
     * transition state.
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
     *         <div>
     *           {"I'll receive my-node-* classes"}
     *         </div>
     *       </CSSTransition>
     *       <button type="button" onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the `in` prop is set to `true`, the child component will first receive
     * the class `example-enter`, then the `example-enter-active` will be added in
     * the next tick. `CSSTransition` [forces a
     * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
     * between before adding the `example-enter-active`. This is an important trick
     * because it allows us to transition between `example-enter` and
     * `example-enter-active` even though they were added immediately one after
     * another. Most notably, this is what makes it possible for us to animate
     * _appearance_.
     *
     * ```css
     * .my-node-enter {
     *   opacity: 0;
     * }
     * .my-node-enter-active {
     *   opacity: 1;
     *   transition: opacity 200ms;
     * }
     * .my-node-exit {
     *   opacity: 1;
     * }
     * .my-node-exit-active {
     *   opacity: 0;
     *   transition: opacity 200ms;
     * }
     * ```
     *
     * `*-active` classes represent which styles you want to animate **to**.
     */


    var CSSTransition =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(CSSTransition, _React$Component);

      function CSSTransition() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        };

        _this.onEnter = function (node, appearing) {
          _this.removeClasses(node, 'exit');

          _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

          if (_this.props.onEnter) {
            _this.props.onEnter(node, appearing);
          }
        };

        _this.onEntering = function (node, appearing) {
          var type = appearing ? 'appear' : 'enter';

          _this.addClass(node, type, 'active');

          if (_this.props.onEntering) {
            _this.props.onEntering(node, appearing);
          }
        };

        _this.onEntered = function (node, appearing) {
          var type = appearing ? 'appear' : 'enter';

          _this.removeClasses(node, type);

          _this.addClass(node, type, 'done');

          if (_this.props.onEntered) {
            _this.props.onEntered(node, appearing);
          }
        };

        _this.onExit = function (node) {
          _this.removeClasses(node, 'appear');

          _this.removeClasses(node, 'enter');

          _this.addClass(node, 'exit', 'base');

          if (_this.props.onExit) {
            _this.props.onExit(node);
          }
        };

        _this.onExiting = function (node) {
          _this.addClass(node, 'exit', 'active');

          if (_this.props.onExiting) {
            _this.props.onExiting(node);
          }
        };

        _this.onExited = function (node) {
          _this.removeClasses(node, 'exit');

          _this.addClass(node, 'exit', 'done');

          if (_this.props.onExited) {
            _this.props.onExited(node);
          }
        };

        _this.getClassNames = function (type) {
          var classNames = _this.props.classNames;
          var isStringClassNames = typeof classNames === 'string';
          var prefix = isStringClassNames && classNames ? classNames + "-" : '';
          var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
          var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
          var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
          return {
            baseClassName: baseClassName,
            activeClassName: activeClassName,
            doneClassName: doneClassName
          };
        };

        return _this;
      }

      var _proto = CSSTransition.prototype;

      _proto.addClass = function addClass(node, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];

        if (type === 'appear' && phase === 'done') {
          className += " " + this.getClassNames('enter').doneClassName;
        } // This is for to force a repaint,
        // which is necessary in order to transition styles when adding a class name.


        if (phase === 'active') {
          /* eslint-disable no-unused-expressions */
          node && node.scrollTop;
        }

        this.appliedClasses[type][phase] = className;

        _addClass(node, className);
      };

      _proto.removeClasses = function removeClasses(node, type) {
        var _this$appliedClasses$ = this.appliedClasses[type],
            baseClassName = _this$appliedClasses$.base,
            activeClassName = _this$appliedClasses$.active,
            doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {};

        if (baseClassName) {
          removeClass$1(node, baseClassName);
        }

        if (activeClassName) {
          removeClass$1(node, activeClassName);
        }

        if (doneClassName) {
          removeClass$1(node, doneClassName);
        }
      };

      _proto.render = function render() {
        var _this$props = this.props,
            _ = _this$props.classNames,
            props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);

        return React__default.createElement(Transition, _extends({}, props, {
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        }));
      };

      return CSSTransition;
    }(React__default.Component);

    CSSTransition.defaultProps = {
      classNames: ''
    };
    CSSTransition.propTypes = _extends({}, Transition.propTypes, {
      /**
       * The animation classNames applied to the component as it enters, exits or
       * has finished the transition. A single name can be provided and it will be
       * suffixed for each stage: e.g.
       *
       * `classNames="fade"` applies `fade-enter`, `fade-enter-active`,
       * `fade-enter-done`, `fade-exit`, `fade-exit-active`, `fade-exit-done`,
       * `fade-appear`, `fade-appear-active`, and `fade-appear-done`.
       *
       * **Note**: `fade-appear-done` and `fade-enter-done` will _both_ be applied.
       * This allows you to define different behavior for when appearing is done and
       * when regular entering is done, using selectors like
       * `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply an
       * epic entrance animation when element first appears in the DOM using
       * [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
       * simply use `fade-enter-done` for defining both cases.
       *
       * Each individual classNames can also be specified independently like:
       *
       * ```js
       * classNames={{
       *  appear: 'my-appear',
       *  appearActive: 'my-active-appear',
       *  appearDone: 'my-done-appear',
       *  enter: 'my-enter',
       *  enterActive: 'my-active-enter',
       *  enterDone: 'my-done-enter',
       *  exit: 'my-exit',
       *  exitActive: 'my-active-exit',
       *  exitDone: 'my-done-exit',
       * }}
       * ```
       *
       * If you want to set these classes using CSS Modules:
       *
       * ```js
       * import styles from './styles.css';
       * ```
       *
       * you might want to use camelCase in your CSS file, that way could simply
       * spread them instead of listing them one by one:
       *
       * ```js
       * classNames={{ ...styles }}
       * ```
       *
       * @type {string | {
       *  appear?: string,
       *  appearActive?: string,
       *  appearDone?: string,
       *  enter?: string,
       *  enterActive?: string,
       *  enterDone?: string,
       *  exit?: string,
       *  exitActive?: string,
       *  exitDone?: string,
       * }}
       */
      classNames: classNamesShape,

      /**
       * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
       * applied.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEnter: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'enter-active' or
       * 'appear-active' class is applied.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntering: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'enter' or
       * 'appear' classes are **removed** and the `done` class is added to the DOM node.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntered: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit' class is
       * applied.
       *
       * @type Function(node: HtmlElement)
       */
      onExit: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
       *
       * @type Function(node: HtmlElement)
       */
      onExiting: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit' classes
       * are **removed** and the `exit-done` class is added to the DOM node.
       *
       * @type Function(node: HtmlElement)
       */
      onExited: PropTypes.func
    });

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /**
     * Given `this.props.children`, return an object mapping key to child.
     *
     * @param {*} children `this.props.children`
     * @return {object} Mapping of key to child
     */

    function getChildMapping(children, mapFn) {
      var mapper = function mapper(child) {
        return mapFn && React.isValidElement(child) ? mapFn(child) : child;
      };

      var result = Object.create(null);
      if (children) React.Children.map(children, function (c) {
        return c;
      }).forEach(function (child) {
        // run the map function here instead so that the key is the computed one
        result[child.key] = mapper(child);
      });
      return result;
    }
    /**
     * When you're adding or removing children some may be added or removed in the
     * same render pass. We want to show *both* since we want to simultaneously
     * animate elements in and out. This function takes a previous set of keys
     * and a new set of keys and merges them with its best guess of the correct
     * ordering. In the future we may expose some of the utilities in
     * ReactMultiChild to make this easy, but for now React itself does not
     * directly have this concept of the union of prevChildren and nextChildren
     * so we implement it here.
     *
     * @param {object} prev prev children as returned from
     * `ReactTransitionChildMapping.getChildMapping()`.
     * @param {object} next next children as returned from
     * `ReactTransitionChildMapping.getChildMapping()`.
     * @return {object} a key set that contains all keys in `prev` and all keys
     * in `next` in a reasonable order.
     */

    function mergeChildMappings(prev, next) {
      prev = prev || {};
      next = next || {};

      function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
      } // For each key of `next`, the list of keys to insert before that key in
      // the combined list


      var nextKeysPending = Object.create(null);
      var pendingKeys = [];

      for (var prevKey in prev) {
        if (prevKey in next) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }

      var i;
      var childMapping = {};

      for (var nextKey in next) {
        if (nextKeysPending[nextKey]) {
          for (i = 0; i < nextKeysPending[nextKey].length; i++) {
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
          }
        }

        childMapping[nextKey] = getValueForKey(nextKey);
      } // Finally, add the keys which didn't appear before any key in `next`


      for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
      }

      return childMapping;
    }

    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }

    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function (child) {
        return React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, 'appear', props),
          enter: getProp(child, 'enter', props),
          exit: getProp(child, 'exit', props)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function (key) {
        var child = children[key];
        if (!React.isValidElement(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = React.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

        if (hasNext && (!hasPrev || isLeaving)) {
          // console.log('entering', key)
          children[key] = React.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          // item is old (exiting)
          // console.log('leaving', key)
          children[key] = React.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && React.isValidElement(prevChild)) {
          // item hasn't changed transition states
          // copy over the last transition props;
          // console.log('unchanged', key)
          children[key] = React.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
          });
        }
      });
      return children;
    }

    var values = Object.values || function (obj) {
      return Object.keys(obj).map(function (k) {
        return obj[k];
      });
    };

    var defaultProps = {
      component: 'div',
      childFactory: function childFactory(child) {
        return child;
      }
      /**
       * The `<TransitionGroup>` component manages a set of transition components
       * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
       * components, `<TransitionGroup>` is a state machine for managing the mounting
       * and unmounting of components over time.
       *
       * Consider the example below. As items are removed or added to the TodoList the
       * `in` prop is toggled automatically by the `<TransitionGroup>`.
       *
       * Note that `<TransitionGroup>`  does not define any animation behavior!
       * Exactly _how_ a list item animates is up to the individual transition
       * component. This means you can mix and match animations across different list
       * items.
       */

    };

    var TransitionGroup =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(TransitionGroup, _React$Component);

      function TransitionGroup(props, context) {
        var _this;

        _this = _React$Component.call(this, props, context) || this;

        var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited: handleExited,
          firstRender: true
        };
        return _this;
      }

      var _proto = TransitionGroup.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };

      TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children,
            handleExited = _ref.handleExited,
            firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      };

      _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping) return;

        if (child.props.onExited) {
          child.props.onExited(node);
        }

        if (this.mounted) {
          this.setState(function (state) {
            var children = _extends({}, state.children);

            delete children[child.key];
            return {
              children: children
            };
          });
        }
      };

      _proto.render = function render() {
        var _this$props = this.props,
            Component = _this$props.component,
            childFactory = _this$props.childFactory,
            props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);

        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;

        if (Component === null) {
          return React__default.createElement(TransitionGroupContext.Provider, {
            value: contextValue
          }, children);
        }

        return React__default.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, React__default.createElement(Component, props, children));
      };

      return TransitionGroup;
    }(React__default.Component);

    TransitionGroup.propTypes = {
      /**
       * `<TransitionGroup>` renders a `<div>` by default. You can change this
       * behavior by providing a `component` prop.
       * If you use React v16+ and would like to avoid a wrapping `<div>` element
       * you can pass in `component={null}`. This is useful if the wrapping div
       * borks your css styles.
       */
      component: PropTypes__default.any,

      /**
       * A set of `<Transition>` components, that are toggled `in` and out as they
       * leave. the `<TransitionGroup>` will inject specific transition props, so
       * remember to spread them through if you are wrapping the `<Transition>` as
       * with our `<Fade>` example.
       *
       * While this component is meant for multiple `Transition` or `CSSTransition`
       * children, sometimes you may want to have a single transition child with
       * content that you want to be transitioned out and in when you change it
       * (e.g. routes, images etc.) In that case you can change the `key` prop of
       * the transition child as you change its content, this will cause
       * `TransitionGroup` to transition the child out and back in.
       */
      children: PropTypes__default.node,

      /**
       * A convenience prop that enables or disables appear animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      appear: PropTypes__default.bool,

      /**
       * A convenience prop that enables or disables enter animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      enter: PropTypes__default.bool,

      /**
       * A convenience prop that enables or disables exit animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      exit: PropTypes__default.bool,

      /**
       * You may need to apply reactive updates to a child as it is exiting.
       * This is generally done by using `cloneElement` however in the case of an exiting
       * child the element has already been removed and not accessible to the consumer.
       *
       * If you do need to update a child as it leaves you can provide a `childFactory`
       * to wrap every child, even the ones that are leaving.
       *
       * @type Function(child: ReactElement) -> ReactElement
       */
      childFactory: PropTypes__default.func
    };
    TransitionGroup.defaultProps = defaultProps;

    /**
     * The `<ReplaceTransition>` component is a specialized `Transition` component
     * that animates between two children.
     *
     * ```jsx
     * <ReplaceTransition in>
     *   <Fade><div>I appear first</div></Fade>
     *   <Fade><div>I replace the above</div></Fade>
     * </ReplaceTransition>
     * ```
     */

    var ReplaceTransition =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(ReplaceTransition, _React$Component);

      function ReplaceTransition() {
        var _this;

        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

        _this.handleEnter = function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _this.handleLifecycle('onEnter', 0, args);
        };

        _this.handleEntering = function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return _this.handleLifecycle('onEntering', 0, args);
        };

        _this.handleEntered = function () {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return _this.handleLifecycle('onEntered', 0, args);
        };

        _this.handleExit = function () {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          return _this.handleLifecycle('onExit', 1, args);
        };

        _this.handleExiting = function () {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }

          return _this.handleLifecycle('onExiting', 1, args);
        };

        _this.handleExited = function () {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }

          return _this.handleLifecycle('onExited', 1, args);
        };

        return _this;
      }

      var _proto = ReplaceTransition.prototype;

      _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
        var _child$props;

        var children = this.props.children;
        var child = React__default.Children.toArray(children)[idx];
        if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
        if (this.props[handler]) this.props[handler](ReactDOM.findDOMNode(this));
      };

      _proto.render = function render() {
        var _this$props = this.props,
            children = _this$props.children,
            inProp = _this$props.in,
            props = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in"]);

        var _React$Children$toArr = React__default.Children.toArray(children),
            first = _React$Children$toArr[0],
            second = _React$Children$toArr[1];

        delete props.onEnter;
        delete props.onEntering;
        delete props.onEntered;
        delete props.onExit;
        delete props.onExiting;
        delete props.onExited;
        return React__default.createElement(TransitionGroup, props, inProp ? React__default.cloneElement(first, {
          key: 'first',
          onEnter: this.handleEnter,
          onEntering: this.handleEntering,
          onEntered: this.handleEntered
        }) : React__default.cloneElement(second, {
          key: 'second',
          onEnter: this.handleExit,
          onEntering: this.handleExiting,
          onEntered: this.handleExited
        }));
      };

      return ReplaceTransition;
    }(React__default.Component);

    ReplaceTransition.propTypes = {
      in: PropTypes__default.bool.isRequired,
      children: function children(props, propName) {
        if (React__default.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
        return null;
      }
    };

    var animationDuration = 350;
    var useStyles$3 = makeStyles(function (theme) {
      var slideTransition = theme.transitions.create('transform', {
        duration: animationDuration,
        easing: 'cubic-bezier(0.35, 0.8, 0.4, 1)'
      });
      return {
        transitionContainer: {
          display: 'block',
          position: 'relative',
          '& > *': {
            position: 'absolute',
            top: 0,
            right: 0,
            left: 0
          }
        },
        'slideEnter-left': {
          willChange: 'transform',
          transform: 'translate(100%)'
        },
        'slideEnter-right': {
          willChange: 'transform',
          transform: 'translate(-100%)'
        },
        slideEnterActive: {
          transform: 'translate(0%)',
          transition: slideTransition
        },
        slideExit: {
          transform: 'translate(0%)'
        },
        'slideExitActiveLeft-left': {
          willChange: 'transform',
          transform: 'translate(-200%)',
          transition: slideTransition
        },
        'slideExitActiveLeft-right': {
          willChange: 'transform',
          transform: 'translate(200%)',
          transition: slideTransition
        }
      };
    }, {
      name: 'MuiPickersSlideTransition'
    });

    var SlideTransition = function (_a) {
      var children = _a.children,
          transKey = _a.transKey,
          slideDirection = _a.slideDirection,
          _b = _a.className,
          className = _b === void 0 ? null : _b;
      var classes = useStyles$3();
      var transitionClasses = {
        exit: classes.slideExit,
        enterActive: classes.slideEnterActive,
        // @ts-ignore
        enter: classes['slideEnter-' + slideDirection],
        // @ts-ignore
        exitActive: classes['slideExitActiveLeft-' + slideDirection]
      };
      return React.createElement(TransitionGroup, {
        className: clsx(classes.transitionContainer, className),
        childFactory: function (element) {
          return React.cloneElement(element, {
            classNames: transitionClasses
          });
        }
      }, React.createElement(CSSTransition, {
        mountOnEnter: true,
        unmountOnExit: true,
        key: transKey + slideDirection,
        timeout: animationDuration,
        classNames: transitionClasses,
        children: children
      }));
    };

    var ArrowLeftIcon = function (props) {
      return React__default.createElement(SvgIcon$2, __assign({}, props), React__default.createElement("path", {
        d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
      }), React__default.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0V0z"
      }));
    };

    var ArrowRightIcon = function (props) {
      return React__default.createElement(SvgIcon$2, __assign({}, props), React__default.createElement("path", {
        d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
      }), React__default.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0V0z"
      }));
    };

    var useStyles$4 = makeStyles(function (theme) {
      return {
        switchHeader: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginTop: theme.spacing(0.5),
          marginBottom: theme.spacing(1)
        },
        transitionContainer: {
          width: '100%',
          height: 20
        },
        iconButton: {
          zIndex: 2,
          backgroundColor: theme.palette.background.paper,
          '& > *': {
            // label
            backgroundColor: theme.palette.background.paper,
            '& > *': {
              // icon
              zIndex: 1,
              overflow: 'visible'
            }
          }
        },
        daysHeader: {
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          maxHeight: 16
        },
        dayLabel: {
          width: 36,
          margin: '0 2px',
          textAlign: 'center',
          color: theme.palette.text.hint
        }
      };
    }, {
      name: 'MuiPickersCalendarHeader'
    });
    var CalendarHeader = function (_a) {
      var currentMonth = _a.currentMonth,
          onMonthChange = _a.onMonthChange,
          leftArrowIcon = _a.leftArrowIcon,
          rightArrowIcon = _a.rightArrowIcon,
          leftArrowButtonProps = _a.leftArrowButtonProps,
          rightArrowButtonProps = _a.rightArrowButtonProps,
          disablePrevMonth = _a.disablePrevMonth,
          disableNextMonth = _a.disableNextMonth,
          slideDirection = _a.slideDirection;
      var utils = useUtils();
      var classes = useStyles$4();
      var theme = useTheme();
      var rtl = theme.direction === 'rtl';

      var selectNextMonth = function () {
        return onMonthChange(utils.getNextMonth(currentMonth), 'left');
      };

      var selectPreviousMonth = function () {
        return onMonthChange(utils.getPreviousMonth(currentMonth), 'right');
      };

      return React.createElement("div", null, React.createElement("div", {
        className: classes.switchHeader
      }, React.createElement(IconButton$2, __assign({}, leftArrowButtonProps, {
        disabled: disablePrevMonth,
        onClick: selectPreviousMonth,
        className: classes.iconButton
      }), rtl ? rightArrowIcon : leftArrowIcon), React.createElement(SlideTransition, {
        slideDirection: slideDirection,
        transKey: currentMonth.toString(),
        className: classes.transitionContainer
      }, React.createElement(Typography$2, {
        align: "center",
        variant: "body1"
      }, utils.getCalendarHeaderText(currentMonth))), React.createElement(IconButton$2, __assign({}, rightArrowButtonProps, {
        disabled: disableNextMonth,
        onClick: selectNextMonth,
        className: classes.iconButton
      }), rtl ? leftArrowIcon : rightArrowIcon)), React.createElement("div", {
        className: classes.daysHeader
      }, utils.getWeekdays().map(function (day, index) {
        return React.createElement(Typography$2, {
          key: index,
          variant: "caption",
          className: classes.dayLabel
        }, day);
      })));
    };
    CalendarHeader.displayName = 'CalendarHeader';
    CalendarHeader.propTypes = {
      leftArrowIcon: PropTypes.node,
      rightArrowIcon: PropTypes.node,
      disablePrevMonth: PropTypes.bool,
      disableNextMonth: PropTypes.bool
    };
    CalendarHeader.defaultProps = {
      leftArrowIcon: React.createElement(ArrowLeftIcon, null),
      rightArrowIcon: React.createElement(ArrowRightIcon, null),
      disablePrevMonth: false,
      disableNextMonth: false
    };

    function chainPropTypes(propType1, propType2) {

      return function validate() {
        return propType1.apply(void 0, arguments) || propType2.apply(void 0, arguments);
      };
    }

    function isClassComponent(elementType) {
      // elementType.prototype?.isReactComponent
      var _elementType$prototyp = elementType.prototype,
          prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
      return Boolean(prototype.isReactComponent);
    }

    function acceptingRef(props, propName, componentName, location, propFullName) {
      var element = props[propName];
      var safePropName = propFullName || propName;

      if (element == null) {
        return null;
      }

      var warningHint;
      var elementType = element.type;
      /**
       * Blacklisting instead of whitelisting
       *
       * Blacklisting will miss some components, such as React.Fragment. Those will at least
       * trigger a warning in React.
       * We can't whitelist because there is no safe way to detect React.forwardRef
       * or class components. "Safe" means there's no public API.
       *
       */

      if (typeof elementType === 'function' && !isClassComponent(elementType)) {
        warningHint = 'Did you accidentally use a plain function component for an element instead?';
      }

      if (warningHint !== undefined) {
        return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/guides/composition/#caveat-with-refs');
      }

      return null;
    }

    var elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);
    elementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);

    function isClassComponent$1(elementType) {
      // elementType.prototype?.isReactComponent
      var _elementType$prototyp = elementType.prototype,
          prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
      return Boolean(prototype.isReactComponent);
    }

    function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var safePropName = propFullName || propName;

      if (propValue == null) {
        return null;
      }

      var warningHint;
      /**
       * Blacklisting instead of whitelisting
       *
       * Blacklisting will miss some components, such as React.Fragment. Those will at least
       * trigger a warning in React.
       * We can't whitelist because there is no safe way to detect React.forwardRef
       * or class components. "Safe" means there's no public API.
       *
       */

      if (typeof propValue === 'function' && !isClassComponent$1(propValue)) {
        warningHint = 'Did you accidentally provide a plain function component instead?';
      }

      if (warningHint !== undefined) {
        return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element type that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/guides/composition/#caveat-with-refs');
      }

      return null;
    }

    var elementTypeAcceptingRef$1 = chainPropTypes(PropTypes.elementType, elementTypeAcceptingRef);

    // This module is based on https://github.com/airbnb/prop-types-exact repository.
    // However, in order to reduce the number of dependencies and to remove some extra safe checks
    // the module was forked.
    // Only exported for test purposes.
    var specialProperty = "exact-prop: \u200B";

    function exactProp(propTypes) {

      return _extends_1({}, propTypes, defineProperty({}, specialProperty, function (props) {
        var unsupportedProps = Object.keys(props).filter(function (prop) {
          return !propTypes.hasOwnProperty(prop);
        });

        if (unsupportedProps.length > 0) {
          return new Error("The following properties are not supported: ".concat(unsupportedProps.map(function (prop) {
            return "`".concat(prop, "`");
          }).join(', '), ". Please remove them."));
        }

        return null;
      }));
    }

    var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
    });

    var reactIs_production_min = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports,"__esModule",{value:!0});
    var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.memo"):
    60115,r=b?Symbol.for("react.lazy"):60116;function t(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case r:case q:case d:return u}}}function v(a){return t(a)===m}exports.typeOf=t;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;
    exports.Fragment=e;exports.Lazy=r;exports.Memo=q;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===r||a.$$typeof===q||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||t(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return t(a)===k};
    exports.isContextProvider=function(a){return t(a)===h};exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return t(a)===n};exports.isFragment=function(a){return t(a)===e};exports.isLazy=function(a){return t(a)===r};exports.isMemo=function(a){return t(a)===q};exports.isPortal=function(a){return t(a)===d};exports.isProfiler=function(a){return t(a)===g};exports.isStrictMode=function(a){return t(a)===f};
    exports.isSuspense=function(a){return t(a)===p};
    });

    unwrapExports(reactIs_production_min);
    var reactIs_production_min_1 = reactIs_production_min.typeOf;
    var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
    var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
    var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
    var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
    var reactIs_production_min_6 = reactIs_production_min.Element;
    var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
    var reactIs_production_min_8 = reactIs_production_min.Fragment;
    var reactIs_production_min_9 = reactIs_production_min.Lazy;
    var reactIs_production_min_10 = reactIs_production_min.Memo;
    var reactIs_production_min_11 = reactIs_production_min.Portal;
    var reactIs_production_min_12 = reactIs_production_min.Profiler;
    var reactIs_production_min_13 = reactIs_production_min.StrictMode;
    var reactIs_production_min_14 = reactIs_production_min.Suspense;
    var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
    var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
    var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
    var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
    var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
    var reactIs_production_min_20 = reactIs_production_min.isElement;
    var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
    var reactIs_production_min_22 = reactIs_production_min.isFragment;
    var reactIs_production_min_23 = reactIs_production_min.isLazy;
    var reactIs_production_min_24 = reactIs_production_min.isMemo;
    var reactIs_production_min_25 = reactIs_production_min.isPortal;
    var reactIs_production_min_26 = reactIs_production_min.isProfiler;
    var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
    var reactIs_production_min_28 = reactIs_production_min.isSuspense;

    var reactIs_development = createCommonjsModule(function (module, exports) {



    {
      (function() {

    Object.defineProperty(exports, '__esModule', { value: true });

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol.for;

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' ||
      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
    }

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function () {};

    {
      var printWarning = function (format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function (condition, format) {
        if (format === undefined) {
          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;
              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_LAZY_TYPE:
          case REACT_MEMO_TYPE:
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    }

    // AsyncMode is deprecated along with isAsyncMode
    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;

    var hasWarnedAboutDeprecatedIsAsyncMode = false;

    // AsyncMode should be deprecated
    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true;
          lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    exports.typeOf = typeOf;
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isValidElementType = isValidElementType;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
      })();
    }
    });

    unwrapExports(reactIs_development);
    var reactIs_development_1 = reactIs_development.typeOf;
    var reactIs_development_2 = reactIs_development.AsyncMode;
    var reactIs_development_3 = reactIs_development.ConcurrentMode;
    var reactIs_development_4 = reactIs_development.ContextConsumer;
    var reactIs_development_5 = reactIs_development.ContextProvider;
    var reactIs_development_6 = reactIs_development.Element;
    var reactIs_development_7 = reactIs_development.ForwardRef;
    var reactIs_development_8 = reactIs_development.Fragment;
    var reactIs_development_9 = reactIs_development.Lazy;
    var reactIs_development_10 = reactIs_development.Memo;
    var reactIs_development_11 = reactIs_development.Portal;
    var reactIs_development_12 = reactIs_development.Profiler;
    var reactIs_development_13 = reactIs_development.StrictMode;
    var reactIs_development_14 = reactIs_development.Suspense;
    var reactIs_development_15 = reactIs_development.isValidElementType;
    var reactIs_development_16 = reactIs_development.isAsyncMode;
    var reactIs_development_17 = reactIs_development.isConcurrentMode;
    var reactIs_development_18 = reactIs_development.isContextConsumer;
    var reactIs_development_19 = reactIs_development.isContextProvider;
    var reactIs_development_20 = reactIs_development.isElement;
    var reactIs_development_21 = reactIs_development.isForwardRef;
    var reactIs_development_22 = reactIs_development.isFragment;
    var reactIs_development_23 = reactIs_development.isLazy;
    var reactIs_development_24 = reactIs_development.isMemo;
    var reactIs_development_25 = reactIs_development.isPortal;
    var reactIs_development_26 = reactIs_development.isProfiler;
    var reactIs_development_27 = reactIs_development.isStrictMode;
    var reactIs_development_28 = reactIs_development.isSuspense;

    var reactIs = createCommonjsModule(function (module) {

    {
      module.exports = reactIs_development;
    }
    });
    var reactIs_1 = reactIs.ForwardRef;

    // https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3

    var fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
    function getFunctionName(fn) {
      var match = "".concat(fn).match(fnNameMatchRegex);
      var name = match && match[1];
      return name || '';
    }
    /**
     * @param {function} Component
     * @param {string} fallback
     * @returns {string | undefined}
     */

    function getFunctionComponentName(Component) {
      var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return Component.displayName || Component.name || getFunctionName(Component) || fallback;
    }

    function getWrappedName(outerType, innerType, wrapperName) {
      var functionName = getFunctionComponentName(innerType);
      return outerType.displayName || (functionName !== '' ? "".concat(wrapperName, "(").concat(functionName, ")") : wrapperName);
    }
    /**
     * cherry-pick from
     * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
     * originally forked from recompose/getDisplayName with added IE 11 support
     *
     * @param {React.ReactType} Component
     * @returns {string | undefined}
     */


    function getDisplayName(Component) {
      if (Component == null) {
        return undefined;
      }

      if (typeof Component === 'string') {
        return Component;
      }

      if (typeof Component === 'function') {
        return getFunctionComponentName(Component, 'Component');
      }

      if (_typeof_1(Component) === 'object') {
        switch (Component.$$typeof) {
          case reactIs_1:
            return getWrappedName(Component, Component.render, 'ForwardRef');

          default:
            return undefined;
        }
      }

      return undefined;
    }

    /* eslint-disable */
    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

    /** @license Material-UI v4.0.1
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    //
    // A strict capitalization should uppercase the first letter of each word a the sentence.
    // We only handle the first word.

    function capitalize(string) {
      if (typeof string !== 'string') {
        throw new Error('Material-UI: capitalize(string) expects a string argument.');
      }

      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    /**
     * Safe chained function
     *
     * Will only create a new function if needed,
     * otherwise will pass back existing functions or null.
     *
     * @param {function} functions to chain
     * @returns {function|null}
     */

    function createChainedFunction() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }

      return funcs.reduce(function (acc, func) {
        if (func == null) {
          return acc;
        }

        warning_1(typeof func === 'function', 'Material-UI: invalid Argument Type, must only provide functions, undefined, or null.');
        return function chainedFunction() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          acc.apply(this, args);
          func.apply(this, args);
        };
      }, function () {});
    }

    var SIZE = 44;

    function getRelativeValue(value, min, max) {
      var clampedValue = Math.min(Math.max(min, value), max);
      return (clampedValue - min) / (max - min);
    }

    function easeOut(t) {
      t = getRelativeValue(t, 0, 1); // https://gist.github.com/gre/1650294

      t = (t -= 1) * t * t + 1;
      return t;
    }

    function easeIn(t) {
      return t * t;
    }

    var styles$2 = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'inline-block',
          lineHeight: 1 // Keep the progress centered

        },

        /* Styles applied to the root element if `variant="static"`. */
        static: {
          transition: theme.transitions.create('transform')
        },

        /* Styles applied to the root element if `variant="indeterminate"`. */
        indeterminate: {
          animation: 'mui-progress-circular-rotate 1.4s linear infinite',
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-progress-circular-rotate'
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          color: theme.palette.secondary.main
        },

        /* Styles applied to the `svg` element. */
        svg: {},

        /* Styles applied to the `circle` svg path. */
        circle: {
          stroke: 'currentColor' // Use butt to follow the specification, by chance, it's already the default CSS value.
          // strokeLinecap: 'butt',

        },

        /* Styles applied to the `circle` svg path if `variant="static"`. */
        circleStatic: {
          transition: theme.transitions.create('stroke-dashoffset')
        },

        /* Styles applied to the `circle` svg path if `variant="indeterminate"`. */
        circleIndeterminate: {
          animation: 'mui-progress-circular-dash 1.4s ease-in-out infinite',
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-progress-circular-dash',
          // Some default value that looks fine waiting for the animation to kicks in.
          strokeDasharray: '80px, 200px',
          strokeDashoffset: '0px' // Add the unit to fix a Edge 16 and below bug.

        },
        '@keyframes mui-progress-circular-rotate': {
          '100%': {
            transform: 'rotate(360deg)'
          }
        },
        '@keyframes mui-progress-circular-dash': {
          '0%': {
            strokeDasharray: '1px, 200px',
            strokeDashoffset: '0px'
          },
          '50%': {
            strokeDasharray: '100px, 200px',
            strokeDashoffset: '-15px'
          },
          '100%': {
            strokeDasharray: '100px, 200px',
            strokeDashoffset: '-125px'
          }
        },

        /* Styles applied to the `circle` svg path if `disableShrink={true}`. */
        circleDisableShrink: {
          animation: 'none'
        }
      };
    };
    /**
     * ## ARIA
     *
     * If the progress bar is describing the loading progress of a particular region of a page,
     * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`
     * attribute to `true` on that region until it has finished loading.
     */

    var CircularProgress = React__default.forwardRef(function CircularProgress(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'primary' : _props$color,
          _props$disableShrink = props.disableShrink,
          disableShrink = _props$disableShrink === void 0 ? false : _props$disableShrink,
          _props$size = props.size,
          size = _props$size === void 0 ? 40 : _props$size,
          style = props.style,
          _props$thickness = props.thickness,
          thickness = _props$thickness === void 0 ? 3.6 : _props$thickness,
          _props$value = props.value,
          value = _props$value === void 0 ? 0 : _props$value,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'indeterminate' : _props$variant,
          other = objectWithoutProperties(props, ["classes", "className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"]);

      var circleStyle = {};
      var rootStyle = {};
      var rootProps = {};

      if (variant === 'determinate' || variant === 'static') {
        var circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
        circleStyle.strokeDasharray = circumference.toFixed(3);
        rootProps['aria-valuenow'] = Math.round(value);

        if (variant === 'static') {
          circleStyle.strokeDashoffset = "".concat(((100 - value) / 100 * circumference).toFixed(3), "px");
          rootStyle.transform = 'rotate(-90deg)';
        } else {
          circleStyle.strokeDashoffset = "".concat((easeIn((100 - value) / 100) * circumference).toFixed(3), "px");
          rootStyle.transform = "rotate(".concat((easeOut(value / 70) * 270).toFixed(3), "deg)");
        }
      }

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, color !== 'inherit' && classes["color".concat(capitalize(color))], variant === 'indeterminate' && classes.indeterminate, variant === 'static' && classes.static, className),
        style: _extends_1({
          width: size,
          height: size
        }, rootStyle, style),
        ref: ref,
        role: "progressbar"
      }, rootProps, other), React__default.createElement("svg", {
        className: classes.svg,
        viewBox: "".concat(SIZE / 2, " ").concat(SIZE / 2, " ").concat(SIZE, " ").concat(SIZE)
      }, React__default.createElement("circle", {
        className: clsx(classes.circle, variant === 'indeterminate' && classes.circleIndeterminate, variant === 'static' && classes.circleStatic, disableShrink && classes.circleDisableShrink),
        style: circleStyle,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })));
    });
    CircularProgress.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary', 'inherit']),

      /**
       * If `true`, the shrink animation is disabled.
       * This only works if variant is `indeterminate`.
       */
      disableShrink: chainPropTypes(PropTypes__default.bool, function (props) {
        if (props.disableShrink && props.variant !== 'indeterminate') {
          return new Error('Material-UI: you have provided the `disableShrink` property ' + 'with a variant other than `indeterminate`. This will have no effect.');
        }

        return null;
      }),

      /**
       * The size of the circle.
       */
      size: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * The thickness of the circle.
       */
      thickness: PropTypes__default.number,

      /**
       * The value of the progress indicator for the determinate and static variants.
       * Value between 0 and 100.
       */
      value: PropTypes__default.number,

      /**
       * The variant to use.
       * Use indeterminate when there is no progress value.
       */
      variant: PropTypes__default.oneOf(['determinate', 'indeterminate', 'static'])
    };
    var CircularProgress$1 = withStyles(styles$2, {
      name: 'MuiCircularProgress',
      flip: false
    })(CircularProgress);

    var useIsomorphicEffect = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;
    function runKeyHandler(e, keyHandlers) {
      var handler = keyHandlers[e.key];

      if (handler) {
        handler(); // if event was handled prevent other side effects (e.g. page scroll)

        e.preventDefault();
      }
    }
    function useKeyDown(active, keyHandlers) {
      var keyHandlersRef = React.useRef(keyHandlers);
      useIsomorphicEffect(function () {
        keyHandlersRef.current = keyHandlers;
      });
      React.useEffect(function () {
        if (active) {
          var handleKeyDown_1 = function (event) {
            runKeyHandler(event, keyHandlers);
          };

          window.addEventListener('keydown', handleKeyDown_1);
          return function () {
            window.removeEventListener('keydown', handleKeyDown_1);
          };
        }
      }, [active]);
    }

    var withUtils = function () {
      return function (Component) {
        var WithUtils = function (props) {
          var utils = useUtils();
          return React.createElement(Component, __assign({
            utils: utils
          }, props));
        };

        WithUtils.displayName = "WithUtils(" + (Component.displayName || Component.name) + ")";
        return WithUtils;
      };
    };

    var KeyDownListener = function (_a) {
      var onKeyDown = _a.onKeyDown;
      React.useEffect(function () {
        window.addEventListener('keydown', onKeyDown);
        return function () {
          window.removeEventListener('keydown', onKeyDown);
        };
      }, [onKeyDown]);
      return null;
    };

    var Calendar =
    /** @class */
    function (_super) {
      __extends(Calendar, _super);

      function Calendar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.state = {
          slideDirection: 'left',
          currentMonth: _this.props.utils.startOfMonth(_this.props.date),
          loadingQueue: 0
        };

        _this.onDateSelect = function (day, isFinish) {
          if (isFinish === void 0) {
            isFinish = true;
          }

          var _a = _this.props,
              date = _a.date,
              utils = _a.utils;

          _this.props.onChange(utils.mergeDateAndTime(day, date), isFinish);
        };

        _this.handleChangeMonth = function (newMonth, slideDirection) {
          _this.setState({
            currentMonth: newMonth,
            slideDirection: slideDirection
          });

          if (_this.props.onMonthChange) {
            var returnVal = _this.props.onMonthChange(newMonth);

            if (returnVal) {
              _this.pushToLoadingQueue();

              returnVal.then(function () {
                _this.popFromLoadingQueue();
              });
            }
          }
        };

        _this.validateMinMaxDate = function (day) {
          var _a = _this.props,
              minDate = _a.minDate,
              maxDate = _a.maxDate,
              utils = _a.utils,
              disableFuture = _a.disableFuture,
              disablePast = _a.disablePast;
          var now = utils.date();
          return Boolean(disableFuture && utils.isAfterDay(day, now) || disablePast && utils.isBeforeDay(day, now) || minDate && utils.isBeforeDay(day, utils.date(minDate)) || maxDate && utils.isAfterDay(day, utils.date(maxDate)));
        };

        _this.shouldDisablePrevMonth = function () {
          var _a = _this.props,
              utils = _a.utils,
              disablePast = _a.disablePast,
              minDate = _a.minDate;
          var now = utils.date();
          var firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, utils.date(minDate)) ? now : utils.date(minDate));
          return !utils.isBefore(firstEnabledMonth, _this.state.currentMonth);
        };

        _this.shouldDisableNextMonth = function () {
          var _a = _this.props,
              utils = _a.utils,
              disableFuture = _a.disableFuture,
              maxDate = _a.maxDate;
          var now = utils.date();
          var lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, utils.date(maxDate)) ? now : utils.date(maxDate));
          return !utils.isAfter(lastEnabledMonth, _this.state.currentMonth);
        };

        _this.shouldDisableDate = function (day) {
          var shouldDisableDate = _this.props.shouldDisableDate;
          return _this.validateMinMaxDate(day) || Boolean(shouldDisableDate && shouldDisableDate(day));
        };

        _this.moveToDay = function (day) {
          if (day && !_this.shouldDisableDate(day)) {
            _this.onDateSelect(day, false);
          }
        };

        _this.handleKeyDown = function (event) {
          var _a = _this.props,
              theme = _a.theme,
              date = _a.date,
              utils = _a.utils;
          runKeyHandler(event, {
            ArrowUp: function () {
              return _this.moveToDay(utils.addDays(date, -7));
            },
            ArrowDown: function () {
              return _this.moveToDay(utils.addDays(date, 7));
            },
            ArrowLeft: function () {
              return _this.moveToDay(utils.addDays(date, theme.direction === 'ltr' ? -1 : 1));
            },
            ArrowRight: function () {
              return _this.moveToDay(utils.addDays(date, theme.direction === 'ltr' ? 1 : -1));
            }
          });
        };

        _this.renderWeeks = function () {
          var _a = _this.props,
              utils = _a.utils,
              classes = _a.classes;
          var weeks = utils.getWeekArray(_this.state.currentMonth);
          return weeks.map(function (week) {
            return React.createElement("div", {
              key: "week-" + week[0].toString(),
              className: classes.week
            }, _this.renderDays(week));
          });
        };

        _this.renderDays = function (week) {
          var _a = _this.props,
              date = _a.date,
              renderDay = _a.renderDay,
              utils = _a.utils;
          var now = utils.date();
          var selectedDate = utils.startOfDay(date);
          var currentMonthNumber = utils.getMonth(_this.state.currentMonth);
          return week.map(function (day) {
            var disabled = _this.shouldDisableDate(day);

            var isDayInCurrentMonth = utils.getMonth(day) === currentMonthNumber;
            var dayComponent = React.createElement(Day, {
              disabled: disabled,
              current: utils.isSameDay(day, now),
              hidden: !isDayInCurrentMonth,
              selected: utils.isSameDay(selectedDate, day)
            }, utils.getDayText(day));

            if (renderDay) {
              dayComponent = renderDay(day, selectedDate, isDayInCurrentMonth, dayComponent);
            }

            return React.createElement(DayWrapper, {
              value: day,
              key: day.toString(),
              disabled: disabled,
              dayInCurrentMonth: isDayInCurrentMonth,
              onSelect: _this.onDateSelect
            }, dayComponent);
          });
        };

        _this.pushToLoadingQueue = function () {
          var loadingQueue = _this.state.loadingQueue + 1;

          _this.setState({
            loadingQueue: loadingQueue
          });
        };

        _this.popFromLoadingQueue = function () {
          var loadingQueue = _this.state.loadingQueue;
          loadingQueue = loadingQueue <= 0 ? 0 : loadingQueue - 1;

          _this.setState({
            loadingQueue: loadingQueue
          });
        };

        return _this;
      }

      Calendar.getDerivedStateFromProps = function (nextProps, state) {
        var utils = nextProps.utils,
            nextDate = nextProps.date;

        if (!utils.isEqual(nextDate, state.lastDate)) {
          var nextMonth = utils.getMonth(nextDate);
          var lastDate = state.lastDate || nextDate;
          var lastMonth = utils.getMonth(lastDate);
          return {
            lastDate: nextDate,
            currentMonth: nextProps.utils.startOfMonth(nextDate),
            // prettier-ignore
            slideDirection: nextMonth === lastMonth ? state.slideDirection : utils.isAfterDay(nextDate, lastDate) ? 'left' : 'right'
          };
        }

        return null;
      };

      Calendar.prototype.componentDidMount = function () {
        var _a = this.props,
            date = _a.date,
            minDate = _a.minDate,
            maxDate = _a.maxDate,
            utils = _a.utils,
            disablePast = _a.disablePast,
            disableFuture = _a.disableFuture;

        if (this.shouldDisableDate(date)) {
          var closestEnabledDate = findClosestEnabledDate({
            date: date,
            utils: utils,
            minDate: utils.date(minDate),
            maxDate: utils.date(maxDate),
            disablePast: Boolean(disablePast),
            disableFuture: Boolean(disableFuture),
            shouldDisableDate: this.shouldDisableDate
          });
          this.onDateSelect(closestEnabledDate, false);
        }
      };

      Calendar.prototype.render = function () {
        var _a = this.state,
            currentMonth = _a.currentMonth,
            slideDirection = _a.slideDirection;
        var _b = this.props,
            classes = _b.classes,
            allowKeyboardControl = _b.allowKeyboardControl,
            leftArrowButtonProps = _b.leftArrowButtonProps,
            leftArrowIcon = _b.leftArrowIcon,
            rightArrowButtonProps = _b.rightArrowButtonProps,
            rightArrowIcon = _b.rightArrowIcon,
            loadingIndicator = _b.loadingIndicator;
        var loadingElement = loadingIndicator ? loadingIndicator : React.createElement(CircularProgress$1, null);
        return React.createElement(React.Fragment, null, allowKeyboardControl && React.createElement(KeyDownListener, {
          onKeyDown: this.handleKeyDown
        }), React.createElement(CalendarHeader, {
          currentMonth: currentMonth,
          slideDirection: slideDirection,
          onMonthChange: this.handleChangeMonth,
          leftArrowIcon: leftArrowIcon,
          leftArrowButtonProps: leftArrowButtonProps,
          rightArrowIcon: rightArrowIcon,
          rightArrowButtonProps: rightArrowButtonProps,
          disablePrevMonth: this.shouldDisablePrevMonth(),
          disableNextMonth: this.shouldDisableNextMonth()
        }), React.createElement(SlideTransition, {
          slideDirection: slideDirection,
          transKey: currentMonth.toString(),
          className: classes.transitionContainer
        }, React.createElement(React.Fragment, null, this.state.loadingQueue > 0 && React.createElement("div", {
          className: classes.progressContainer
        }, loadingElement) || React.createElement("div", null, this.renderWeeks()))));
      };

      Calendar.propTypes = {
        renderDay: PropTypes.func,
        shouldDisableDate: PropTypes.func,
        allowKeyboardControl: PropTypes.bool
      };
      Calendar.defaultProps = {
        minDate: new Date('1900-01-01'),
        maxDate: new Date('2100-01-01'),
        disablePast: false,
        disableFuture: false,
        allowKeyboardControl: true
      };
      return Calendar;
    }(React.Component);
    var styles$3 = function (theme) {
      return {
        transitionContainer: {
          minHeight: 36 * 6,
          marginTop: theme.spacing(1.5)
        },
        progressContainer: {
          width: '100%',
          height: '100%',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center'
        },
        week: {
          display: 'flex',
          justifyContent: 'center'
        }
      };
    };
    var Calendar$1 = withStyles(styles$3, {
      name: 'MuiPickersCalendar',
      withTheme: true
    })(withUtils()(Calendar));

    var useStyles$5 = makeStyles(function (theme) {
      return {
        root: {
          height: theme.spacing(5),
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          outline: 'none',
          '&:focus': {
            color: theme.palette.primary.main,
            fontWeight: theme.typography.fontWeightMedium
          }
        },
        yearSelected: {
          margin: '10px 0',
          fontWeight: theme.typography.fontWeightMedium
        },
        yearDisabled: {
          pointerEvents: 'none',
          color: theme.palette.text.hint
        }
      };
    }, {
      name: 'MuiPickersYear'
    });
    var Year = function (_a) {
      var _b;

      var onSelect = _a.onSelect,
          forwardedRef = _a.forwardedRef,
          value = _a.value,
          selected = _a.selected,
          disabled = _a.disabled,
          children = _a.children,
          other = __rest(_a, ["onSelect", "forwardedRef", "value", "selected", "disabled", "children"]);

      var classes = useStyles$5();
      var handleClick = React.useCallback(function () {
        return onSelect(value);
      }, [onSelect, value]);
      return React.createElement(Typography$2, __assign({
        role: "button",
        component: "div",
        tabIndex: disabled ? -1 : 0,
        onClick: handleClick,
        onKeyPress: handleClick,
        color: selected ? 'primary' : undefined,
        variant: selected ? 'h5' : 'subtitle1',
        children: children,
        ref: forwardedRef,
        className: clsx(classes.root, (_b = {}, _b[classes.yearSelected] = selected, _b[classes.yearDisabled] = disabled, _b))
      }, other));
    };
    Year.displayName = 'Year';
    var Year$1 = React.forwardRef(function (props, ref) {
      return React.createElement(Year, __assign({}, props, {
        forwardedRef: ref
      }));
    });

    var useStyles$6 = makeStyles({
      container: {
        height: 300,
        overflowY: 'auto'
      }
    }, {
      name: 'MuiPickersYearSelection'
    });

    var YearSelection = function (_a) {
      var date = _a.date,
          onChange = _a.onChange,
          onYearChange = _a.onYearChange,
          minDate = _a.minDate,
          maxDate = _a.maxDate,
          disablePast = _a.disablePast,
          disableFuture = _a.disableFuture,
          animateYearScrolling = _a.animateYearScrolling;
      var utils = useUtils();
      var classes = useStyles$6();
      var selectedYearRef = React.useRef(null);
      React.useEffect(function () {
        if (selectedYearRef.current && selectedYearRef.current.scrollIntoView) {
          selectedYearRef.current.scrollIntoView({
            behavior: animateYearScrolling ? 'smooth' : 'auto'
          });
        }
      }, []); // eslint-disable-line

      var currentYear = utils.getYear(date);
      var onYearSelect = React.useCallback(function (year) {
        var newDate = utils.setYear(date, year);

        if (onYearChange) {
          onYearChange(newDate);
        }

        onChange(newDate, true);
      }, [date, onChange, onYearChange, utils]);
      return React.createElement("div", {
        className: classes.container
      }, utils.getYearRange(minDate, maxDate).map(function (year) {
        var yearNumber = utils.getYear(year);
        var selected = yearNumber === currentYear;
        return React.createElement(Year$1, {
          key: utils.getYearText(year),
          selected: selected,
          value: yearNumber,
          onSelect: onYearSelect,
          ref: selected ? selectedYearRef : undefined,
          disabled: Boolean(disablePast && utils.isBeforeYear(year, utils.date()) || disableFuture && utils.isAfterYear(year, utils.date()))
        }, utils.getYearText(year));
      }));
    };

    var useStyles$7 = makeStyles(function (theme) {
      return {
        root: {
          flex: '1 0 33.33%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          outline: 'none',
          height: 75,
          transition: theme.transitions.create('font-size', {
            duration: '100ms'
          }),
          '&:focus': {
            color: theme.palette.primary.main,
            fontWeight: theme.typography.fontWeightMedium
          }
        },
        monthSelected: {
          color: theme.palette.primary.main,
          fontWeight: theme.typography.fontWeightMedium
        },
        monthDisabled: {
          pointerEvents: 'none',
          color: theme.palette.text.hint
        }
      };
    }, {
      name: 'MuiPickersMonth'
    });
    var Month = function (_a) {
      var _b;

      var selected = _a.selected,
          onSelect = _a.onSelect,
          disabled = _a.disabled,
          value = _a.value,
          children = _a.children,
          other = __rest(_a, ["selected", "onSelect", "disabled", "value", "children"]);

      var classes = useStyles$7();
      var handleSelection = React.useCallback(function () {
        onSelect(value);
      }, [onSelect, value]);
      return React.createElement(Typography$2, __assign({
        role: "button",
        component: "div",
        className: clsx(classes.root, (_b = {}, _b[classes.monthSelected] = selected, _b[classes.monthDisabled] = disabled, _b)),
        tabIndex: disabled ? -1 : 0,
        onClick: handleSelection,
        onKeyPress: handleSelection,
        color: selected ? 'primary' : undefined,
        variant: selected ? 'h5' : 'subtitle1',
        children: children
      }, other));
    };
    Month.displayName = 'Month';

    var useStyles$8 = makeStyles({
      container: {
        width: 310,
        display: 'flex',
        flexWrap: 'wrap',
        alignContent: 'stretch'
      }
    }, {
      name: 'MuiPickersMonthSelection'
    });
    var MonthSelection = function (_a) {
      var disablePast = _a.disablePast,
          disableFuture = _a.disableFuture,
          minDate = _a.minDate,
          maxDate = _a.maxDate,
          date = _a.date,
          onMonthChange = _a.onMonthChange,
          onChange = _a.onChange;
      var utils = useUtils();
      var classes = useStyles$8();
      var currentMonth = utils.getMonth(date);

      var shouldDisableMonth = function (month) {
        var now = utils.date();
        var utilMinDate = utils.date(minDate);
        var utilMaxDate = utils.date(maxDate);
        var firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, utilMinDate) ? now : utilMinDate);
        var lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, utilMaxDate) ? now : utilMaxDate);
        var isBeforeFirstEnabled = utils.isBefore(month, firstEnabledMonth);
        var isAfterLastEnabled = utils.isAfter(month, lastEnabledMonth);
        return isBeforeFirstEnabled || isAfterLastEnabled;
      };

      var onMonthSelect = React.useCallback(function (month) {
        var newDate = utils.setMonth(date, month);
        onChange(newDate, true);

        if (onMonthChange) {
          onMonthChange(newDate);
        }
      }, [date, onChange, onMonthChange, utils]);
      return React.createElement("div", {
        className: classes.container
      }, utils.getMonthArray(date).map(function (month) {
        var monthNumber = utils.getMonth(month);
        var monthText = utils.format(month, 'MMM');
        return React.createElement(Month, {
          key: monthText,
          value: monthNumber,
          selected: monthNumber === currentMonth,
          onSelect: onMonthSelect,
          disabled: shouldDisableMonth(month)
        }, monthText);
      }));
    };

    function useViews(views, openTo, onChange) {
      var _a = React.useState(openTo && views.includes(openTo) ? openTo : views[0]),
          openView = _a[0],
          setOpenView = _a[1];

      var getNextAvailableView = React.useCallback(function (nextView) {
        if (views.includes(nextView)) {
          return nextView;
        }

        return views[views.indexOf(openView) + 1];
      }, [openView, views]);
      var handleChangeAndOpenNext = React.useCallback(function (nextView) {
        return function (date, isFinish) {
          var nextViewToOpen = nextView && getNextAvailableView(nextView);

          if (isFinish && nextViewToOpen) {
            // do not close picker if needs to show next view
            onChange(date, false);
            setOpenView(nextViewToOpen);
            return;
          }

          onChange(date, Boolean(isFinish));
        };
      }, [getNextAvailableView, onChange]);
      return {
        handleChangeAndOpenNext: handleChangeAndOpenNext,
        openView: openView,
        setOpenView: setOpenView
      };
    }

    var ClockType;

    (function (ClockType) {
      ClockType["HOURS"] = "hours";
      ClockType["MINUTES"] = "minutes";
      ClockType["SECONDS"] = "seconds";
    })(ClockType || (ClockType = {}));

    var ClockType$1 = ClockType;

    var ClockPointer =
    /** @class */
    function (_super) {
      __extends(ClockPointer, _super);

      function ClockPointer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.state = {
          toAnimateTransform: false,
          previousType: undefined
        };

        _this.getAngleStyle = function () {
          var _a = _this.props,
              value = _a.value,
              isInner = _a.isInner,
              type = _a.type;
          var max = type === ClockType$1.HOURS ? 12 : 60;
          var angle = 360 / max * value;

          if (type === ClockType$1.HOURS && value > 12) {
            angle -= 360; // round up angle to max 360 degrees
          }

          return {
            height: isInner ? '26%' : '40%',
            transform: "rotateZ(" + angle + "deg)"
          };
        };

        return _this;
      }

      ClockPointer.prototype.render = function () {
        var _a, _b;

        var _c = this.props,
            classes = _c.classes,
            hasSelected = _c.hasSelected;
        return React.createElement("div", {
          style: this.getAngleStyle(),
          className: clsx(classes.pointer, (_a = {}, _a[classes.animateTransform] = this.state.toAnimateTransform, _a))
        }, React.createElement("div", {
          className: clsx(classes.thumb, (_b = {}, _b[classes.noPoint] = hasSelected, _b))
        }));
      };

      ClockPointer.getDerivedStateFromProps = function (nextProps, state) {
        if (nextProps.type !== state.previousType) {
          return {
            toAnimateTransform: true,
            previousType: nextProps.type
          };
        }

        return {
          toAnimateTransform: false,
          previousType: nextProps.type
        };
      };

      return ClockPointer;
    }(React.Component);
    var styles$4 = function (theme) {
      return createStyles({
        pointer: {
          width: 2,
          backgroundColor: theme.palette.primary.main,
          position: 'absolute',
          left: 'calc(50% - 1px)',
          bottom: '50%',
          transformOrigin: 'center bottom 0px'
        },
        animateTransform: {
          transition: theme.transitions.create(['transform', 'height'])
        },
        thumb: {
          width: 4,
          height: 4,
          backgroundColor: theme.palette.primary.contrastText,
          borderRadius: '100%',
          position: 'absolute',
          top: -21,
          left: -15,
          border: "14px solid " + theme.palette.primary.main,
          boxSizing: 'content-box'
        },
        noPoint: {
          backgroundColor: theme.palette.primary.main
        }
      });
    };
    var ClockPointer$1 = withStyles(styles$4, {
      name: 'MuiPickersClockPointer'
    })(ClockPointer);

    var center = {
      x: 260 / 2,
      y: 260 / 2
    };
    var basePoint = {
      x: center.x,
      y: 0
    };
    var cx = basePoint.x - center.x;
    var cy = basePoint.y - center.y;

    var rad2deg = function (rad) {
      return rad * 57.29577951308232;
    };

    var getAngleValue = function (step, offsetX, offsetY) {
      var x = offsetX - center.x;
      var y = offsetY - center.y;
      var atan = Math.atan2(cx, cy) - Math.atan2(x, y);
      var deg = rad2deg(atan);
      deg = Math.round(deg / step) * step;
      deg %= 360;
      var value = Math.floor(deg / step) || 0;
      var delta = Math.pow(x, 2) + Math.pow(y, 2);
      var distance = Math.sqrt(delta);
      return {
        value: value,
        distance: distance
      };
    };

    var getHours = function (offsetX, offsetY, ampm) {
      var _a = getAngleValue(30, offsetX, offsetY),
          value = _a.value,
          distance = _a.distance;

      value = value || 12;

      if (!ampm) {
        if (distance < 90) {
          value += 12;
          value %= 24;
        }
      } else {
        value %= 12;
      }

      return value;
    };
    var getMinutes = function (offsetX, offsetY, step) {
      if (step === void 0) {
        step = 1;
      }

      var angleStep = step * 6;
      var value = getAngleValue(angleStep, offsetX, offsetY).value;
      value = value * step % 60;
      return value;
    };
    var getMeridiem = function (date, utils) {
      return utils.getHours(date) >= 12 ? 'pm' : 'am';
    };
    var convertToMeridiem = function (time, meridiem, ampm, utils) {
      if (ampm) {
        var currentMeridiem = utils.getHours(time) >= 12 ? 'pm' : 'am';

        if (currentMeridiem !== meridiem) {
          var hours = meridiem === 'am' ? utils.getHours(time) - 12 : utils.getHours(time) + 12;
          return utils.setHours(time, hours);
        }
      }

      return time;
    };

    var Clock =
    /** @class */
    function (_super) {
      __extends(Clock, _super);

      function Clock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.isMoving = false;

        _this.handleTouchMove = function (e) {
          _this.isMoving = true;

          _this.setTime(e);
        };

        _this.handleTouchEnd = function (e) {
          if (_this.isMoving) {
            _this.setTime(e, true);

            _this.isMoving = false;
          }
        };

        _this.handleMove = function (e) {
          e.preventDefault();
          e.stopPropagation(); // MouseEvent.which is deprecated, but MouseEvent.buttons is not supported in Safari

          var isButtonPressed = typeof e.buttons === 'undefined' ? e.nativeEvent.which === 1 : e.buttons === 1;

          if (isButtonPressed) {
            _this.setTime(e.nativeEvent, false);
          }
        };

        _this.handleMouseUp = function (e) {
          if (_this.isMoving) {
            _this.isMoving = false;
          }

          _this.setTime(e.nativeEvent, true);
        };

        _this.hasSelected = function () {
          var _a = _this.props,
              type = _a.type,
              value = _a.value;

          if (type === ClockType$1.HOURS) {
            return true;
          }

          return value % 5 === 0;
        };

        return _this;
      }

      Clock.prototype.setTime = function (e, isFinish) {
        if (isFinish === void 0) {
          isFinish = false;
        }

        var offsetX = e.offsetX,
            offsetY = e.offsetY;

        if (typeof offsetX === 'undefined') {
          var rect = e.target.getBoundingClientRect();
          offsetX = e.changedTouches[0].clientX - rect.left;
          offsetY = e.changedTouches[0].clientY - rect.top;
        }

        var value = this.props.type === ClockType$1.SECONDS || this.props.type === ClockType$1.MINUTES ? getMinutes(offsetX, offsetY, this.props.minutesStep) : getHours(offsetX, offsetY, Boolean(this.props.ampm));
        this.props.onChange(value, isFinish);
      };

      Clock.prototype.render = function () {
        var _a = this.props,
            classes = _a.classes,
            value = _a.value,
            children = _a.children,
            type = _a.type,
            ampm = _a.ampm;
        var isPointerInner = !ampm && type === ClockType$1.HOURS && (value < 1 || value > 12);
        return React.createElement("div", {
          className: classes.container
        }, React.createElement("div", {
          className: classes.clock
        }, React.createElement("div", {
          role: "menu",
          tabIndex: -1,
          className: classes.squareMask,
          onTouchMove: this.handleTouchMove,
          onTouchEnd: this.handleTouchEnd,
          onMouseUp: this.handleMouseUp,
          onMouseMove: this.handleMove
        }), React.createElement("div", {
          className: classes.pin
        }), React.createElement(ClockPointer$1, {
          type: type,
          value: value,
          isInner: isPointerInner,
          hasSelected: this.hasSelected()
        }), children));
      };

      Clock.propTypes = {
        type: PropTypes.oneOf(Object.keys(ClockType$1).map(function (key) {
          return ClockType$1[key];
        })).isRequired,
        value: PropTypes.number.isRequired,
        onChange: PropTypes.func.isRequired,
        children: PropTypes.arrayOf(PropTypes.node).isRequired,
        ampm: PropTypes.bool,
        minutesStep: PropTypes.number,
        innerRef: PropTypes.any
      };
      Clock.defaultProps = {
        ampm: false,
        minutesStep: 1
      };
      return Clock;
    }(React.Component);
    var styles$5 = function (theme) {
      return createStyles({
        container: {
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'flex-end',
          margin: theme.spacing(2) + "px 0 " + theme.spacing(1) + "px"
        },
        clock: {
          backgroundColor: 'rgba(0,0,0,.07)',
          borderRadius: '50%',
          height: 260,
          width: 260,
          position: 'relative',
          pointerEvents: 'none',
          zIndex: 1
        },
        squareMask: {
          width: '100%',
          height: '100%',
          position: 'absolute',
          pointerEvents: 'auto',
          outline: 'none',
          touchActions: 'none',
          userSelect: 'none',
          '&:active': {
            cursor: 'move'
          }
        },
        pin: {
          width: 6,
          height: 6,
          borderRadius: '50%',
          backgroundColor: theme.palette.primary.main,
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)'
        }
      });
    };
    var Clock$1 = withStyles(styles$5, {
      name: 'MuiPickersClock'
    })(Clock);

    var positions = {
      0: [0, 40],
      1: [55, 19.6],
      2: [94.4, 59.5],
      3: [109, 114],
      4: [94.4, 168.5],
      5: [54.5, 208.4],
      6: [0, 223],
      7: [-54.5, 208.4],
      8: [-94.4, 168.5],
      9: [-109, 114],
      10: [-94.4, 59.5],
      11: [-54.5, 19.6],
      12: [0, 5],
      13: [36.9, 49.9],
      14: [64, 77],
      15: [74, 114],
      16: [64, 151],
      17: [37, 178],
      18: [0, 188],
      19: [-37, 178],
      20: [-64, 151],
      21: [-74, 114],
      22: [-64, 77],
      23: [-37, 50]
    };
    var useStyles$9 = makeStyles(function (theme) {
      var size = theme.spacing(4);
      return {
        clockNumber: {
          width: size,
          height: size,
          userSelect: 'none',
          position: 'absolute',
          left: "calc(50% - " + size / 2 + "px)",
          display: 'inline-flex',
          justifyContent: 'center',
          alignItems: 'center',
          borderRadius: '50%',
          color: theme.palette.type === 'light' ? theme.palette.text.primary : theme.palette.text.hint
        },
        clockNumberSelected: {
          color: theme.palette.primary.contrastText
        }
      };
    }, {
      name: 'MuiPickersClockNumber'
    });
    var ClockNumber = function (_a) {
      var _b;

      var selected = _a.selected,
          label = _a.label,
          index = _a.index,
          isInner = _a.isInner;
      var classes = useStyles$9();
      var className = clsx(classes.clockNumber, (_b = {}, _b[classes.clockNumberSelected] = selected, _b));
      var transformStyle = React.useMemo(function () {
        var position = positions[index];
        return {
          transform: "translate(" + position[0] + "px, " + position[1] + "px"
        };
      }, [index]);
      return React.createElement(Typography$2, {
        component: "span",
        className: className,
        variant: isInner ? 'body2' : 'body1',
        style: transformStyle,
        children: label
      });
    };

    var getHourNumbers = function (_a) {
      var ampm = _a.ampm,
          utils = _a.utils,
          date = _a.date;
      var currentHours = utils.getHours(date);
      var hourNumbers = [];
      var startHour = ampm ? 1 : 0;
      var endHour = ampm ? 12 : 23;

      var isSelected = function (hour) {
        if (ampm) {
          if (hour === 12) {
            return currentHours === 12 || currentHours === 0;
          }

          return currentHours === hour || currentHours - 12 === hour;
        }

        return currentHours === hour;
      };

      for (var hour = startHour; hour <= endHour; hour += 1) {
        var label = hour.toString();

        if (hour === 0) {
          label = '00';
        }

        var props = {
          index: hour,
          label: utils.formatNumber(label),
          selected: isSelected(hour),
          isInner: !ampm && (hour === 0 || hour > 12)
        };
        hourNumbers.push(React.createElement(ClockNumber, __assign({
          key: hour
        }, props)));
      }

      return hourNumbers;
    };
    var getMinutesNumbers = function (_a) {
      var value = _a.value,
          utils = _a.utils;
      var f = utils.formatNumber;
      return [React.createElement(ClockNumber, {
        label: f('00'),
        selected: value === 0,
        index: 12,
        key: 12
      }), React.createElement(ClockNumber, {
        label: f('05'),
        selected: value === 5,
        index: 1,
        key: 1
      }), React.createElement(ClockNumber, {
        label: f('10'),
        selected: value === 10,
        index: 2,
        key: 2
      }), React.createElement(ClockNumber, {
        label: f('15'),
        selected: value === 15,
        index: 3,
        key: 3
      }), React.createElement(ClockNumber, {
        label: f('20'),
        selected: value === 20,
        index: 4,
        key: 4
      }), React.createElement(ClockNumber, {
        label: f('25'),
        selected: value === 25,
        index: 5,
        key: 5
      }), React.createElement(ClockNumber, {
        label: f('30'),
        selected: value === 30,
        index: 6,
        key: 6
      }), React.createElement(ClockNumber, {
        label: f('35'),
        selected: value === 35,
        index: 7,
        key: 7
      }), React.createElement(ClockNumber, {
        label: f('40'),
        selected: value === 40,
        index: 8,
        key: 8
      }), React.createElement(ClockNumber, {
        label: f('45'),
        selected: value === 45,
        index: 9,
        key: 9
      }), React.createElement(ClockNumber, {
        label: f('50'),
        selected: value === 50,
        index: 10,
        key: 10
      }), React.createElement(ClockNumber, {
        label: f('55'),
        selected: value === 55,
        index: 11,
        key: 11
      })];
    };

    var TimePickerView = function (_a) {
      var type = _a.type,
          onHourChange = _a.onHourChange,
          onMinutesChange = _a.onMinutesChange,
          onSecondsChange = _a.onSecondsChange,
          ampm = _a.ampm,
          date = _a.date,
          minutesStep = _a.minutesStep;
      var utils = useUtils();
      var viewProps = React.useMemo(function () {
        switch (type) {
          case ClockType$1.HOURS:
            return {
              value: utils.getHours(date),
              children: getHourNumbers({
                date: date,
                utils: utils,
                ampm: Boolean(ampm)
              }),
              onChange: function (value, isFinish) {
                var currentMeridiem = getMeridiem(date, utils);
                var updatedTimeWithMeridiem = convertToMeridiem(utils.setHours(date, value), currentMeridiem, Boolean(ampm), utils);
                onHourChange(updatedTimeWithMeridiem, isFinish);
              }
            };

          case ClockType$1.MINUTES:
            var minutesValue = utils.getMinutes(date);
            return {
              value: minutesValue,
              children: getMinutesNumbers({
                value: minutesValue,
                utils: utils
              }),
              onChange: function (value, isFinish) {
                var updatedTime = utils.setMinutes(date, value);
                onMinutesChange(updatedTime, isFinish);
              }
            };

          case ClockType$1.SECONDS:
            var secondsValue = utils.getSeconds(date);
            return {
              value: secondsValue,
              children: getMinutesNumbers({
                value: secondsValue,
                utils: utils
              }),
              onChange: function (value, isFinish) {
                var updatedTime = utils.setSeconds(date, value);
                onSecondsChange(updatedTime, isFinish);
              }
            };

          default:
            throw new Error('You must provide the type for TimePickerView');
        }
      }, [ampm, date, onHourChange, onMinutesChange, onSecondsChange, type, utils]);
      return React.createElement(Clock$1, __assign({
        type: type,
        ampm: ampm,
        minutesStep: minutesStep
      }, viewProps));
    };
    TimePickerView.displayName = 'TimePickerView';
    TimePickerView.propTypes = {
      date: PropTypes.object.isRequired,
      onHourChange: PropTypes.func.isRequired,
      onMinutesChange: PropTypes.func.isRequired,
      onSecondsChange: PropTypes.func.isRequired,
      ampm: PropTypes.bool,
      minutesStep: PropTypes.number,
      type: PropTypes.oneOf(Object.keys(ClockType$1).map(function (key) {
        return ClockType$1[key];
      })).isRequired
    };
    TimePickerView.defaultProps = {
      ampm: true,
      minutesStep: 1
    };
    var TimePickerView$1 = React.memo(TimePickerView);

    var viewsMap = {
      year: YearSelection,
      month: MonthSelection,
      date: Calendar$1,
      hours: TimePickerView,
      minutes: TimePickerView,
      seconds: TimePickerView
    };
    var useStyles$a = makeStyles({
      pickerView: {
        minHeight: 305,
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center'
      }
    }, {
      name: 'MuiPickersBasePicker'
    });
    var Picker = function (props) {
      var date = props.date,
          ampm = props.ampm,
          views = props.views,
          disableToolbar = props.disableToolbar,
          disablePast = props.disablePast,
          disableFuture = props.disableFuture,
          hideTabs = props.hideTabs,
          onChange = props.onChange,
          openTo = props.openTo,
          minutesStep = props.minutesStep,
          dateRangeIcon = props.dateRangeIcon,
          timeIcon = props.timeIcon,
          unparsedMinDate = props.minDate,
          unparsedMaxDate = props.maxDate,
          animateYearScrolling = props.animateYearScrolling,
          leftArrowIcon = props.leftArrowIcon,
          rightArrowIcon = props.rightArrowIcon,
          renderDay = props.renderDay,
          shouldDisableDate = props.shouldDisableDate,
          allowKeyboardControl = props.allowKeyboardControl,
          onMonthChange = props.onMonthChange,
          onYearChange = props.onYearChange,
          leftArrowButtonProps = props.leftArrowButtonProps,
          rightArrowButtonProps = props.rightArrowButtonProps,
          ToolbarComponent = props.ToolbarComponent,
          loadingIndicator = props.loadingIndicator;
      var utils = useUtils();
      var classes = useStyles$a();

      var _a = useViews(views, openTo, onChange),
          openView = _a.openView,
          setOpenView = _a.setOpenView,
          handleChangeAndOpenNext = _a.handleChangeAndOpenNext;

      var minDate = React.useMemo(function () {
        return utils.date(unparsedMinDate);
      }, [unparsedMinDate, utils]);
      var maxDate = React.useMemo(function () {
        return utils.date(unparsedMaxDate);
      }, [unparsedMaxDate, utils]);
      return React.createElement(React.Fragment, null, !disableToolbar && React.createElement(ToolbarComponent, __assign({
        date: date,
        onChange: onChange,
        setOpenView: setOpenView,
        openView: openView,
        hideTabs: hideTabs,
        dateRangeIcon: dateRangeIcon,
        timeIcon: timeIcon
      }, props)), React.createElement("div", {
        className: classes.pickerView
      }, openView === 'year' && React.createElement(YearSelection, {
        date: date,
        onChange: handleChangeAndOpenNext('month'),
        minDate: minDate,
        maxDate: maxDate,
        disablePast: disablePast,
        disableFuture: disableFuture,
        onYearChange: onYearChange,
        animateYearScrolling: animateYearScrolling
      }), openView === 'month' && React.createElement(MonthSelection, {
        date: date,
        onChange: handleChangeAndOpenNext('date'),
        minDate: minDate,
        maxDate: maxDate,
        disablePast: disablePast,
        disableFuture: disableFuture,
        onMonthChange: onMonthChange
      }), openView === 'date' && React.createElement(Calendar$1, {
        date: date,
        onChange: handleChangeAndOpenNext('hours'),
        onMonthChange: onMonthChange,
        disablePast: disablePast,
        disableFuture: disableFuture,
        minDate: minDate,
        maxDate: maxDate,
        leftArrowIcon: leftArrowIcon,
        leftArrowButtonProps: leftArrowButtonProps,
        rightArrowIcon: rightArrowIcon,
        rightArrowButtonProps: rightArrowButtonProps,
        renderDay: renderDay,
        shouldDisableDate: shouldDisableDate,
        allowKeyboardControl: allowKeyboardControl,
        loadingIndicator: loadingIndicator
      }), (openView === 'hours' || openView === 'minutes' || openView === 'seconds') && React.createElement(TimePickerView, {
        date: date,
        ampm: ampm,
        type: openView,
        minutesStep: minutesStep,
        onHourChange: handleChangeAndOpenNext('minutes'),
        onMinutesChange: handleChangeAndOpenNext('seconds'),
        onSecondsChange: handleChangeAndOpenNext(null)
      })));
    };
    Picker.defaultProps = __assign({}, datePickerDefaultProps, {
      views: Object.keys(viewsMap)
    });

    var DIALOG_WIDTH = 310;
    var DIALOG_WIDTH_WIDER = 325;

    var ModalDialog = function (_a) {
      var _b, _c;

      var children = _a.children,
          classes = _a.classes,
          onAccept = _a.onAccept,
          onDismiss = _a.onDismiss,
          onClear = _a.onClear,
          onSetToday = _a.onSetToday,
          okLabel = _a.okLabel,
          cancelLabel = _a.cancelLabel,
          clearLabel = _a.clearLabel,
          todayLabel = _a.todayLabel,
          clearable = _a.clearable,
          showTodayButton = _a.showTodayButton,
          showTabs = _a.showTabs,
          wider = _a.wider,
          other = __rest(_a, ["children", "classes", "onAccept", "onDismiss", "onClear", "onSetToday", "okLabel", "cancelLabel", "clearLabel", "todayLabel", "clearable", "showTodayButton", "showTabs", "wider"]);

      return React.createElement(Dialog$1, __assign({
        role: "dialog",
        onClose: onDismiss,
        classes: {
          paper: clsx(classes.dialogRoot, (_b = {}, _b[classes.dialogRootWider] = wider, _b))
        }
      }, other), React.createElement(DialogContent$1, {
        children: children,
        className: classes.dialog
      }), React.createElement(DialogActions$1, {
        classes: {
          root: clsx((_c = {}, _c[classes.withAdditionalAction] = clearable || showTodayButton, _c))
        }
      }, clearable && React.createElement(Button$1, {
        color: "primary",
        onClick: onClear
      }, clearLabel), !clearable && showTodayButton && React.createElement(Button$1, {
        color: "primary",
        onClick: onSetToday
      }, todayLabel), cancelLabel && React.createElement(Button$1, {
        color: "primary",
        onClick: onDismiss
      }, cancelLabel), okLabel && React.createElement(Button$1, {
        color: "primary",
        onClick: onAccept
      }, okLabel)));
    };
    ModalDialog.displayName = 'ModalDialog';
    var styles$6 = createStyles({
      dialogRoot: {
        minWidth: DIALOG_WIDTH,
        maxWidth: DIALOG_WIDTH_WIDER
      },
      dialogRootWider: {
        minWidth: DIALOG_WIDTH_WIDER
      },
      dialog: {
        // minHeight: dialogHeight,
        overflow: 'hidden',
        '&:first-child': {
          padding: 0
        }
      },
      withAdditionalAction: {
        // set justifyContent to default value to fix IE11 layout bug
        // see https://github.com/dmtrKovalenko/material-ui-pickers/pull/267
        justifyContent: 'flex-start',
        '& > *:first-child': {
          marginRight: 'auto'
        }
      }
    });
    var ModalDialog$1 = withStyles(styles$6, {
      name: 'MuiPickersModal'
    })(ModalDialog);

    var ModalWrapper = function (_a) {
      var open = _a.open,
          children = _a.children,
          okLabel = _a.okLabel,
          cancelLabel = _a.cancelLabel,
          clearLabel = _a.clearLabel,
          todayLabel = _a.todayLabel,
          showTodayButton = _a.showTodayButton,
          clearable = _a.clearable,
          DialogProps = _a.DialogProps,
          showTabs = _a.showTabs,
          wider = _a.wider,
          InputComponent = _a.InputComponent,
          DateInputProps = _a.DateInputProps,
          onClear = _a.onClear,
          onAccept = _a.onAccept,
          onDismiss = _a.onDismiss,
          onSetToday = _a.onSetToday,
          other = __rest(_a, ["open", "children", "okLabel", "cancelLabel", "clearLabel", "todayLabel", "showTodayButton", "clearable", "DialogProps", "showTabs", "wider", "InputComponent", "DateInputProps", "onClear", "onAccept", "onDismiss", "onSetToday"]);

      useKeyDown(open, {
        Enter: onAccept
      });
      return React.createElement(React.Fragment, null, React.createElement(InputComponent, __assign({}, other, DateInputProps)), React.createElement(ModalDialog$1, __assign({
        wider: wider,
        showTabs: showTabs,
        open: open,
        onClear: onClear,
        onAccept: onAccept,
        onDismiss: onDismiss,
        onSetToday: onSetToday,
        clearLabel: clearLabel,
        todayLabel: todayLabel,
        okLabel: okLabel,
        cancelLabel: cancelLabel,
        clearable: clearable,
        showTodayButton: showTodayButton,
        children: children
      }, DialogProps)));
    };
    ModalWrapper.propTypes = {
      okLabel: PropTypes.node,
      cancelLabel: PropTypes.node,
      clearLabel: PropTypes.node,
      clearable: PropTypes.bool,
      todayLabel: PropTypes.node,
      showTodayButton: PropTypes.bool,
      DialogProps: PropTypes.object
    };
    ModalWrapper.defaultProps = {
      okLabel: 'OK',
      cancelLabel: 'Cancel',
      clearLabel: 'Clear',
      todayLabel: 'Today',
      clearable: false,
      showTodayButton: false
    };

    var useStyles$b = makeStyles({
      popoverPaper: {
        width: DIALOG_WIDTH,
        paddingBottom: 8
      },
      popoverPaperWider: {
        width: DIALOG_WIDTH_WIDER
      }
    }, {
      name: 'MuiPickersInlineWrapper'
    });
    var InlineWrapper = function (_a) {
      var _b;

      var open = _a.open,
          wider = _a.wider,
          children = _a.children,
          PopoverProps = _a.PopoverProps,
          onClear = _a.onClear,
          onDismiss = _a.onDismiss,
          onSetToday = _a.onSetToday,
          onAccept = _a.onAccept,
          showTabs = _a.showTabs,
          DateInputProps = _a.DateInputProps,
          InputComponent = _a.InputComponent,
          other = __rest(_a, ["open", "wider", "children", "PopoverProps", "onClear", "onDismiss", "onSetToday", "onAccept", "showTabs", "DateInputProps", "InputComponent"]);

      var ref = React.useRef();
      var classes = useStyles$b();
      useKeyDown(open, {
        Enter: onAccept
      });
      return React.createElement(React.Fragment, null, React.createElement(InputComponent, __assign({}, other, DateInputProps, {
        inputRef: ref
      })), React.createElement(Popover$2, __assign({
        open: open,
        onClose: onAccept,
        anchorEl: ref.current,
        classes: {
          paper: clsx(classes.popoverPaper, (_b = {}, _b[classes.popoverPaperWider] = wider, _b))
        },
        anchorOrigin: {
          vertical: 'bottom',
          horizontal: 'right'
        },
        transformOrigin: {
          vertical: 'top',
          horizontal: 'right'
        },
        children: children
      }, PopoverProps)));
    };
    InlineWrapper.propTypes = {
      onOpen: PropTypes.func,
      onClose: PropTypes.func,
      PopoverProps: PropTypes.object
    };

    function getWrapperFromVariant(variant) {
      switch (variant) {
        case 'inline':
          return InlineWrapper;

        default:
          return ModalWrapper;
      }
    }
    var Wrapper = function (_a) {
      var variant = _a.variant,
          props = __rest(_a, ["variant"]);

      var Component = getWrapperFromVariant(variant);
      return React.createElement(Component, __assign({}, props));
    };

    var getDisplayDate = function (value, format, utils, isEmpty, _a) {
      var invalidLabel = _a.invalidLabel,
          emptyLabel = _a.emptyLabel,
          labelFunc = _a.labelFunc;
      var date = utils.date(value);

      if (labelFunc) {
        return labelFunc(isEmpty ? null : date, invalidLabel);
      }

      if (isEmpty) {
        return emptyLabel || '';
      }

      return utils.isValid(date) ? utils.format(date, format) : invalidLabel;
    };

    var getComparisonMaxDate = function (utils, strictCompareDates, date) {
      if (strictCompareDates) {
        return date;
      }

      return utils.endOfDay(date);
    };

    var getComparisonMinDate = function (utils, strictCompareDates, date) {
      if (strictCompareDates) {
        return date;
      }

      return utils.startOfDay(date);
    };

    var validate = function (value, utils, _a // DateTimePicker doesn't support
    ) {
      var maxDate = _a.maxDate,
          minDate = _a.minDate,
          disablePast = _a.disablePast,
          disableFuture = _a.disableFuture,
          maxDateMessage = _a.maxDateMessage,
          minDateMessage = _a.minDateMessage,
          invalidDateMessage = _a.invalidDateMessage,
          strictCompareDates = _a.strictCompareDates;
      var parsedValue = utils.date(value); // if null - do not show error

      if (value === null) {
        return '';
      }

      if (!utils.isValid(value)) {
        return invalidDateMessage;
      }

      if (maxDate && utils.isAfter(parsedValue, getComparisonMaxDate(utils, !!strictCompareDates, utils.date(maxDate)))) {
        return maxDateMessage;
      }

      if (disableFuture && utils.isAfter(parsedValue, getComparisonMaxDate(utils, !!strictCompareDates, utils.date()))) {
        return maxDateMessage;
      }

      if (minDate && utils.isBefore(parsedValue, getComparisonMinDate(utils, !!strictCompareDates, utils.date(minDate)))) {
        return minDateMessage;
      }

      if (disablePast && utils.isBefore(parsedValue, getComparisonMinDate(utils, !!strictCompareDates, utils.date()))) {
        return minDateMessage;
      }

      return '';
    };
    function pick12hOr24hFormat(userFormat, ampm, formats) {
      if (ampm === void 0) {
        ampm = true;
      }

      if (userFormat) {
        return userFormat;
      }

      return ampm ? formats['12h'] : formats['24h'];
    }
    function makeMaskFromFormat(format, numberMaskChar) {
      return format.replace(/[a-z]/gi, numberMaskChar);
    }
    var maskedDateFormatter = function (mask, numberMaskChar, refuse) {
      return function (value) {
        if (value === '') {
          return value;
        }

        var result = '';
        var parsed = value.replace(refuse, '');
        var i = 0;
        var n = 0;

        while (i < mask.length) {
          var maskChar = mask[i];

          if (maskChar === numberMaskChar && n < parsed.length) {
            var parsedChar = parsed[n];
            result += parsedChar;
            n += 1;
          } else {
            result += maskChar;
          }

          i += 1;
        }

        return result;
      };
    };

    var valueToDate = function (utils, _a) {
      var value = _a.value,
          initialFocusedDate = _a.initialFocusedDate;
      var initialDate = value || initialFocusedDate || utils.date();
      var date = utils.date(initialDate);
      return date && utils.isValid(date) ? date : utils.date();
    };

    function useDateValues(props, options) {
      var utils = useUtils();
      var date = valueToDate(utils, props);
      var acceptedDateRef = React.useRef(date);
      var format = props.format || options.getDefaultFormat();
      return {
        acceptedDateRef: acceptedDateRef,
        date: date,
        format: format
      };
    }

    function makeControlledOpenProps(props) {
      return {
        isOpen: props.open,
        setIsOpen: function (newIsOpen) {
          return newIsOpen ? props.onOpen && props.onOpen() : props.onClose && props.onClose();
        }
      };
    }
    /* eslint-disable react-hooks/rules-of-hooks */


    function useOpenState(props) {
      if (props.open !== undefined && props.open !== null) {
        return makeControlledOpenProps(props);
      }

      var _a = React.useState(false),
          isOpen = _a[0],
          setIsOpenState = _a[1]; // prettier-ignore


      var setIsOpen = React.useCallback(function (newIsOpen) {
        setIsOpenState(newIsOpen);
        return newIsOpen ? props.onOpen && props.onOpen() : props.onClose && props.onClose();
      }, [props]);
      return {
        isOpen: isOpen,
        setIsOpen: setIsOpen
      };
    }
    /* eslint-enable react-hooks/rules-of-hooks */


    function usePickerState(props, options) {
      var utils = useUtils();

      var _a = useOpenState(props),
          isOpen = _a.isOpen,
          setIsOpen = _a.setIsOpen;

      var _b = useDateValues(props, options),
          acceptedDateRef = _b.acceptedDateRef,
          date = _b.date,
          format = _b.format;

      if (!isOpen) {
        // if value was changed in closed state treat it as accepted
        acceptedDateRef.current = date;
      }

      var validationError = validate(props.value, utils, props);
      React.useEffect(function () {
        if (validationError && props.onError) {
          props.onError(validationError, props.value);
        }
      }, [props, validationError]);
      var inputProps = React.useMemo(function () {
        return {
          validationError: validationError,
          onClick: function () {
            return !props.disabled && setIsOpen(true);
          },
          inputValue: getDisplayDate(acceptedDateRef.current, format, utils, props.value === null, props)
        };
      }, [acceptedDateRef, format, props, setIsOpen, utils, validationError]); // prettier-ignore

      var acceptDate = React.useCallback(function (acceptedDate) {
        acceptedDateRef.current = acceptedDate;
        setIsOpen(false);
        props.onChange(acceptedDate);

        if (props.onAccept) {
          props.onAccept(acceptedDate);
        }
      }, [acceptedDateRef, setIsOpen, props]);
      var wrapperProps = React.useMemo(function () {
        return {
          format: format,
          open: isOpen,
          onAccept: function () {
            return acceptDate(date);
          },
          onClear: function () {
            return acceptDate(null);
          },
          onSetToday: function () {
            return props.onChange(utils.date());
          },
          onDismiss: function () {
            setIsOpen(false);
            props.onChange(acceptedDateRef.current);
          }
        };
      }, [acceptDate, acceptedDateRef, date, format, isOpen, props, setIsOpen, utils]);
      var pickerProps = React.useMemo(function () {
        return {
          date: date,
          onChange: function (newDate, isFinish) {
            if (isFinish === void 0) {
              isFinish = true;
            }

            props.onChange(newDate);

            if (isFinish && props.autoOk) {
              acceptDate(newDate);
            }
          }
        };
      }, [acceptDate, date, props]);
      var pickerState = {
        pickerProps: pickerProps,
        inputProps: inputProps,
        wrapperProps: wrapperProps
      };
      React.useDebugValue(pickerState);
      return pickerState;
    }

    var PureDateInput = function (_a) {
      var inputValue = _a.inputValue,
          inputVariant = _a.inputVariant,
          validationError = _a.validationError,
          InputProps = _a.InputProps,
          _b = _a.TextFieldComponent,
          TextFieldComponent = _b === void 0 ? TextField$1 : _b,
          other = __rest(_a, ["inputValue", "inputVariant", "validationError", "InputProps", "TextFieldComponent"]);

      var PureDateInputProps = React.useMemo(function () {
        return __assign({}, InputProps, {
          readOnly: true
        });
      }, [InputProps]);
      return React.createElement(TextFieldComponent, __assign({
        error: Boolean(validationError),
        helperText: validationError
      }, other, {
        // do not overridable
        value: inputValue,
        variant: inputVariant,
        InputProps: PureDateInputProps
      }));
    };
    PureDateInput.displayName = 'PureDateInput';

    function makePurePicker(_a) {
      var useOptions = _a.useOptions,
          ToolbarComponent = _a.ToolbarComponent;

      function WrappedPurePicker(props) {
        var allowKeyboardControl = props.allowKeyboardControl,
            ampm = props.ampm,
            hideTabs = props.hideTabs,
            animateYearScrolling = props.animateYearScrolling,
            autoOk = props.autoOk,
            disableFuture = props.disableFuture,
            disablePast = props.disablePast,
            format = props.format,
            forwardedRef = props.forwardedRef,
            initialFocusedDate = props.initialFocusedDate,
            invalidDateMessage = props.invalidDateMessage,
            labelFunc = props.labelFunc,
            leftArrowIcon = props.leftArrowIcon,
            leftArrowButtonProps = props.leftArrowButtonProps,
            maxDate = props.maxDate,
            maxDateMessage = props.maxDateMessage,
            minDate = props.minDate,
            onOpen = props.onOpen,
            onClose = props.onClose,
            minDateMessage = props.minDateMessage,
            strictCompareDates = props.strictCompareDates,
            minutesStep = props.minutesStep,
            onAccept = props.onAccept,
            onChange = props.onChange,
            onMonthChange = props.onMonthChange,
            onYearChange = props.onYearChange,
            renderDay = props.renderDay,
            views = props.views,
            openTo = props.openTo,
            rightArrowIcon = props.rightArrowIcon,
            rightArrowButtonProps = props.rightArrowButtonProps,
            shouldDisableDate = props.shouldDisableDate,
            dateRangeIcon = props.dateRangeIcon,
            timeIcon = props.timeIcon,
            value = props.value,
            variant = props.variant,
            disableToolbar = props.disableToolbar,
            loadingIndicator = props.loadingIndicator,
            other = __rest(props, ["allowKeyboardControl", "ampm", "hideTabs", "animateYearScrolling", "autoOk", "disableFuture", "disablePast", "format", "forwardedRef", "initialFocusedDate", "invalidDateMessage", "labelFunc", "leftArrowIcon", "leftArrowButtonProps", "maxDate", "maxDateMessage", "minDate", "onOpen", "onClose", "minDateMessage", "strictCompareDates", "minutesStep", "onAccept", "onChange", "onMonthChange", "onYearChange", "renderDay", "views", "openTo", "rightArrowIcon", "rightArrowButtonProps", "shouldDisableDate", "dateRangeIcon", "timeIcon", "value", "variant", "disableToolbar", "loadingIndicator"]);

        var options = useOptions(props);

        var _a = usePickerState(props, options),
            pickerProps = _a.pickerProps,
            inputProps = _a.inputProps,
            wrapperProps = _a.wrapperProps;

        return React.createElement(Wrapper, __assign({
          variant: variant,
          InputComponent: PureDateInput,
          DateInputProps: inputProps
        }, wrapperProps, other), React.createElement(Picker, __assign({}, pickerProps, {
          disableToolbar: disableToolbar,
          ToolbarComponent: ToolbarComponent,
          hideTabs: hideTabs,
          ampm: ampm,
          views: views,
          openTo: openTo,
          allowKeyboardControl: allowKeyboardControl,
          minutesStep: minutesStep,
          animateYearScrolling: animateYearScrolling,
          disableFuture: disableFuture,
          disablePast: disablePast,
          leftArrowIcon: leftArrowIcon,
          leftArrowButtonProps: leftArrowButtonProps,
          maxDate: maxDate,
          minDate: minDate,
          strictCompareDates: strictCompareDates,
          onMonthChange: onMonthChange,
          onYearChange: onYearChange,
          renderDay: renderDay,
          dateRangeIcon: dateRangeIcon,
          timeIcon: timeIcon,
          rightArrowIcon: rightArrowIcon,
          rightArrowButtonProps: rightArrowButtonProps,
          shouldDisableDate: shouldDisableDate,
          loadingIndicator: loadingIndicator
        })));
      }

      return WrappedPurePicker;
    }

    var Rifm =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(Rifm, _React$Component);

      function Rifm(props) {
        var _this;

        _this = _React$Component.call(this, props) || this;
        _this._state = null;
        _this._del = false;

        _this._handleChange = function (evt) {
          {
            if (evt.target.type === 'number') {
              console.error('Rifm does not support input type=number, use type=tel instead.');
              return;
            }
          } // FUTURE: use evt.nativeEvent.inputType for del event, see comments at onkeydown


          var stateValue = _this.state.value;
          var value = evt.target.value;
          var input = evt.target;
          var op = value.length > stateValue.length;
          var del = _this._del;

          var noOp = stateValue === _this.props.format(value);

          _this.setState({
            value: value,
            local: true
          }, function () {
            var selectionStart = input.selectionStart;
            var refuse = _this.props.refuse || /[^\d]+/g;
            var before = value.substr(0, selectionStart).replace(refuse, '');
            _this._state = {
              input: input,
              before: before,
              op: op,
              di: del && noOp,
              del: del
            };

            if (_this.props.replace && _this.props.replace(stateValue) && op && !noOp) {
              var start = -1;

              for (var i = 0; i !== before.length; ++i) {
                start = Math.max(start, value.toLowerCase().indexOf(before[i].toLowerCase(), start + 1));
              }

              var c = value.substr(start + 1).replace(refuse, '')[0];
              start = value.indexOf(c, start + 1);
              value = "" + value.substr(0, start) + value.substr(start + 1);
            }

            var fv = _this.props.format(value);

            if (stateValue === fv) {
              _this.setState({
                value: value
              });
            } else {
              _this.props.onChange(fv);
            }
          });
        };

        _this._hKD = function (evt) {
          if (evt.code === 'Delete') {
            _this._del = true;
          }
        };

        _this._hKU = function (evt) {
          if (evt.code === 'Delete') {
            _this._del = false;
          }
        };

        _this.state = {
          value: props.value,
          local: true
        };
        return _this;
      }

      Rifm.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        return {
          value: state.local ? state.value : props.value,
          local: false
        };
      };

      var _proto = Rifm.prototype;

      _proto.render = function render() {
        var _handleChange = this._handleChange,
            value = this.state.value,
            children = this.props.children;
        return children({
          value: value,
          onChange: _handleChange
        });
      } // delete when  https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported by all major browsers
      ;

      _proto.componentWillUnmount = function componentWillUnmount() {
        document.removeEventListener('keydown', this._hKD);
        document.removeEventListener('keyup', this._hKU);
      } // delete when  https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported by all major browsers
      ;

      _proto.componentDidMount = function componentDidMount() {
        document.addEventListener('keydown', this._hKD);
        document.addEventListener('keyup', this._hKU);
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        var _state = this._state;

        if (_state) {
          var value = this.state.value;
          var start = -1;

          for (var i = 0; i !== _state.before.length; ++i) {
            start = Math.max(start, value.toLowerCase().indexOf(_state.before[i].toLowerCase(), start + 1));
          } // format usually looks better without this


          if (this.props.replace && (_state.op || _state.del && !_state.di)) {
            while (value[start + 1] && (this.props.refuse || /[^\d]+/).test(value[start + 1])) {
              start += 1;
            }
          }

          _state.input.selectionStart = _state.input.selectionEnd = start + 1 + (_state.di ? 1 : 0);
        }

        this._state = null;
      };

      return Rifm;
    }(React.Component);

    var styles$7 = function styles(theme) {
      var elevations = {};
      theme.shadows.forEach(function (shadow, index) {
        elevations["elevation".concat(index)] = {
          boxShadow: shadow
        };
      });
      return _extends_1({
        /* Styles applied to the root element. */
        root: {
          backgroundColor: theme.palette.background.paper,
          color: theme.palette.text.primary,
          transition: theme.transitions.create('box-shadow')
        },

        /* Styles applied to the root element if `square={false}`. */
        rounded: {
          borderRadius: theme.shape.borderRadius
        }
      }, elevations);
    };
    var Paper = React__default.forwardRef(function Paper(props, ref) {
      var classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$square = props.square,
          square = _props$square === void 0 ? false : _props$square,
          _props$elevation = props.elevation,
          elevation = _props$elevation === void 0 ? 1 : _props$elevation,
          other = objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation"]);

      warning_1(elevation >= 0 && elevation < 25, "Material-UI: this elevation `".concat(elevation, "` is not implemented."));
      var className = clsx(classes.root, classes["elevation".concat(elevation)], !square && classes.rounded, classNameProp);
      return React__default.createElement(Component, _extends_1({
        className: className,
        ref: ref
      }, other));
    });
    Paper.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Shadow depth, corresponds to `dp` in the spec.
       * It accepts values between 0 and 24 inclusive.
       */
      elevation: PropTypes__default.number,

      /**
       * If `true`, rounded corners are disabled.
       */
      square: PropTypes__default.bool
    };
    var Paper$1 = withStyles(styles$7, {
      name: 'MuiPaper'
    })(Paper);

    var styles$8 = function styles(theme) {
      var backgroundColorDefault = theme.palette.type === 'light' ? theme.palette.grey[100] : theme.palette.grey[900];
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'flex',
          flexDirection: 'column',
          width: '100%',
          boxSizing: 'border-box',
          // Prevent padding issue with the Modal and fixed positioned AppBar.
          zIndex: theme.zIndex.appBar,
          flexShrink: 0
        },

        /* Styles applied to the root element if `position="fixed"`. */
        positionFixed: {
          position: 'fixed',
          top: 0,
          left: 'auto',
          right: 0
        },

        /* Styles applied to the root element if `position="absolute"`. */
        positionAbsolute: {
          position: 'absolute',
          top: 0,
          left: 'auto',
          right: 0
        },

        /* Styles applied to the root element if `position="sticky"`. */
        positionSticky: {
          position: 'sticky',
          top: 0,
          left: 'auto',
          right: 0
        },

        /* Styles applied to the root element if `position="static"`. */
        positionStatic: {
          position: 'static'
        },

        /* Styles applied to the root element if `position="relative"`. */
        positionRelative: {
          position: 'relative'
        },

        /* Styles applied to the root element if `color="default"`. */
        colorDefault: {
          backgroundColor: backgroundColorDefault,
          color: theme.palette.getContrastText(backgroundColorDefault)
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          backgroundColor: theme.palette.primary.main,
          color: theme.palette.primary.contrastText
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          backgroundColor: theme.palette.secondary.main,
          color: theme.palette.secondary.contrastText
        }
      };
    };
    var AppBar = React__default.forwardRef(function AppBar(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'primary' : _props$color,
          _props$position = props.position,
          position = _props$position === void 0 ? 'fixed' : _props$position,
          other = objectWithoutProperties(props, ["classes", "className", "color", "position"]);

      return React__default.createElement(Paper$1, _extends_1({
        square: true,
        component: "header",
        elevation: 4,
        className: clsx(classes.root, classes["position".concat(capitalize(position))], color !== 'inherit' && classes["color".concat(capitalize(color))], position === 'fixed' && 'mui-fixed', className),
        ref: ref
      }, other));
    });
    AppBar.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['inherit', 'primary', 'secondary', 'default']),

      /**
       * The positioning type. The behavior of the different options is described
       * [in the MDN web docs](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning).
       * Note: `sticky` is not universally supported and will fall back to `static` when unavailable.
       */
      position: PropTypes__default.oneOf(['fixed', 'absolute', 'sticky', 'static', 'relative'])
    };
    withStyles(styles$8, {
      name: 'MuiAppBar'
    })(AppBar);

    var styles$9 = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexShrink: 0,
          width: 40,
          height: 40,
          fontFamily: theme.typography.fontFamily,
          fontSize: theme.typography.pxToRem(20),
          borderRadius: '50%',
          overflow: 'hidden',
          userSelect: 'none'
        },

        /* Styles applied to the root element if there are children and not `src` or `srcSet`. */
        colorDefault: {
          color: theme.palette.background.default,
          backgroundColor: theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[600]
        },

        /* Styles applied to the img element if either `src` or `srcSet` is defined. */
        img: {
          width: '100%',
          height: '100%',
          textAlign: 'center',
          // Handle non-square image. The property isn't supported by IE 11.
          objectFit: 'cover'
        }
      };
    };
    var Avatar = React__default.forwardRef(function Avatar(props, ref) {
      var alt = props.alt,
          childrenProp = props.children,
          childrenClassNameProp = props.childrenClassName,
          classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          imgProps = props.imgProps,
          sizes = props.sizes,
          src = props.src,
          srcSet = props.srcSet,
          other = objectWithoutProperties(props, ["alt", "children", "childrenClassName", "classes", "className", "component", "imgProps", "sizes", "src", "srcSet"]);

      var children = null;
      var img = src || srcSet;

      if (img) {
        children = React__default.createElement("img", _extends_1({
          alt: alt,
          src: src,
          srcSet: srcSet,
          sizes: sizes,
          className: classes.img
        }, imgProps));
      } else if (childrenClassNameProp && React__default.isValidElement(childrenProp)) {
        children = React__default.cloneElement(childrenProp, {
          className: clsx(childrenClassNameProp, childrenProp.props.className)
        });
      } else {
        children = childrenProp;
      }

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, classes.system, !img && classes.colorDefault, classNameProp),
        ref: ref
      }, other), children);
    });
    Avatar.propTypes = {
      /**
       * Used in combination with `src` or `srcSet` to
       * provide an alt attribute for the rendered `img` element.
       */
      alt: PropTypes__default.string,

      /**
       * Used to render icon or text elements inside the Avatar.
       * `src` and `alt` props will not be used and no `img` will
       * be rendered by default.
       *
       * This can be an element, or just a string.
       */
      children: PropTypes__default.node,

      /**
       * @ignore
       * The className of the child element.
       * Used by Chip and ListItemIcon to style the Avatar icon.
       */
      childrenClassName: PropTypes__default.string,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Attributes applied to the `img` element if the component
       * is used to display an image.
       */
      imgProps: PropTypes__default.object,

      /**
       * The `sizes` attribute for the `img` element.
       */
      sizes: PropTypes__default.string,

      /**
       * The `src` attribute for the `img` element.
       */
      src: PropTypes__default.string,

      /**
       * The `srcSet` attribute for the `img` element.
       */
      srcSet: PropTypes__default.string
    };
    withStyles(styles$9, {
      name: 'MuiAvatar'
    })(Avatar);

    var reflow = function reflow(node) {
      return node.scrollTop;
    };
    function getTransitionProps(props, options) {
      var timeout = props.timeout,
          _props$style = props.style,
          style = _props$style === void 0 ? {} : _props$style;
      return {
        duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode],
        delay: style.transitionDelay
      };
    }

    function isMuiElement(element, muiNames) {
      return React__default.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
    }
    function setRef(ref, value) {
      if (typeof ref === 'function') {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    function useForkRef(refA, refB) {
      /**
       * This will create a new function if the ref props change and are defined.
       * This means react will call the old forkRef with `null` and the new forkRef
       * with the ref. Cleanup naturally emerges from this behavior
       */
      return React__default.useMemo(function () {
        if (refA == null && refB == null) {
          return null;
        }

        return function (refValue) {
          setRef(refA, refValue);
          setRef(refB, refValue);
        };
      }, [refA, refB]);
    }

    var styles$a = {
      entering: {
        opacity: 1
      },
      entered: {
        opacity: 1
      }
    };
    var defaultTimeout = {
      enter: duration.enteringScreen,
      exit: duration.leavingScreen
    };
    /**
     * The Fade transition is used by the [Modal](/components/modal/) component.
     * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
     */

    var Fade = React__default.forwardRef(function Fade(props, ref) {
      var children = props.children,
          inProp = props.in,
          onEnter = props.onEnter,
          onExit = props.onExit,
          style = props.style,
          theme = props.theme,
          _props$timeout = props.timeout,
          timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout,
          other = objectWithoutProperties(props, ["children", "in", "onEnter", "onExit", "style", "theme", "timeout"]);

      var handleRef = useForkRef(children.ref, ref);

      var handleEnter = function handleEnter(node) {
        reflow(node); // So the animation always start from the start.

        var transitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'enter'
        });
        node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
        node.style.transition = theme.transitions.create('opacity', transitionProps);

        if (onEnter) {
          onEnter(node);
        }
      };

      var handleExit = function handleExit(node) {
        var transitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'exit'
        });
        node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
        node.style.transition = theme.transitions.create('opacity', transitionProps);

        if (onExit) {
          onExit(node);
        }
      };

      return React__default.createElement(Transition, _extends_1({
        appear: true,
        in: inProp,
        onEnter: handleEnter,
        onExit: handleExit,
        timeout: timeout
      }, other), function (state, childProps) {
        return React__default.cloneElement(children, _extends_1({
          style: _extends_1({
            opacity: 0,
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, styles$a[state], style, children.props.style),
          ref: handleRef
        }, childProps));
      });
    });
    Fade.propTypes = {
      /**
       * A single child content element.
       */
      children: PropTypes__default.element,

      /**
       * If `true`, the component will transition in.
       */
      in: PropTypes__default.bool,

      /**
       * @ignore
       */
      onEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onExit: PropTypes__default.func,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      timeout: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })])
    };
    var Fade$1 = withTheme(Fade);

    var styles$b = {
      /* Styles applied to the root element. */
      root: {
        zIndex: -1,
        position: 'fixed',
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        // Remove grey highlight
        WebkitTapHighlightColor: 'transparent',
        // Disable scroll capabilities.
        touchAction: 'none'
      },

      /* Styles applied to the root element if `invisible={true}`. */
      invisible: {
        backgroundColor: 'transparent'
      }
    };
    var Backdrop = React__default.forwardRef(function Backdrop(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$invisible = props.invisible,
          invisible = _props$invisible === void 0 ? false : _props$invisible,
          open = props.open,
          transitionDuration = props.transitionDuration,
          other = objectWithoutProperties(props, ["classes", "className", "invisible", "open", "transitionDuration"]);

      return React__default.createElement(Fade$1, _extends_1({
        in: open,
        timeout: transitionDuration
      }, other), React__default.createElement("div", {
        className: clsx(classes.root, invisible && classes.invisible, className),
        "aria-hidden": true,
        ref: ref
      }));
    });
    Backdrop.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the backdrop is invisible.
       * It can be used when rendering a popover or a custom select component.
       */
      invisible: PropTypes__default.bool,

      /**
       * If `true`, the backdrop is open.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })])
    };
    var Backdrop$1 = withStyles(styles$b, {
      name: 'MuiBackdrop'
    })(Backdrop);

    var RADIUS = 10;
    var styles$c = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          display: 'inline-flex',
          // For correct alignment with the text.
          verticalAlign: 'middle'
        },

        /* Styles applied to the badge `span` element. */
        badge: {
          display: 'flex',
          flexDirection: 'row',
          flexWrap: 'wrap',
          justifyContent: 'center',
          alignContent: 'center',
          alignItems: 'center',
          position: 'absolute',
          top: 0,
          right: 0,
          boxSizing: 'border-box',
          fontFamily: theme.typography.fontFamily,
          fontWeight: theme.typography.fontWeightMedium,
          fontSize: theme.typography.pxToRem(12),
          minWidth: RADIUS * 2,
          padding: '0 4px',
          height: RADIUS * 2,
          borderRadius: RADIUS,
          backgroundColor: theme.palette.color,
          color: theme.palette.textColor,
          zIndex: 1,
          // Render the badge on top of potential ripples.
          transform: 'scale(1) translate(50%, -50%)',
          transformOrigin: '100% 0%',
          transition: theme.transitions.create('transform', {
            easing: theme.transitions.easing.easeInOut,
            duration: theme.transitions.duration.enteringScreen
          })
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          backgroundColor: theme.palette.primary.main,
          color: theme.palette.primary.contrastText
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          backgroundColor: theme.palette.secondary.main,
          color: theme.palette.secondary.contrastText
        },

        /* Styles applied to the root element if `color="error"`. */
        colorError: {
          backgroundColor: theme.palette.error.main,
          color: theme.palette.error.contrastText
        },

        /* Styles applied to the badge `span` element if `invisible={true}`. */
        invisible: {
          transition: theme.transitions.create('transform', {
            easing: theme.transitions.easing.easeInOut,
            duration: theme.transitions.duration.leavingScreen
          }),
          transform: 'scale(0) translate(50%, -50%)',
          transformOrigin: '100% 0%'
        },

        /* Styles applied to the root element if `variant="dot"`. */
        dot: {
          height: 6,
          minWidth: 6,
          padding: 0
        }
      };
    };
    var Badge = React__default.forwardRef(function Badge(props, ref) {
      var badgeContent = props.badgeContent,
          children = props.children,
          classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$component = props.component,
          ComponentProp = _props$component === void 0 ? 'span' : _props$component,
          invisibleProp = props.invisible,
          _props$max = props.max,
          max = _props$max === void 0 ? 99 : _props$max,
          _props$showZero = props.showZero,
          showZero = _props$showZero === void 0 ? false : _props$showZero,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'standard' : _props$variant,
          other = objectWithoutProperties(props, ["badgeContent", "children", "classes", "className", "color", "component", "invisible", "max", "showZero", "variant"]);

      var invisible = invisibleProp;

      if (invisibleProp == null && (badgeContent === 0 && !showZero || badgeContent == null && variant !== 'dot')) {
        invisible = true;
      }

      var displayValue = '';

      if (variant !== 'dot') {
        displayValue = badgeContent > max ? "".concat(max, "+") : badgeContent;
      }

      return React__default.createElement(ComponentProp, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other), children, React__default.createElement("span", {
        className: clsx(classes.badge, color !== 'default' && classes["color".concat(capitalize(color))], invisible && classes.invisible, variant === 'dot' && classes.dot)
      }, displayValue));
    });
    Badge.propTypes = {
      /**
       * The content rendered within the badge.
       */
      badgeContent: PropTypes__default.node,

      /**
       * The badge will be added relative to this node.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'primary', 'secondary', 'error']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the badge will be invisible.
       */
      invisible: PropTypes__default.bool,

      /**
       * Max count to show.
       */
      max: PropTypes__default.number,

      /**
       * Controls whether the badge is hidden when `badgeContent` is zero.
       */
      showZero: PropTypes__default.bool,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'dot'])
    };
    withStyles(styles$c, {
      name: 'MuiBadge'
    })(Badge);

    var styles$d = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'flex',
          justifyContent: 'center',
          height: 56,
          backgroundColor: theme.palette.background.paper
        }
      };
    };
    var BottomNavigation = React__default.forwardRef(function BottomNavigation(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          onChange = props.onChange,
          _props$showLabels = props.showLabels,
          showLabels = _props$showLabels === void 0 ? false : _props$showLabels,
          value = props.value,
          other = objectWithoutProperties(props, ["children", "classes", "className", "component", "onChange", "showLabels", "value"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other), React__default.Children.map(children, function (child, childIndex) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        warning_1(child.type !== React__default.Fragment, ["Material-UI: the BottomNavigation component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        var childValue = child.props.value === undefined ? childIndex : child.props.value;
        return React__default.cloneElement(child, {
          selected: childValue === value,
          showLabel: child.props.showLabel !== undefined ? child.props.showLabel : showLabels,
          value: childValue,
          onChange: onChange
        });
      }));
    });
    BottomNavigation.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Callback fired when the value changes.
       *
       * @param {object} event The event source of the callback
       * @param {any} value We default to the index of the child
       */
      onChange: PropTypes__default.func,

      /**
       * If `true`, all `BottomNavigationAction`s will show their labels.
       * By default, only the selected `BottomNavigationAction` will show its label.
       */
      showLabels: PropTypes__default.bool,

      /**
       * The value of the currently selected `BottomNavigationAction`.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$d, {
      name: 'MuiBottomNavigation'
    })(BottomNavigation);

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    var arrayWithHoles = _arrayWithHoles;

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    var iterableToArrayLimit = _iterableToArrayLimit;

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    var nonIterableRest = _nonIterableRest;

    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
    }

    var slicedToArray = _slicedToArray;

    var useEnhancedEffect = typeof window !== 'undefined' && "development" !== 'test' ? React__default.useLayoutEffect : React__default.useEffect;
    /**
     * NoSsr purposely removes components from the subject of Server Side Rendering (SSR).
     *
     * This component can be useful in a variety of situations:
     * - Escape hatch for broken dependencies not supporting SSR.
     * - Improve the time-to-first paint on the client by only rendering above the fold.
     * - Reduce the rendering time on the server.
     * - Under too heavy server load, you can turn on service degradation.
     */

    function NoSsr(props) {
      var children = props.children,
          _props$defer = props.defer,
          defer = _props$defer === void 0 ? false : _props$defer,
          _props$fallback = props.fallback,
          fallback = _props$fallback === void 0 ? null : _props$fallback;

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          mountedState = _React$useState2[0],
          setMountedState = _React$useState2[1];

      useEnhancedEffect(function () {
        if (!defer) {
          setMountedState(true);
        }
      }, [defer]);
      React__default.useEffect(function () {
        if (defer) {
          setMountedState(true);
        }
      }, [defer]); // We need the Fragment here to force react-docgen to recognise NoSsr as a component.

      return React__default.createElement(React__default.Fragment, null, mountedState ? children : fallback);
    }

    NoSsr.propTypes = {
      /**
       * You can wrap a node.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * If `true`, the component will not only prevent server-side rendering.
       * It will also defer the rendering of the children into a different screen frame.
       */
      defer: PropTypes__default.bool,

      /**
       * The fallback content to display.
       */
      fallback: PropTypes__default.node
    };

    {
      // eslint-disable-next-line
      NoSsr['propTypes' + ''] = exactProp(NoSsr.propTypes);
    }

    // based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
    var hadKeyboardEvent = true;
    var hadFocusVisibleRecently = false;
    var hadFocusVisibleRecentlyTimeout = null;
    var inputTypesWhitelist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      'datetime-local': true
    };
    /**
     * Computes whether the given element should automatically trigger the
     * `focus-visible` class being added, i.e. whether it should always match
     * `:focus-visible` when focused.
     * @param {Element} node
     * @return {boolean}
     */

    function focusTriggersKeyboardModality(node) {
      var type = node.type,
          tagName = node.tagName;

      if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
        return true;
      }

      if (tagName === 'TEXTAREA' && !node.readOnly) {
        return true;
      }

      if (node.isContentEditable) {
        return true;
      }

      return false;
    }

    function handleKeyDown() {
      hadKeyboardEvent = true;
    }
    /**
     * If at any point a user clicks with a pointing device, ensure that we change
     * the modality away from keyboard.
     * This avoids the situation where a user presses a key on an already focused
     * element, and then clicks on a different element, focusing it with a
     * pointing device, while we still think we're in keyboard modality.
     * @param {Event} e
     */


    function handlePointerDown() {
      hadKeyboardEvent = false;
    }

    function handleVisibilityChange() {
      if (this.visibilityState === 'hidden') {
        // If the tab becomes active again, the browser will handle calling focus
        // on the element (Safari actually calls it twice).
        // If this tab change caused a blur on an element with focus-visible,
        // re-apply the class when the user switches back to the tab.
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
      }
    }

    function prepare(ownerDocument) {
      ownerDocument.addEventListener('keydown', handleKeyDown, true);
      ownerDocument.addEventListener('mousedown', handlePointerDown, true);
      ownerDocument.addEventListener('pointerdown', handlePointerDown, true);
      ownerDocument.addEventListener('touchstart', handlePointerDown, true);
      ownerDocument.addEventListener('visibilitychange', handleVisibilityChange, true);
    }
    function isFocusVisible(event) {
      var target = event.target;

      try {
        return target.matches(':focus-visible');
      } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
      // we use our own heuristic for those browsers
      // rethrow might be better if it's not the expected error but do we really
      // want to crash if focus-visible malfunctioned?
      // no need for validFocusTarget check. the user does that by attaching it to
      // focusable events only


      return hadKeyboardEvent || focusTriggersKeyboardModality(target);
    }
    /**
     * Should be called if a blur event is fired on a focus-visible element
     */

    function handleBlurVisible() {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
        hadFocusVisibleRecently = false;
        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      }, 100);
    }
    function useIsFocusVisible() {
      var ref = React__default.useCallback(function (instance) {
        var node = ReactDOM__default.findDOMNode(instance);

        if (node != null) {
          prepare(node.ownerDocument);
        }
      }, []);
      return {
        isFocusVisible: isFocusVisible,
        onBlurVisible: handleBlurVisible,
        ref: ref
      };
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }
    }

    var arrayWithoutHoles = _arrayWithoutHoles;

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    var iterableToArray = _iterableToArray;

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    var nonIterableSpread = _nonIterableSpread;

    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
    }

    var toConsumableArray = _toConsumableArray;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    var classCallCheck = _classCallCheck;

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    var createClass = _createClass;

    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    var assertThisInitialized = _assertThisInitialized$1;

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
        return call;
      }

      return assertThisInitialized(self);
    }

    var possibleConstructorReturn = _possibleConstructorReturn;

    var getPrototypeOf = createCommonjsModule(function (module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    module.exports = _getPrototypeOf;
    });

    var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf;
    });

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) setPrototypeOf(subClass, superClass);
    }

    var inherits = _inherits;

    /**
     * @ignore - internal component.
     */

    function Ripple(props) {
      var classes = props.classes,
          className = props.className,
          _props$pulsate = props.pulsate,
          pulsate = _props$pulsate === void 0 ? false : _props$pulsate,
          rippleX = props.rippleX,
          rippleY = props.rippleY,
          rippleSize = props.rippleSize,
          other = objectWithoutProperties(props, ["classes", "className", "pulsate", "rippleX", "rippleY", "rippleSize"]);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          visible = _React$useState2[0],
          setVisible = _React$useState2[1];

      var _React$useState3 = React__default.useState(false),
          _React$useState4 = slicedToArray(_React$useState3, 2),
          leaving = _React$useState4[0],
          setLeaving = _React$useState4[1];

      var handleEnter = function handleEnter() {
        setVisible(true);
      };

      var handleExit = function handleExit() {
        setLeaving(true);
      };

      var rippleClassName = clsx(classes.ripple, visible && classes.rippleVisible, pulsate && classes.ripplePulsate, className);
      var rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
      };
      var childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
      return React__default.createElement(Transition, _extends_1({
        onEnter: handleEnter,
        onExit: handleExit
      }, other), React__default.createElement("span", {
        className: rippleClassName,
        style: rippleStyles
      }, React__default.createElement("span", {
        className: childClassName
      })));
    }

    Ripple.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
       */
      pulsate: PropTypes__default.bool,

      /**
       * Diameter of the ripple.
       */
      rippleSize: PropTypes__default.number,

      /**
       * Horizontal position of the ripple center.
       */
      rippleX: PropTypes__default.number,

      /**
       * Vertical position of the ripple center.
       */
      rippleY: PropTypes__default.number
    };

    var DURATION = 550;
    var DELAY_RIPPLE = 80;
    var styles$e = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'block',
          position: 'absolute',
          overflow: 'hidden',
          borderRadius: 'inherit',
          width: '100%',
          height: '100%',
          left: 0,
          top: 0,
          pointerEvents: 'none',
          zIndex: 0
        },

        /* Styles applied to the internal `Ripple` components `ripple` class. */
        ripple: {
          opacity: 0,
          position: 'absolute'
        },

        /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
        rippleVisible: {
          opacity: 0.3,
          transform: 'scale(1)',
          animation: "mui-ripple-enter ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut),
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-ripple-enter'
        },

        /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
        ripplePulsate: {
          animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
        },

        /* Styles applied to the internal `Ripple` components `child` class. */
        child: {
          opacity: 1,
          display: 'block',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: 'currentColor'
        },

        /* Styles applied to the internal `Ripple` components `childLeaving` class. */
        childLeaving: {
          opacity: 0,
          animation: "mui-ripple-exit ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut),
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-ripple-exit'
        },

        /* Styles applied to the internal `Ripple` components `childPulsate` class. */
        childPulsate: {
          position: 'absolute',
          left: 0,
          top: 0,
          animation: "mui-ripple-pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite"),
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-ripple-pulsate'
        },
        '@keyframes mui-ripple-enter': {
          '0%': {
            transform: 'scale(0)',
            opacity: 0.1
          },
          '100%': {
            transform: 'scale(1)',
            opacity: 0.3
          }
        },
        '@keyframes mui-ripple-exit': {
          '0%': {
            opacity: 1
          },
          '100%': {
            opacity: 0
          }
        },
        '@keyframes mui-ripple-pulsate': {
          '0%': {
            transform: 'scale(1)'
          },
          '50%': {
            transform: 'scale(0.92)'
          },
          '100%': {
            transform: 'scale(1)'
          }
        }
      };
    };

    var TouchRipple =
    /*#__PURE__*/
    function (_React$PureComponent) {
      inherits(TouchRipple, _React$PureComponent);

      function TouchRipple() {
        var _getPrototypeOf2;

        var _this;

        classCallCheck(this, TouchRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf(TouchRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _this.state = {
          nextKey: 0,
          ripples: []
        };
        _this.container = React__default.createRef();

        _this.pulsate = function () {
          _this.start({}, {
            pulsate: true
          });
        };

        _this.start = function () {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var cb = arguments.length > 2 ? arguments[2] : undefined;
          var _options$pulsate = options.pulsate,
              pulsate = _options$pulsate === void 0 ? false : _options$pulsate,
              _options$center = options.center,
              center = _options$center === void 0 ? _this.props.center || options.pulsate : _options$center,
              _options$fakeElement = options.fakeElement,
              fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;

          if (event.type === 'mousedown' && _this.ignoringMouseDown) {
            _this.ignoringMouseDown = false;
            return;
          }

          if (event.type === 'touchstart') {
            _this.ignoringMouseDown = true;
          }

          var element = fakeElement ? null : _this.container.current;
          var rect = element ? element.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
          }; // Get the size of the ripple

          var rippleX;
          var rippleY;
          var rippleSize;

          if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
            rippleX = Math.round(rect.width / 2);
            rippleY = Math.round(rect.height / 2);
          } else {
            var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
            var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
            rippleX = Math.round(clientX - rect.left);
            rippleY = Math.round(clientY - rect.top);
          }

          if (center) {
            rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.

            if (rippleSize % 2 === 0) {
              rippleSize += 1;
            }
          } else {
            var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
            var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
            rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
          } // Touche devices


          if (event.touches) {
            // Prepare the ripple effect.
            _this.startTimerCommit = function () {
              _this.startCommit({
                pulsate: pulsate,
                rippleX: rippleX,
                rippleY: rippleY,
                rippleSize: rippleSize,
                cb: cb
              });
            }; // Delay the execution of the ripple effect.


            _this.startTimer = setTimeout(function () {
              if (_this.startTimerCommit) {
                _this.startTimerCommit();

                _this.startTimerCommit = null;
              }
            }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
          } else {
            _this.startCommit({
              pulsate: pulsate,
              rippleX: rippleX,
              rippleY: rippleY,
              rippleSize: rippleSize,
              cb: cb
            });
          }
        };

        _this.startCommit = function (params) {
          var pulsate = params.pulsate,
              rippleX = params.rippleX,
              rippleY = params.rippleY,
              rippleSize = params.rippleSize,
              cb = params.cb;

          _this.setState(function (state) {
            return {
              nextKey: state.nextKey + 1,
              ripples: [].concat(toConsumableArray(state.ripples), [React__default.createElement(Ripple, {
                key: state.nextKey,
                classes: _this.props.classes,
                timeout: {
                  exit: DURATION,
                  enter: DURATION
                },
                pulsate: pulsate,
                rippleX: rippleX,
                rippleY: rippleY,
                rippleSize: rippleSize
              })])
            };
          }, cb);
        };

        _this.stop = function (event, cb) {
          clearTimeout(_this.startTimer);
          var ripples = _this.state.ripples; // The touch interaction occurs too quickly.
          // We still want to show ripple effect.

          if (event.type === 'touchend' && _this.startTimerCommit) {
            event.persist();

            _this.startTimerCommit();

            _this.startTimerCommit = null;
            _this.startTimer = setTimeout(function () {
              _this.stop(event, cb);
            });
            return;
          }

          _this.startTimerCommit = null;

          if (ripples && ripples.length) {
            _this.setState({
              ripples: ripples.slice(1)
            }, cb);
          }
        };

        return _this;
      }

      createClass(TouchRipple, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          clearTimeout(this.startTimer);
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props,
              center = _this$props.center,
              classes = _this$props.classes,
              className = _this$props.className,
              other = objectWithoutProperties(_this$props, ["center", "classes", "className"]);

          return React__default.createElement("span", _extends_1({
            className: clsx(classes.root, className),
            ref: this.container
          }, other), React__default.createElement(TransitionGroup, {
            component: null,
            enter: true,
            exit: true
          }, this.state.ripples));
        }
      }]);

      return TouchRipple;
    }(React__default.PureComponent);

    TouchRipple.propTypes = {
      /**
       * If `true`, the ripple starts at the center of the component
       * rather than at the point of interaction.
       */
      center: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    TouchRipple.defaultProps = {
      center: false
    };
    var TouchRipple$1 = withStyles(styles$e, {
      flip: false,
      name: 'MuiTouchRipple'
    })(TouchRipple);

    var styles$f = {
      /* Styles applied to the root element. */
      root: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        // Remove grey highlight
        WebkitTapHighlightColor: 'transparent',
        backgroundColor: 'transparent',
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 'none',
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: 'pointer',
        userSelect: 'none',
        verticalAlign: 'middle',
        '-moz-appearance': 'none',
        // Reset
        '-webkit-appearance': 'none',
        // Reset
        textDecoration: 'none',
        // So we take precedent over the style of a native <a /> element.
        color: 'inherit',
        '&::-moz-focus-inner': {
          borderStyle: 'none' // Remove Firefox dotted outline.

        },
        '&$disabled': {
          pointerEvents: 'none',
          // Disable link interactions
          cursor: 'default'
        }
      },

      /* Styles applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if keyboard focused. */
      focusVisible: {}
    };
    var useEnhancedEffect$1 = typeof window !== 'undefined' ? React__default.useLayoutEffect : React__default.useEffect;
    /**
     * https://github.com/facebook/react/issues/14099#issuecomment-440013892
     *
     * @param {function} fn
     */

    function useEventCallback(fn) {
      var ref = React__default.useRef(fn);
      useEnhancedEffect$1(function () {
        ref.current = fn;
      });
      return React__default.useCallback(function (event) {
        return (0, ref.current)(event);
      }, []);
    }
    /**
     * `ButtonBase` contains as few styles as possible.
     * It aims to be a simple building block for creating a button.
     * It contains a load of style reset and some focus/ripple logic.
     */


    var ButtonBase = React__default.forwardRef(function ButtonBase(props, ref) {
      var action = props.action,
          buttonRefProp = props.buttonRef,
          _props$centerRipple = props.centerRipple,
          centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          component = _props$component === void 0 ? 'button' : _props$component,
          disabled = props.disabled,
          _props$disableRipple = props.disableRipple,
          disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,
          _props$disableTouchRi = props.disableTouchRipple,
          disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi,
          _props$focusRipple = props.focusRipple,
          focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple,
          focusVisibleClassName = props.focusVisibleClassName,
          onBlur = props.onBlur,
          onClick = props.onClick,
          onFocus = props.onFocus,
          onFocusVisible = props.onFocusVisible,
          onKeyDown = props.onKeyDown,
          onKeyUp = props.onKeyUp,
          onMouseDown = props.onMouseDown,
          onMouseLeave = props.onMouseLeave,
          onMouseUp = props.onMouseUp,
          onTouchEnd = props.onTouchEnd,
          onTouchMove = props.onTouchMove,
          onTouchStart = props.onTouchStart,
          _props$tabIndex = props.tabIndex,
          tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
          TouchRippleProps = props.TouchRippleProps,
          _props$type = props.type,
          type = _props$type === void 0 ? 'button' : _props$type,
          other = objectWithoutProperties(props, ["action", "buttonRef", "centerRipple", "children", "classes", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "type"]);

      var buttonRef = React__default.useRef(null);

      function getButtonNode() {
        // #StrictMode ready
        return ReactDOM__default.findDOMNode(buttonRef.current);
      }

      var rippleRef = React__default.useRef(null);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          focusVisible = _React$useState2[0],
          setFocusVisible = _React$useState2[1];

      if (disabled && focusVisible) {
        setFocusVisible(false);
      }

      var _useIsFocusVisible = useIsFocusVisible(),
          isFocusVisible = _useIsFocusVisible.isFocusVisible,
          onBlurVisible = _useIsFocusVisible.onBlurVisible,
          focusVisibleRef = _useIsFocusVisible.ref;

      React__default.useImperativeHandle(action, function () {
        return {
          focusVisible: function focusVisible() {
            setFocusVisible(true);
            buttonRef.current.focus();
          }
        };
      }, []);
      React__default.useEffect(function () {
        if (focusVisible && focusRipple && !disableRipple) {
          rippleRef.current.pulsate();
        }
      }, [disableRipple, focusRipple, focusVisible]);

      function useRippleHandler(rippleAction, eventCallback) {
        var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
        return useEventCallback(function (event) {
          if (eventCallback) {
            eventCallback(event);
          }

          var ignore = event.defaultPrevented || skipRippleAction;

          if (!ignore && rippleRef.current) {
            rippleRef.current[rippleAction](event);
          }

          return true;
        });
      }

      var handleMouseDown = useRippleHandler('start', onMouseDown);
      var handleMouseUp = useRippleHandler('stop', onMouseUp);
      var handleMouseLeave = useRippleHandler('stop', function (event) {
        if (focusVisible) {
          event.preventDefault();
        }

        if (onMouseLeave) {
          onMouseLeave(event);
        }
      });
      var handleTouchStart = useRippleHandler('start', onTouchStart);
      var handleTouchEnd = useRippleHandler('stop', onTouchEnd);
      var handleTouchMove = useRippleHandler('stop', onTouchMove);
      var handleBlur = useRippleHandler('stop', function (event) {
        if (focusVisible) {
          onBlurVisible(event);
          setFocusVisible(false);
        }

        if (onBlur) {
          onBlur(event);
        }
      }, false);
      var handleFocus = useEventCallback(function (event) {
        if (disabled) {
          return;
        } // Fix for https://github.com/facebook/react/issues/7769


        if (!buttonRef.current) {
          buttonRef.current = event.currentTarget;
        }

        if (isFocusVisible(event)) {
          setFocusVisible(true);

          if (onFocusVisible) {
            onFocusVisible(event);
          }
        }

        if (onFocus) {
          onFocus(event);
        }
      });
      var keydownRef = React__default.useRef(false);
      var handleKeyDown = useEventCallback(function (event) {
        // Check if key is already down to avoid repeats being counted as multiple activations
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
          keydownRef.current = true;
          event.persist();
          rippleRef.current.stop(event, function () {
            rippleRef.current.start(event);
          });
        }

        if (onKeyDown) {
          onKeyDown(event);
        }

        var button = getButtonNode(); // Keyboard accessibility for non interactive elements

        if (event.target === event.currentTarget && component && component !== 'button' && (event.key === ' ' || event.key === 'Enter') && !(button.tagName === 'A' && button.href)) {
          event.preventDefault();

          if (onClick) {
            onClick(event);
          }
        }
      });
      var handleKeyUp = useEventCallback(function (event) {
        if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible) {
          keydownRef.current = false;
          event.persist();
          rippleRef.current.stop(event, function () {
            rippleRef.current.pulsate(event);
          });
        }

        if (onKeyUp) {
          onKeyUp(event);
        }
      });
      var className = clsx(classes.root, classNameProp, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled);
      var ComponentProp = component;

      if (ComponentProp === 'button' && other.href) {
        ComponentProp = 'a';
      }

      var buttonProps = {};

      if (ComponentProp === 'button') {
        buttonProps.type = type;
        buttonProps.disabled = disabled;
      } else {
        buttonProps.role = 'button';
        buttonProps['aria-disabled'] = disabled;
      }

      var handleUserRef = useForkRef(buttonRefProp, ref);
      var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
      var handleRef = useForkRef(handleUserRef, handleOwnRef);
      return React__default.createElement(ComponentProp, _extends_1({
        className: className,
        onBlur: handleBlur,
        onClick: onClick,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex
      }, buttonProps, other), children, !disableRipple && !disabled ? React__default.createElement(NoSsr, null, React__default.createElement(TouchRipple$1, _extends_1({
        ref: rippleRef,
        center: centerRipple
      }, TouchRippleProps))) : null);
    });
    ButtonBase.propTypes = {
      /**
       * Callback fired when the component mounts.
       * This is useful when you want to trigger an action programmatically.
       * It currently only supports `focusVisible()` action.
       *
       * @param {object} actions This object contains all possible actions
       * that can be triggered programmatically.
       */
      action: PropTypes__default.func,

      /**
       * Use that property to pass a ref callback to the native button component.
       * @deprecated Use `ref` instead
       */
      buttonRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * If `true`, the ripples will be centered.
       * They won't start at the cursor interaction position.
       */
      centerRipple: PropTypes__default.bool,

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: elementTypeAcceptingRef$1,

      /**
       * If `true`, the base button will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       *
       *  Without a ripple there is no styling for :focus-visible by default. Be sure
       * to highlight the element by applying separate styles with the `focusVisibleClassName`.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * If `true`, the touch ripple effect will be disabled.
       */
      disableTouchRipple: PropTypes__default.bool,

      /**
       * If `true`, the base button will have a keyboard focus ripple.
       * `disableRipple` must also be `false`.
       */
      focusRipple: PropTypes__default.bool,

      /**
       * This property can help a person know which element has the keyboard focus.
       * The class name will be applied when the element gain the focus through a keyboard interaction.
       * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
       * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/master/explainer.md).
       * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
       * if needed.
       */
      focusVisibleClassName: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocus: PropTypes__default.func,

      /**
       * Callback fired when the component is focused with a keyboard.
       * We trigger a `onFocus` callback too.
       */
      onFocusVisible: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyDown: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyUp: PropTypes__default.func,

      /**
       * @ignore
       */
      onMouseDown: PropTypes__default.func,

      /**
       * @ignore
       */
      onMouseLeave: PropTypes__default.func,

      /**
       * @ignore
       */
      onMouseUp: PropTypes__default.func,

      /**
       * @ignore
       */
      onTouchEnd: PropTypes__default.func,

      /**
       * @ignore
       */
      onTouchMove: PropTypes__default.func,

      /**
       * @ignore
       */
      onTouchStart: PropTypes__default.func,

      /**
       * @ignore
       */
      role: PropTypes__default.string,

      /**
       * @ignore
       */
      tabIndex: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),

      /**
       * Properties applied to the `TouchRipple` element.
       */
      TouchRippleProps: PropTypes__default.object,

      /**
       * Used to control the button's purpose.
       * This property passes the value to the `type` attribute of the native button component.
       */
      type: PropTypes__default.oneOf(['submit', 'reset', 'button'])
    };
    var ButtonBase$1 = withStyles(styles$f, {
      name: 'MuiButtonBase'
    })(ButtonBase);

    function unsupportedProp(props, propName, componentName, location, propFullName) {

      var propFullNameSafe = propFullName || propName;

      if (typeof props[propName] !== 'undefined') {
        return new Error("The property `".concat(propFullNameSafe, "` is not supported. Please remove it."));
      }

      return null;
    }

    var styles$g = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          transition: theme.transitions.create(['color', 'padding-top'], {
            duration: theme.transitions.duration.short
          }),
          padding: '6px 12px 8px',
          minWidth: 80,
          maxWidth: 168,
          color: theme.palette.text.secondary,
          flex: '1',
          '&$iconOnly': {
            paddingTop: 16
          },
          '&$selected': {
            paddingTop: 6,
            color: theme.palette.primary.main
          }
        },

        /* Styles applied to the root element if selected. */
        selected: {},

        /* Styles applied to the root element if `showLabel={false}` and not selected. */
        iconOnly: {},

        /* Styles applied to the span element that wraps the icon and label. */
        wrapper: {
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100%',
          flexDirection: 'column'
        },

        /* Styles applied to the label's span element. */
        label: {
          fontFamily: theme.typography.fontFamily,
          fontSize: theme.typography.pxToRem(12),
          opacity: 1,
          transition: 'font-size 0.2s, opacity 0.2s',
          transitionDelay: '0.1s',
          '&$iconOnly': {
            opacity: 0,
            transitionDelay: '0s'
          },
          '&$selected': {
            fontSize: theme.typography.pxToRem(14)
          }
        }
      };
    };
    var BottomNavigationAction = React__default.forwardRef(function BottomNavigationAction(props, ref) {
      var classes = props.classes,
          className = props.className,
          icon = props.icon,
          label = props.label,
          onChange = props.onChange,
          onClick = props.onClick,
          selected = props.selected,
          showLabel = props.showLabel,
          value = props.value,
          other = objectWithoutProperties(props, ["classes", "className", "icon", "label", "onChange", "onClick", "selected", "showLabel", "value"]);

      var handleChange = function handleChange(event) {
        if (onChange) {
          onChange(event, value);
        }

        if (onClick) {
          onClick(event);
        }
      };

      return React__default.createElement(ButtonBase$1, _extends_1({
        ref: ref,
        className: clsx(classes.root, selected && classes.selected, !showLabel && !selected && classes.iconOnly, className),
        focusRipple: true,
        onClick: handleChange
      }, other), React__default.createElement("span", {
        className: classes.wrapper
      }, icon, React__default.createElement("span", {
        className: clsx(classes.label, selected && classes.selected, !showLabel && !selected && classes.iconOnly)
      }, label)));
    });
    BottomNavigationAction.propTypes = {
      /**
       * This property isn't supported.
       * Use the `component` property if you need to change the children structure.
       */
      children: unsupportedProp,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The icon element.
       */
      icon: PropTypes__default.node,

      /**
       * The label element.
       */
      label: PropTypes__default.node,

      /**
       * @ignore
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * @ignore
       */
      selected: PropTypes__default.bool,

      /**
       * If `true`, the `BottomNavigationAction` will show its label.
       * By default, only the selected `BottomNavigationAction`
       * inside `BottomNavigation` will show its label.
       */
      showLabel: PropTypes__default.bool,

      /**
       * You can provide your own value. Otherwise, we fallback to the child position index.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$g, {
      name: 'MuiBottomNavigationAction'
    })(BottomNavigationAction);

    var responsivePropType = PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string, PropTypes__default.object]);

    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var warning$1 = function() {};

    {
      var printWarning$1 = function printWarning(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = 'Warning: ' +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      warning$1 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === undefined) {
          throw new Error(
              '`warning(condition, format, ...args)` requires a warning ' +
              'message argument'
          );
        }
        if (!condition) {
          printWarning$1.apply(null, [format].concat(args));
        }
      };
    }

    var warning_1$1 = warning$1;

    function merge(acc, item) {
      if (!item) {
        return acc;
      }

      return umd(acc, item, {
        clone: false // No need to clone deep, it's way faster.

      });
    }

    // For instance with the first breakpoint xs: [xs, sm[.

    var values$1 = {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920
    };
    var defaultBreakpoints = {
      // Sorted ASC by size. That's important.
      // It can't be configured as it's used statically for propTypes.
      keys: ['xs', 'sm', 'md', 'lg', 'xl'],
      up: function up(key) {
        return "@media (min-width:".concat(values$1[key], "px)");
      }
    };
    function handleBreakpoints(props, propValue, styleFromPropValue) {
      warning_1$1(props.theme, '@material-ui/system: you are calling a style function without a theme value.');

      if (Array.isArray(propValue)) {
        var themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;
        return propValue.reduce(function (acc, item, index) {
          acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
          return acc;
        }, {});
      }

      if (_typeof_1(propValue) === 'object') {
        var _themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;

        return Object.keys(propValue).reduce(function (acc, breakpoint) {
          acc[_themeBreakpoints.up(breakpoint)] = styleFromPropValue(propValue[breakpoint]);
          return acc;
        }, {});
      }

      var output = styleFromPropValue(propValue);
      return output;
    }

    function getPath(obj, path) {
      if (!path || typeof path !== 'string') {
        return null;
      }

      return path.split('.').reduce(function (acc, item) {
        return acc && acc[item] ? acc[item] : null;
      }, obj);
    }

    function style(options) {
      var prop = options.prop,
          _options$cssProperty = options.cssProperty,
          cssProperty = _options$cssProperty === void 0 ? options.prop : _options$cssProperty,
          themeKey = options.themeKey,
          transform = options.transform;

      var fn = function fn(props) {
        if (props[prop] == null) {
          return null;
        }

        var propValue = props[prop];
        var theme = props.theme;
        var themeMapping = getPath(theme, themeKey) || {};

        var styleFromPropValue = function styleFromPropValue(propValueFinal) {
          var value;

          if (typeof themeMapping === 'function') {
            value = themeMapping(propValueFinal);
          } else if (Array.isArray(themeMapping)) {
            value = themeMapping[propValueFinal];
          } else {
            value = getPath(themeMapping, propValueFinal) || propValueFinal;

            if (transform) {
              value = transform(value);
            }
          }

          if (cssProperty === false) {
            return value;
          }

          return defineProperty({}, cssProperty, value);
        };

        return handleBreakpoints(props, propValue, styleFromPropValue);
      };

      fn.propTypes = defineProperty({}, prop, responsivePropType);
      fn.filterProps = [prop];
      return fn;
    }

    function compose() {
      for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
        styles[_key] = arguments[_key];
      }

      var fn = function fn(props) {
        return styles.reduce(function (acc, style) {
          var output = style(props);

          if (output) {
            return merge(acc, output);
          }

          return acc;
        }, {});
      }; // Alternative approach that doesn't yield any performance gain.
      // const handlers = styles.reduce((acc, style) => {
      //   style.filterProps.forEach(prop => {
      //     acc[prop] = style;
      //   });
      //   return acc;
      // }, {});
      // const fn = props => {
      //   return Object.keys(props).reduce((acc, prop) => {
      //     if (handlers[prop]) {
      //       return merge(acc, handlers[prop](props));
      //     }
      //     return acc;
      //   }, {});
      // };


      fn.propTypes = styles.reduce(function (acc, style) {
        return Object.assign(acc, style.propTypes);
      }, {});
      fn.filterProps = styles.reduce(function (acc, style) {
        return acc.concat(style.filterProps);
      }, []);
      return fn;
    }

    function getBorder(value) {
      if (typeof value !== 'number') {
        return value;
      }

      return "".concat(value, "px solid").concat(value === 0 ? ' !important' : '');
    }

    var border = style({
      prop: 'border',
      themeKey: 'borders',
      transform: getBorder
    });
    var borderTop = style({
      prop: 'borderTop',
      themeKey: 'borders',
      transform: getBorder
    });
    var borderRight = style({
      prop: 'borderRight',
      themeKey: 'borders',
      transform: getBorder
    });
    var borderBottom = style({
      prop: 'borderBottom',
      themeKey: 'borders',
      transform: getBorder
    });
    var borderLeft = style({
      prop: 'borderLeft',
      themeKey: 'borders',
      transform: getBorder
    });
    var borderColor = style({
      prop: 'borderColor',
      themeKey: 'palette',
      transform: function transform(value) {
        return "".concat(value, " !important");
      }
    });
    var borderRadius = style({
      prop: 'borderRadius',
      themeKey: 'shape'
    });
    var borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderRadius);

    function omit(input, fields) {
      var output = {};
      Object.keys(input).forEach(function (prop) {
        if (fields.indexOf(prop) === -1) {
          output[prop] = input[prop];
        }
      });
      return output;
    }

    function css(styleFunction) {
      var newStyleFunction = function newStyleFunction(props) {
        var output = styleFunction(props);

        if (props.css) {
          return _extends_1({}, merge(output, styleFunction(_extends_1({
            theme: props.theme
          }, props.css))), omit(props.css, [styleFunction.filterProps]));
        }

        return output;
      };

      newStyleFunction.propTypes = _extends_1({}, styleFunction.propTypes, {
        css: PropTypes__default.object
      });
      newStyleFunction.filterProps = ['css'].concat(toConsumableArray(styleFunction.filterProps));
      return newStyleFunction;
    }

    var displayRaw = style({
      prop: 'display'
    });
    var displayPrint = style({
      prop: 'displayPrint',
      cssProperty: false,
      transform: function transform(value) {
        return {
          '@media print': {
            display: value
          }
        };
      }
    });
    var display = compose(displayRaw, displayPrint);

    var flexDirection = style({
      prop: 'flexDirection'
    });
    var flexWrap = style({
      prop: 'flexWrap'
    });
    var justifyContent = style({
      prop: 'justifyContent'
    });
    var alignItems = style({
      prop: 'alignItems'
    });
    var alignContent = style({
      prop: 'alignContent'
    });
    var order = style({
      prop: 'order'
    });
    var flex = style({
      prop: 'flex'
    });
    var flexGrow = style({
      prop: 'flexGrow'
    });
    var flexShrink = style({
      prop: 'flexShrink'
    });
    var alignSelf = style({
      prop: 'alignSelf'
    });
    var flexbox = compose(flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf);

    var color = style({
      prop: 'color',
      themeKey: 'palette'
    });
    var bgcolor = style({
      prop: 'bgcolor',
      cssProperty: 'backgroundColor',
      themeKey: 'palette'
    });
    var palette = compose(color, bgcolor);

    var position = style({
      prop: 'position'
    });
    var zIndex$1 = style({
      prop: 'zIndex',
      themeKey: 'zIndex'
    });
    var top = style({
      prop: 'top'
    });
    var right = style({
      prop: 'right'
    });
    var bottom = style({
      prop: 'bottom'
    });
    var left = style({
      prop: 'left'
    });
    var positions$1 = compose(position, zIndex$1, top, right, bottom, left);

    var boxShadow = style({
      prop: 'boxShadow',
      themeKey: 'shadows'
    });

    function transform(value) {
      return value <= 1 ? "".concat(value * 100, "%") : value;
    }

    var width = style({
      prop: 'width',
      transform: transform
    });
    var maxWidth = style({
      prop: 'maxWidth',
      transform: transform
    });
    var minWidth = style({
      prop: 'minWidth',
      transform: transform
    });
    var height = style({
      prop: 'height',
      transform: transform
    });
    var maxHeight = style({
      prop: 'maxHeight',
      transform: transform
    });
    var minHeight = style({
      prop: 'minHeight',
      transform: transform
    });
    var sizeWidth = style({
      prop: 'size',
      cssProperty: 'width',
      transform: transform
    });
    var sizeHeight = style({
      prop: 'size',
      cssProperty: 'height',
      transform: transform
    });
    var sizing = compose(width, maxWidth, minWidth, height, maxHeight, minHeight);

    function memoize(fn) {
      var cache = {};
      return function (arg) {
        if (cache[arg] === undefined) {
          cache[arg] = fn(arg);
        }

        return cache[arg];
      };
    }

    var properties = {
      m: 'margin',
      p: 'padding'
    };
    var directions = {
      t: 'Top',
      r: 'Right',
      b: 'Bottom',
      l: 'Left',
      x: ['Left', 'Right'],
      y: ['Top', 'Bottom']
    }; // memoize() impact:
    // From 300,000 ops/sec
    // To 350,000 ops/sec

    var getCssProperties = memoize(function (prop) {
      // It's not a shorthand notation.
      if (prop.length > 3) {
        return [prop];
      }

      var _prop$split = prop.split(''),
          _prop$split2 = slicedToArray(_prop$split, 2),
          a = _prop$split2[0],
          b = _prop$split2[1];

      var property = properties[a];
      var direction = directions[b] || '';
      return Array.isArray(direction) ? direction.map(function (dir) {
        return property + dir;
      }) : [property + direction];
    });
    var spacingKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'];

    function getTransformer(theme) {
      var themeSpacing = theme.spacing || 8;

      if (typeof themeSpacing === 'number') {
        return function (abs) {
          return themeSpacing * abs;
        };
      }

      if (Array.isArray(themeSpacing)) {
        return function (abs) {
          warning_1$1(abs <= themeSpacing.length - 1, ["@material-ui/system: the value provided (".concat(abs, ") overflows."), "The supported values are: ".concat(JSON.stringify(themeSpacing), "."), "".concat(abs, " > ").concat(themeSpacing.length - 1, ", you need to add the missing values.")].join('\n'));
          return themeSpacing[abs];
        };
      }

      if (typeof themeSpacing === 'function') {
        return themeSpacing;
      }

      warning_1$1(false, ["@material-ui/system: the `theme.spacing` value (".concat(themeSpacing, ") is invalid."), 'It should be a number, an array or a function.'].join('\n'));
      return function () {
        return undefined;
      };
    }

    function getValue(transformer, propValue) {
      if (typeof propValue === 'string') {
        return propValue;
      }

      var abs = Math.abs(propValue);
      var transformed = transformer(abs);

      if (propValue >= 0) {
        return transformed;
      }

      if (typeof transformed === 'number') {
        return -transformed;
      }

      return "-".concat(transformed);
    }

    function getStyleFromPropValue(cssProperties, transformer) {
      return function (propValue) {
        return cssProperties.reduce(function (acc, cssProperty) {
          acc[cssProperty] = getValue(transformer, propValue);
          return acc;
        }, {});
      };
    }

    function spacing(props) {
      var theme = props.theme;
      var transformer = getTransformer(theme);
      return Object.keys(props).map(function (prop) {
        // Using a hash computation over an array iteration could be faster, but with only 14 items,
        // it's doesn't worth the bundle size.
        if (spacingKeys.indexOf(prop) === -1) {
          return null;
        }

        var cssProperties = getCssProperties(prop);
        var styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
        var propValue = props[prop];
        return handleBreakpoints(props, propValue, styleFromPropValue);
      }).reduce(merge, {});
    }

    spacing.propTypes = spacingKeys.reduce(function (obj, key) {
      obj[key] = responsivePropType;
      return obj;
    }, {});
    spacing.filterProps = spacingKeys;

    var fontFamily = style({
      prop: 'fontFamily',
      themeKey: 'typography'
    });
    var fontSize = style({
      prop: 'fontSize',
      themeKey: 'typography'
    });
    var fontWeight = style({
      prop: 'fontWeight',
      themeKey: 'typography'
    });
    var textAlign = style({
      prop: 'textAlign'
    });
    var typography = compose(fontFamily, fontSize, fontWeight, textAlign);

    /** @license Material-UI v4.0.1
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var styleFunction = css(compose(borders, display, flexbox, positions$1, palette, boxShadow, sizing, spacing, typography));
    /**
     * @ignore - do not document.
     */

    var Box = styled('div')(styleFunction, {
      name: 'MuiBox'
    });

    var styles$h = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          margin: 0
        },

        /* Styles applied to the root element if `variant="body2"`. */
        body2: theme.typography.body2,

        /* Styles applied to the root element if `variant="body1"`. */
        body1: theme.typography.body1,

        /* Styles applied to the root element if `variant="caption"`. */
        caption: theme.typography.caption,

        /* Styles applied to the root element if `variant="button"`. */
        button: theme.typography.button,

        /* Styles applied to the root element if `variant="h1"`. */
        h1: theme.typography.h1,

        /* Styles applied to the root element if `variant="h2"`. */
        h2: theme.typography.h2,

        /* Styles applied to the root element if `variant="h3"`. */
        h3: theme.typography.h3,

        /* Styles applied to the root element if `variant="h4"`. */
        h4: theme.typography.h4,

        /* Styles applied to the root element if `variant="h5"`. */
        h5: theme.typography.h5,

        /* Styles applied to the root element if `variant="h6"`. */
        h6: theme.typography.h6,

        /* Styles applied to the root element if `variant="subtitle1"`. */
        subtitle1: theme.typography.subtitle1,

        /* Styles applied to the root element if `variant="subtitle2"`. */
        subtitle2: theme.typography.subtitle2,

        /* Styles applied to the root element if `variant="overline"`. */
        overline: theme.typography.overline,

        /* Styles applied to the root element if `variant="srOnly"`. Only accessible to screen readers. */
        srOnly: {
          position: 'absolute',
          height: 1,
          width: 1,
          overflow: 'hidden'
        },

        /* Styles applied to the root element if `align="left"`. */
        alignLeft: {
          textAlign: 'left'
        },

        /* Styles applied to the root element if `align="center"`. */
        alignCenter: {
          textAlign: 'center'
        },

        /* Styles applied to the root element if `align="right"`. */
        alignRight: {
          textAlign: 'right'
        },

        /* Styles applied to the root element if `align="justify"`. */
        alignJustify: {
          textAlign: 'justify'
        },

        /* Styles applied to the root element if `align="nowrap"`. */
        noWrap: {
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap'
        },

        /* Styles applied to the root element if `gutterBottom={true}`. */
        gutterBottom: {
          marginBottom: '0.35em'
        },

        /* Styles applied to the root element if `paragraph={true}`. */
        paragraph: {
          marginBottom: 16
        },

        /* Styles applied to the root element if `color="inherit"`. */
        colorInherit: {
          color: 'inherit'
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          color: theme.palette.secondary.main
        },

        /* Styles applied to the root element if `color="textPrimary"`. */
        colorTextPrimary: {
          color: theme.palette.text.primary
        },

        /* Styles applied to the root element if `color="textSecondary"`. */
        colorTextSecondary: {
          color: theme.palette.text.secondary
        },

        /* Styles applied to the root element if `color="error"`. */
        colorError: {
          color: theme.palette.error.main
        },

        /* Styles applied to the root element if `display="inline"`. */
        displayInline: {
          display: 'inline'
        },

        /* Styles applied to the root element if `display="block"`. */
        displayBlock: {
          display: 'block'
        }
      };
    };
    var defaultVariantMapping = {
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      subtitle1: 'h6',
      subtitle2: 'h6',
      body1: 'p',
      body2: 'p'
    };
    var Typography = React__default.forwardRef(function Typography(props, ref) {
      var _props$align = props.align,
          align = _props$align === void 0 ? 'inherit' : _props$align,
          classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'initial' : _props$color,
          component = props.component,
          _props$display = props.display,
          display = _props$display === void 0 ? 'initial' : _props$display,
          _props$gutterBottom = props.gutterBottom,
          gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom,
          _props$noWrap = props.noWrap,
          noWrap = _props$noWrap === void 0 ? false : _props$noWrap,
          _props$paragraph = props.paragraph,
          paragraph = _props$paragraph === void 0 ? false : _props$paragraph,
          theme = props.theme,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'body1' : _props$variant,
          _props$variantMapping = props.variantMapping,
          variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping,
          other = objectWithoutProperties(props, ["align", "classes", "className", "color", "component", "display", "gutterBottom", "noWrap", "paragraph", "theme", "variant", "variantMapping"]);

      var Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, variant !== 'inherit' && classes[variant], color !== 'initial' && classes["color".concat(capitalize(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== 'inherit' && classes["align".concat(capitalize(align))], display !== 'initial' && classes["display".concat(capitalize(display))], className),
        ref: ref
      }, other));
    });
    Typography.propTypes = {
      /**
       * Set the text-align on the component.
       */
      align: PropTypes__default.oneOf(['inherit', 'left', 'center', 'right', 'justify']),

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['initial', 'inherit', 'primary', 'secondary', 'textPrimary', 'textSecondary', 'error']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       * By default, it maps the variant to a good default headline component.
       */
      component: PropTypes__default.elementType,

      /**
       * Controls the display type
       */
      display: PropTypes__default.oneOf(['initial', 'block', 'inline']),

      /**
       * If `true`, the text will have a bottom margin.
       */
      gutterBottom: PropTypes__default.bool,

      /**
       * If `true`, the text will not wrap, but instead will truncate with an ellipsis.
       */
      noWrap: PropTypes__default.bool,

      /**
       * If `true`, the text will have a bottom margin.
       */
      paragraph: PropTypes__default.bool,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * Applies the theme typography styles.
       */
      variant: PropTypes__default.oneOf(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline', 'srOnly', 'inherit']),

      /**
       * We are empirically mapping the variant property to a range of different DOM element types.
       * For instance, subtitle1 to `<h6>`.
       * If you wish to change that mapping, you can provide your own.
       * Alternatively, you can use the `component` property.
       */
      variantMapping: PropTypes__default.object
    };
    var Typography$1 = withStyles(styles$h, {
      name: 'MuiTypography',
      withTheme: true
    })(Typography);

    var styles$i = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          userSelect: 'none',
          width: '1em',
          height: '1em',
          display: 'inline-block',
          fill: 'currentColor',
          flexShrink: 0,
          fontSize: theme.typography.pxToRem(24),
          transition: theme.transitions.create('fill', {
            duration: theme.transitions.duration.shorter
          })
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          color: theme.palette.secondary.main
        },

        /* Styles applied to the root element if `color="action"`. */
        colorAction: {
          color: theme.palette.action.active
        },

        /* Styles applied to the root element if `color="error"`. */
        colorError: {
          color: theme.palette.error.main
        },

        /* Styles applied to the root element if `color="disabled"`. */
        colorDisabled: {
          color: theme.palette.action.disabled
        },

        /* Styles applied to the root element if `fontSize="inherit"`. */
        fontSizeInherit: {
          fontSize: 'inherit'
        },

        /* Styles applied to the root element if `fontSize="small"`. */
        fontSizeSmall: {
          fontSize: theme.typography.pxToRem(20)
        },

        /* Styles applied to the root element if `fontSize="large"`. */
        fontSizeLarge: {
          fontSize: theme.typography.pxToRem(35)
        }
      };
    };
    var SvgIcon = React__default.forwardRef(function SvgIcon(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'inherit' : _props$color,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'svg' : _props$component,
          _props$fontSize = props.fontSize,
          fontSize = _props$fontSize === void 0 ? 'default' : _props$fontSize,
          htmlColor = props.htmlColor,
          titleAccess = props.titleAccess,
          _props$viewBox = props.viewBox,
          viewBox = _props$viewBox === void 0 ? '0 0 24 24' : _props$viewBox,
          other = objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "fontSize", "htmlColor", "titleAccess", "viewBox"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, color !== 'inherit' && classes["color".concat(capitalize(color))], fontSize !== 'default' && classes["fontSize".concat(capitalize(fontSize))], className),
        focusable: "false",
        viewBox: viewBox,
        color: htmlColor,
        "aria-hidden": titleAccess ? 'false' : 'true',
        role: titleAccess ? 'img' : 'presentation',
        ref: ref
      }, other), children, titleAccess ? React__default.createElement("title", null, titleAccess) : null);
    });
    SvgIcon.propTypes = {
      /**
       * Node passed into the SVG element.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       * You can use the `htmlColor` property to apply a color attribute to the SVG element.
       */
      color: PropTypes__default.oneOf(['inherit', 'primary', 'secondary', 'action', 'error', 'disabled']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
       */
      fontSize: PropTypes__default.oneOf(['inherit', 'default', 'small', 'large']),

      /**
       * Applies a color attribute to the SVG element.
       */
      htmlColor: PropTypes__default.string,

      /**
       * The shape-rendering attribute. The behavior of the different options is described on the
       * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
       * If you are having issues with blurry icons you should investigate this property.
       */
      shapeRendering: PropTypes__default.string,

      /**
       * Provides a human-readable title for the element that contains it.
       * https://www.w3.org/TR/SVG-access/#Equivalent
       */
      titleAccess: PropTypes__default.string,

      /**
       * Allows you to redefine what the coordinates without units mean inside an SVG element.
       * For example, if the SVG element is 500 (width) by 200 (height),
       * and you pass viewBox="0 0 50 20",
       * this means that the coordinates inside the SVG will go from the top left corner (0,0)
       * to bottom right (50,20) and each unit will be worth 10px.
       */
      viewBox: PropTypes__default.string
    };
    SvgIcon.muiName = 'SvgIcon';
    var SvgIcon$1 = withStyles(styles$i, {
      name: 'MuiSvgIcon'
    })(SvgIcon);

    function createSvgIcon(path, displayName) {
      var Component = React__default.memo(React__default.forwardRef(function (props, ref) {
        return React__default.createElement(SvgIcon$1, _extends_1({}, props, {
          ref: ref
        }), path);
      }));

      {
        Component.displayName = "".concat(displayName, "Icon");
      }

      Component.muiName = SvgIcon$1.muiName;
      return Component;
    }

    /**
     * @ignore - internal component.
     */

    var MoreHorizIcon = createSvgIcon(React__default.createElement("path", {
      d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
    }), 'MoreHoriz');

    var styles$j = function styles(theme) {
      return {
        root: {
          display: 'flex'
        },
        icon: {
          width: 24,
          height: 16,
          backgroundColor: theme.palette.grey[100],
          color: theme.palette.grey[700],
          borderRadius: 2,
          marginLeft: theme.spacing(0.5),
          marginRight: theme.spacing(0.5),
          cursor: 'pointer',
          '&:hover, &:focus': {
            backgroundColor: theme.palette.grey[200]
          },
          '&:active': {
            boxShadow: theme.shadows[0],
            backgroundColor: emphasize(theme.palette.grey[200], 0.12)
          }
        }
      };
    };
    /**
     * @ignore - internal component.
     */


    function BreadcrumbCollapsed(props) {
      var classes = props.classes,
          other = objectWithoutProperties(props, ["classes"]);

      return React__default.createElement("li", _extends_1({
        className: classes.root
      }, other), React__default.createElement(MoreHorizIcon, {
        className: classes.icon
      }));
    }

    BreadcrumbCollapsed.propTypes = {
      /**
       * @ignore
       */
      classes: PropTypes__default.object.isRequired
    };
    var BreadcrumbCollapsed$1 = withStyles(styles$j, {
      name: 'PrivateBreadcrumbCollapsed'
    })(BreadcrumbCollapsed);

    var styles$k = {
      root: {
        display: 'flex',
        userSelect: 'none',
        marginLeft: 8,
        marginRight: 8
      }
    };
    /**
     * @ignore - internal component.
     */

    function BreadcrumbSeparator(props) {
      var classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["classes", "className"]);

      return React__default.createElement("li", _extends_1({
        "aria-hidden": true,
        className: clsx(classes.root, className)
      }, other));
    }

    BreadcrumbSeparator.propTypes = {
      children: PropTypes__default.node.isRequired,
      classes: PropTypes__default.object.isRequired,
      className: PropTypes__default.string
    };
    var BreadcrumbSeparator$1 = withStyles(styles$k, {
      name: 'PrivateBreadcrumbSeparator'
    })(BreadcrumbSeparator);

    var styles$l = {
      /* Styles applied to the root element. */
      root: {},

      /* Styles applied to the ol element. */
      ol: {
        display: 'flex',
        flexWrap: 'wrap',
        alignItems: 'center',
        padding: 0,
        // Reset
        margin: 0 // Reset

      },

      /* Styles applied to the li element. */
      li: {
        listStyle: 'none'
      },

      /* Styles applied to the separator element. */
      separator: {}
    };

    function insertSeparators(items, className, separator) {
      return items.reduce(function (acc, current, index) {
        if (index < items.length - 1) {
          acc = acc.concat(current, React__default.createElement(BreadcrumbSeparator$1 // eslint-disable-next-line react/no-array-index-key
          , {
            key: "separator-".concat(index),
            className: className
          }, separator));
        } else {
          acc.push(current);
        }

        return acc;
      }, []);
    }

    var Breadcrumbs = React__default.forwardRef(function Breadcrumbs(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'nav' : _props$component,
          _props$itemsAfterColl = props.itemsAfterCollapse,
          itemsAfterCollapse = _props$itemsAfterColl === void 0 ? 1 : _props$itemsAfterColl,
          _props$itemsBeforeCol = props.itemsBeforeCollapse,
          itemsBeforeCollapse = _props$itemsBeforeCol === void 0 ? 1 : _props$itemsBeforeCol,
          _props$maxItems = props.maxItems,
          maxItems = _props$maxItems === void 0 ? 8 : _props$maxItems,
          _props$separator = props.separator,
          separator = _props$separator === void 0 ? '/' : _props$separator,
          other = objectWithoutProperties(props, ["children", "classes", "className", "component", "itemsAfterCollapse", "itemsBeforeCollapse", "maxItems", "separator"]);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          expanded = _React$useState2[0],
          setExpanded = _React$useState2[1];

      var renderItemsBeforeAndAfter = function renderItemsBeforeAndAfter(allItems) {
        var handleClickExpand = function handleClickExpand() {
          setExpanded(true);
        }; // This defends against someone passing weird input, to ensure that if all
        // items would be shown anyway, we just show all items without the EllipsisItem


        if (itemsBeforeCollapse + itemsAfterCollapse >= allItems.length) {
          warning_1(false, ['Material-UI: you have provided an invalid combination of properties to the Breadcrumbs.', "itemsAfterCollapse={".concat(itemsAfterCollapse, "} +itemsBeforeCollapse={").concat(itemsBeforeCollapse, "} >= maxItems={").concat(maxItems, "}")].join('\n'));
          return allItems;
        }

        return [].concat(toConsumableArray(allItems.slice(0, itemsBeforeCollapse)), [React__default.createElement(BreadcrumbCollapsed$1, {
          key: "ellipsis",
          onClick: handleClickExpand
        })], toConsumableArray(allItems.slice(allItems.length - itemsAfterCollapse, allItems.length)));
      };

      var allItems = React__default.Children.toArray(children).filter(function (child) {
        return React__default.isValidElement(child);
      }).map(function (child, index) {
        return (// eslint-disable-next-line react/no-array-index-key
          React__default.createElement("li", {
            className: classes.li,
            key: "child-".concat(index)
          }, child)
        );
      });
      return React__default.createElement(Typography$1, _extends_1({
        ref: ref,
        component: Component,
        color: "textSecondary",
        className: clsx(classes.root, className)
      }, other), React__default.createElement("ol", {
        className: classes.ol
      }, insertSeparators(expanded || maxItems && allItems.length <= maxItems ? allItems : renderItemsBeforeAndAfter(allItems), classes.separator, separator)));
    });
    Breadcrumbs.propTypes = {
      /**
       * The breadcrumb children.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       * By default, it maps the variant to a good default headline component.
       */
      component: PropTypes__default.elementType,

      /**
       * If max items is exceeded, the number of items to show after the ellipsis.
       */
      itemsAfterCollapse: PropTypes__default.number,

      /**
       * If max items is exceeded, the number of items to show before the ellipsis.
       */
      itemsBeforeCollapse: PropTypes__default.number,

      /**
       * Specifies the maximum number of breadcrumbs to display. When there are more
       * than the maximum number, only the first and last will be shown, with an
       * ellipsis in between.
       */
      maxItems: PropTypes__default.number,

      /**
       * Custom separator node.
       */
      separator: PropTypes__default.node
    };
    withStyles(styles$l, {
      name: 'MuiBreadcrumbs'
    })(Breadcrumbs);

    var styles$m = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({
          lineHeight: 1.75
        }, theme.typography.button, {
          boxSizing: 'border-box',
          minWidth: 64,
          padding: '6px 16px',
          borderRadius: theme.shape.borderRadius,
          color: theme.palette.text.primary,
          transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {
            duration: theme.transitions.duration.short
          }),
          '&:hover': {
            textDecoration: 'none',
            backgroundColor: fade(theme.palette.text.primary, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            },
            '&$disabled': {
              backgroundColor: 'transparent'
            }
          },
          '&$disabled': {
            color: theme.palette.action.disabled
          }
        }),

        /* Styles applied to the span element that wraps the children. */
        label: {
          width: '100%',
          // Ensure the correct width for iOS Safari
          display: 'inherit',
          alignItems: 'inherit',
          justifyContent: 'inherit'
        },

        /* Styles applied to the root element if `variant="text"`. */
        text: {
          padding: '6px 8px'
        },

        /* Styles applied to the root element if `variant="text"` and `color="primary"`. */
        textPrimary: {
          color: theme.palette.primary.main,
          '&:hover': {
            backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the root element if `variant="text"` and `color="secondary"`. */
        textSecondary: {
          color: theme.palette.secondary.main,
          '&:hover': {
            backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the root element if `variant="outlined"`. */
        outlined: {
          padding: '5px 16px',
          border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
          '&$disabled': {
            border: "1px solid ".concat(theme.palette.action.disabled)
          }
        },

        /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
        outlinedPrimary: {
          color: theme.palette.primary.main,
          border: "1px solid ".concat(fade(theme.palette.primary.main, 0.5)),
          '&:hover': {
            border: "1px solid ".concat(theme.palette.primary.main),
            backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
        outlinedSecondary: {
          color: theme.palette.secondary.main,
          border: "1px solid ".concat(fade(theme.palette.secondary.main, 0.5)),
          '&:hover': {
            border: "1px solid ".concat(theme.palette.secondary.main),
            backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          },
          '&$disabled': {
            border: "1px solid ".concat(theme.palette.action.disabled)
          }
        },

        /* Styles applied to the root element if `variant="contained"`. */
        contained: {
          color: theme.palette.getContrastText(theme.palette.grey[300]),
          backgroundColor: theme.palette.grey[300],
          boxShadow: theme.shadows[2],
          '&$focusVisible': {
            boxShadow: theme.shadows[6]
          },
          '&:active': {
            boxShadow: theme.shadows[8]
          },
          '&$disabled': {
            color: theme.palette.action.disabled,
            boxShadow: theme.shadows[0],
            backgroundColor: theme.palette.action.disabledBackground
          },
          '&:hover': {
            backgroundColor: theme.palette.grey.A100,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.grey[300]
            },
            '&$disabled': {
              backgroundColor: theme.palette.action.disabledBackground
            }
          }
        },

        /* Styles applied to the root element if `variant="contained"` and `color="primary"`. */
        containedPrimary: {
          color: theme.palette.primary.contrastText,
          backgroundColor: theme.palette.primary.main,
          '&:hover': {
            backgroundColor: theme.palette.primary.dark,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.primary.main
            }
          }
        },

        /* Styles applied to the root element if `variant="contained"` and `color="secondary"`. */
        containedSecondary: {
          color: theme.palette.secondary.contrastText,
          backgroundColor: theme.palette.secondary.main,
          '&:hover': {
            backgroundColor: theme.palette.secondary.dark,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.secondary.main
            }
          }
        },

        /* Styles applied to the ButtonBase root element if the button is keyboard focused. */
        focusVisible: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `color="inherit"`. */
        colorInherit: {
          color: 'inherit',
          borderColor: 'currentColor'
        },

        /* Styles applied to the root element if `size="small"`. */
        sizeSmall: {
          padding: '4px 8px',
          minWidth: 64,
          fontSize: theme.typography.pxToRem(13)
        },

        /* Styles applied to the root element if `size="large"`. */
        sizeLarge: {
          padding: '8px 24px',
          fontSize: theme.typography.pxToRem(15)
        },

        /* Styles applied to the root element if `fullWidth={true}`. */
        fullWidth: {
          width: '100%'
        }
      };
    };
    var Button = React__default.forwardRef(function Button(props, ref) {
      var children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$component = props.component,
          component = _props$component === void 0 ? 'button' : _props$component,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$disableFocusRi = props.disableFocusRipple,
          disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
          focusVisibleClassName = props.focusVisibleClassName,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$size = props.size,
          size = _props$size === void 0 ? 'medium' : _props$size,
          _props$type = props.type,
          type = _props$type === void 0 ? 'button' : _props$type,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'text' : _props$variant,
          other = objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "fullWidth", "size", "type", "variant"]);

      var contained = variant === 'contained';
      var text = variant === 'text';
      var className = clsx(classes.root, classNameProp, variant === 'outlined' && [classes.outlined, color === 'primary' && classes.outlinedPrimary, color === 'secondary' && classes.outlinedSecondary], color === 'secondary' && [text && classes.textSecondary, contained && classes.containedSecondary], color === 'primary' && [text && classes.textPrimary, contained && classes.containedPrimary], text && classes.text, contained && classes.contained, size !== 'medium' && classes["size".concat(capitalize(size))], disabled && classes.disabled, fullWidth && classes.fullWidth, color === 'inherit' && classes.colorInherit);
      return React__default.createElement(ButtonBase$1, _extends_1({
        className: className,
        component: component,
        disabled: disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        ref: ref,
        type: type
      }, other), React__default.createElement("span", {
        className: classes.label
      }, children));
    });
    Button.propTypes = {
      /**
       * The content of the button.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'inherit', 'primary', 'secondary']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the button will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the  keyboard focus ripple will be disabled.
       * `disableRipple` must also be true.
       */
      disableFocusRipple: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       *
       *  Without a ripple there is no styling for :focus-visible by default. Be sure
       * to highlight the element by applying separate styles with the `focusVisibleClassName`.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * @ignore
       */
      focusVisibleClassName: PropTypes__default.string,

      /**
       * If `true`, the button will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The URL to link to when the button is clicked.
       * If defined, an `a` element will be used as the root node.
       */
      href: PropTypes__default.string,

      /**
       * The size of the button.
       * `small` is equivalent to the dense button styling.
       */
      size: PropTypes__default.oneOf(['small', 'medium', 'large']),

      /**
       * @ignore
       */
      type: PropTypes__default.string,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['text', 'outlined', 'contained'])
    };
    withStyles(styles$m, {
      name: 'MuiButton'
    })(Button);

    var styles$n = {
      /* Styles applied to the root element. */
      root: {
        overflow: 'hidden'
      }
    };
    var Card = React__default.forwardRef(function Card(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$raised = props.raised,
          raised = _props$raised === void 0 ? false : _props$raised,
          other = objectWithoutProperties(props, ["classes", "className", "raised"]);

      return React__default.createElement(Paper$1, _extends_1({
        className: clsx(classes.root, className),
        elevation: raised ? 8 : 1,
        ref: ref
      }, other));
    });
    Card.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the card will use raised styling.
       */
      raised: PropTypes__default.bool
    };
    withStyles(styles$n, {
      name: 'MuiCard'
    })(Card);

    var styles$o = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'block',
          textAlign: 'inherit',
          width: '100%',
          '&:hover $focusHighlight': {
            opacity: theme.palette.action.hoverOpacity
          },
          '&$focusVisible $focusHighlight': {
            opacity: 0.12
          }
        },

        /* Styles applied to the ButtonBase root element if the action area is keyboard focused. */
        focusVisible: {},

        /* Styles applied to the overlay that covers the action area when it is keyboard focused. */
        focusHighlight: {
          pointerEvents: 'none',
          position: 'absolute',
          backgroundColor: 'currentcolor',
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          opacity: 0,
          transition: theme.transitions.create('opacity', {
            duration: theme.transitions.duration.short
          })
        }
      };
    };
    var CardActionArea = React__default.forwardRef(function CardActionArea(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          focusVisibleClassName = props.focusVisibleClassName,
          other = objectWithoutProperties(props, ["children", "classes", "className", "focusVisibleClassName"]);

      return React__default.createElement(ButtonBase$1, _extends_1({
        className: clsx(classes.root, className),
        focusVisibleClassName: clsx(focusVisibleClassName, classes.focusVisible),
        ref: ref
      }, other), children, React__default.createElement("span", {
        className: classes.focusHighlight
      }));
    });
    CardActionArea.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       */
      focusVisibleClassName: PropTypes__default.string
    };
    withStyles(styles$o, {
      name: 'MuiCardActionArea'
    })(CardActionArea);

    var styles$p = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        alignItems: 'center',
        padding: 8
      },

      /* Styles applied to the root element if `disableSpacing={false}`. */
      spacing: {
        '& > * + *': {
          marginLeft: 8
        }
      }
    };
    var CardActions = React__default.forwardRef(function CardActions(props, ref) {
      var _props$disableSpacing = props.disableSpacing,
          disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,
          classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["disableSpacing", "classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, !disableSpacing && classes.spacing, className),
        ref: ref
      }, other));
    });
    CardActions.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the actions do not have additional margin.
       */
      disableSpacing: PropTypes__default.bool
    };
    withStyles(styles$p, {
      name: 'MuiCardActions'
    })(CardActions);

    var styles$q = {
      /* Styles applied to the root element. */
      root: {
        padding: 16,
        '&:last-child': {
          paddingBottom: 24
        }
      }
    };
    var CardContent = React__default.forwardRef(function CardContent(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          other = objectWithoutProperties(props, ["classes", "className", "component"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other));
    });
    CardContent.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType
    };
    withStyles(styles$q, {
      name: 'MuiCardContent'
    })(CardContent);

    var styles$r = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        alignItems: 'center',
        padding: 16
      },

      /* Styles applied to the avatar element. */
      avatar: {
        flex: '0 0 auto',
        marginRight: 16
      },

      /* Styles applied to the action element. */
      action: {
        flex: '0 0 auto',
        alignSelf: 'flex-start',
        marginTop: -8,
        marginRight: -8
      },

      /* Styles applied to the content wrapper element. */
      content: {
        flex: '1 1 auto'
      },

      /* Styles applied to the title Typography element. */
      title: {},

      /* Styles applied to the subheader Typography element. */
      subheader: {}
    };
    var CardHeader = React__default.forwardRef(function CardHeader(props, ref) {
      var action = props.action,
          avatar = props.avatar,
          classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$disableTypogra = props.disableTypography,
          disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
          subheaderProp = props.subheader,
          subheaderTypographyProps = props.subheaderTypographyProps,
          titleProp = props.title,
          titleTypographyProps = props.titleTypographyProps,
          other = objectWithoutProperties(props, ["action", "avatar", "classes", "className", "component", "disableTypography", "subheader", "subheaderTypographyProps", "title", "titleTypographyProps"]);

      var title = titleProp;

      if (title != null && title.type !== Typography$1 && !disableTypography) {
        title = React__default.createElement(Typography$1, _extends_1({
          variant: avatar ? 'body2' : 'h5',
          className: classes.title,
          component: "span",
          display: "block"
        }, titleTypographyProps), title);
      }

      var subheader = subheaderProp;

      if (subheader != null && subheader.type !== Typography$1 && !disableTypography) {
        subheader = React__default.createElement(Typography$1, _extends_1({
          variant: avatar ? 'body2' : 'body1',
          className: classes.subheader,
          color: "textSecondary",
          component: "span",
          display: "block"
        }, subheaderTypographyProps), subheader);
      }

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, classNameProp),
        ref: ref
      }, other), avatar && React__default.createElement("div", {
        className: classes.avatar
      }, avatar), React__default.createElement("div", {
        className: classes.content
      }, title, subheader), action && React__default.createElement("div", {
        className: classes.action
      }, action));
    });
    CardHeader.propTypes = {
      /**
       * The action to display in the card header.
       */
      action: PropTypes__default.node,

      /**
       * The Avatar for the Card Header.
       */
      avatar: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the children won't be wrapped by a Typography component.
       * This can be useful to render an alternative Typography variant by wrapping
       * the `title` text, and optional `subheader` text
       * with the Typography component.
       */
      disableTypography: PropTypes__default.bool,

      /**
       * The content of the component.
       */
      subheader: PropTypes__default.node,

      /**
       * These props will be forwarded to the subheader
       * (as long as disableTypography is not `true`).
       */
      subheaderTypographyProps: PropTypes__default.object,

      /**
       * The content of the Card Title.
       */
      title: PropTypes__default.node,

      /**
       * These props will be forwarded to the title
       * (as long as disableTypography is not `true`).
       */
      titleTypographyProps: PropTypes__default.object
    };
    withStyles(styles$r, {
      name: 'MuiCardHeader'
    })(CardHeader);

    var styles$s = {
      /* Styles applied to the root element. */
      root: {
        display: 'block',
        backgroundSize: 'cover',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center'
      },

      /* Styles applied to the root element if `component="video, audio, picture, iframe, or img"`. */
      media: {
        width: '100%',
        //  object-fit is not supported by IE 11.
        objectFit: 'cover'
      }
    };
    var MEDIA_COMPONENTS = ['video', 'audio', 'picture', 'iframe', 'img'];
    var CardMedia = React__default.forwardRef(function CardMedia(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          image = props.image,
          src = props.src,
          style = props.style,
          other = objectWithoutProperties(props, ["classes", "className", "component", "image", "src", "style"]);

      warning_1(Boolean(image || src), 'Material-UI: either `image` or `src` property must be specified.');
      var isMediaComponent = MEDIA_COMPONENTS.indexOf(Component) !== -1;
      var composedStyle = !isMediaComponent && image ? _extends_1({
        backgroundImage: "url(\"".concat(image, "\")")
      }, style) : style;
      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, isMediaComponent && classes.media, className),
        ref: ref,
        style: composedStyle,
        src: isMediaComponent ? image || src : undefined
      }, other));
    });
    CardMedia.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Component for rendering image.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Image to be displayed as a background image.
       * Either `image` or `src` prop must be specified.
       * Note that caller must specify height otherwise the image will not be visible.
       */
      image: PropTypes__default.string,

      /**
       * An alias for `image` property.
       * Available only with media components.
       * Media components: `video`, `audio`, `picture`, `iframe`, `img`.
       */
      src: PropTypes__default.string,

      /**
       * @ignore
       */
      style: PropTypes__default.object
    };
    withStyles(styles$s, {
      name: 'MuiCardMedia'
    })(CardMedia);

    /**
     * Copyright 2015, Yahoo! Inc.
     * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
     */

    var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
    };

    var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
    };

    var FORWARD_REF_STATICS = {
        '$$typeof': true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
    };

    var MEMO_STATICS = {
        '$$typeof': true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
    };

    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;

    function getStatics(component) {
        if (reactIs.isMemo(component)) {
            return MEMO_STATICS;
        }
        return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
    }

    var defineProperty$1 = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf$1 = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;

    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== 'string') {
            // don't hoist over string (html) components

            if (objectPrototype) {
                var inheritedComponent = getPrototypeOf$1(sourceComponent);
                if (inheritedComponent && inheritedComponent !== objectPrototype) {
                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                }
            }

            var keys = getOwnPropertyNames(sourceComponent);

            if (getOwnPropertySymbols) {
                keys = keys.concat(getOwnPropertySymbols(sourceComponent));
            }

            var targetStatics = getStatics(targetComponent);
            var sourceStatics = getStatics(sourceComponent);

            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                    try {
                        // Avoid failures from read-only properties
                        defineProperty$1(targetComponent, key, descriptor);
                    } catch (e) {}
                }
            }

            return targetComponent;
        }

        return targetComponent;
    }

    var hoistNonReactStatics_cjs = hoistNonReactStatics;

    /**
     * @ignore - internal component.
     */

    var FormControlContext = React__default.createContext();

    function withFormControlContext(Component) {
      var EnhancedComponent = React__default.forwardRef(function (props, ref) {
        return React__default.createElement(FormControlContext.Consumer, null, function (context) {
          return React__default.createElement(Component, _extends_1({
            muiFormControl: context,
            ref: ref
          }, props));
        });
      });

      {
        EnhancedComponent.displayName = "WithFormControlContext(".concat(getDisplayName(Component), ")");
      }

      hoistNonReactStatics_cjs(EnhancedComponent, Component);
      return EnhancedComponent;
    }

    var styles$t = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          textAlign: 'center',
          flex: '0 0 auto',
          fontSize: theme.typography.pxToRem(24),
          padding: 12,
          borderRadius: '50%',
          overflow: 'visible',
          // Explicitly set the default value to solve a bug on IE 11.
          color: theme.palette.action.active,
          transition: theme.transitions.create('background-color', {
            duration: theme.transitions.duration.shortest
          }),
          '&:hover': {
            backgroundColor: fade(theme.palette.action.active, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          },
          '&$disabled': {
            backgroundColor: 'transparent',
            color: theme.palette.action.disabled
          }
        },

        /* Styles applied to the root element if `edge="start"`. */
        edgeStart: {
          marginLeft: -12,
          '$sizeSmall&': {
            marginLeft: -3
          }
        },

        /* Styles applied to the root element if `edge="end"`. */
        edgeEnd: {
          marginRight: -12,
          '$sizeSmall&': {
            marginRight: -3
          }
        },

        /* Styles applied to the root element if `color="inherit"`. */
        colorInherit: {
          color: 'inherit'
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main,
          '&:hover': {
            backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          color: theme.palette.secondary.main,
          '&:hover': {
            backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `size="small"`. */
        sizeSmall: {
          padding: 3,
          fontSize: theme.typography.pxToRem(18)
        },

        /* Styles applied to the children container element. */
        label: {
          width: '100%',
          display: 'flex',
          alignItems: 'inherit',
          justifyContent: 'inherit'
        }
      };
    };
    /**
     * Refer to the [Icons](/components/icons/) section of the documentation
     * regarding the available icon options.
     */

    var IconButton = React__default.forwardRef(function IconButton(props, ref) {
      var _props$edge = props.edge,
          edge = _props$edge === void 0 ? false : _props$edge,
          children = props.children,
          classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$disableFocusRi = props.disableFocusRipple,
          disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
          _props$size = props.size,
          size = _props$size === void 0 ? 'medium' : _props$size,
          other = objectWithoutProperties(props, ["edge", "children", "classes", "className", "color", "disabled", "disableFocusRipple", "size"]);

      return React__default.createElement(ButtonBase$1, _extends_1({
        className: clsx(classes.root, color !== 'default' && classes["color".concat(capitalize(color))], disabled && classes.disabled, size !== 'medium' && classes["size".concat(capitalize(size))], edge === 'start' && classes.edgeStart, edge === 'end' && classes.edgeEnd, className),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled: disabled,
        ref: ref
      }, other), React__default.createElement("span", {
        className: classes.label
      }, children));
    });
    IconButton.propTypes = {
      /**
       * The icon element.
       */
      children: chainPropTypes(PropTypes__default.node, function (props) {
        var found = React__default.Children.toArray(props.children).some(function (child) {
          return React__default.isValidElement(child) && child.props.onClick;
        });

        if (found) {
          return new Error(['Material-UI: you are providing an onClick event listener ' + 'to a child of a button element.', 'Firefox will never trigger the event.', 'You should move the onClick listener to the parent button element.', 'https://github.com/mui-org/material-ui/issues/13957'].join('\n'));
        }

        return null;
      }),

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'inherit', 'primary', 'secondary']),

      /**
       * If `true`, the button will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the  keyboard focus ripple will be disabled.
       * `disableRipple` must also be true.
       */
      disableFocusRipple: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * If given, uses a negative margin to counteract the padding on one
       * side (this is often helpful for aligning the left or right
       * side of the icon with content above or below, without ruining the border
       * size and shape).
       */
      edge: PropTypes__default.oneOf(['start', 'end', false]),

      /**
       * The size of the button.
       * `small` is equivalent to the dense button styling.
       */
      size: PropTypes__default.oneOf(['small', 'medium'])
    };
    var IconButton$1 = withStyles(styles$t, {
      name: 'MuiIconButton'
    })(IconButton);

    var styles$u = {
      root: {
        padding: 9
      },
      checked: {},
      disabled: {},
      input: {
        cursor: 'inherit',
        position: 'absolute',
        opacity: 0,
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        margin: 0,
        padding: 0
      }
    };
    /**
     * @ignore - internal component.
     */

    var SwitchBase = React__default.forwardRef(function SwitchBase(props, ref) {
      var autoFocus = props.autoFocus,
          checkedProp = props.checked,
          checkedIcon = props.checkedIcon,
          classes = props.classes,
          classNameProp = props.className,
          defaultChecked = props.defaultChecked,
          disabledProp = props.disabled,
          icon = props.icon,
          id = props.id,
          inputProps = props.inputProps,
          inputRef = props.inputRef,
          muiFormControl = props.muiFormControl,
          name = props.name,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onFocus = props.onFocus,
          readOnly = props.readOnly,
          required = props.required,
          tabIndex = props.tabIndex,
          type = props.type,
          value = props.value,
          other = objectWithoutProperties(props, ["autoFocus", "checked", "checkedIcon", "classes", "className", "defaultChecked", "disabled", "icon", "id", "inputProps", "inputRef", "muiFormControl", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"]);

      var _React$useRef = React__default.useRef(checkedProp != null),
          isControlled = _React$useRef.current;

      var _React$useState = React__default.useState(Boolean(defaultChecked)),
          _React$useState2 = slicedToArray(_React$useState, 2),
          checkedState = _React$useState2[0],
          setCheckedState = _React$useState2[1];

      var handleFocus = function handleFocus(event) {
        if (onFocus) {
          onFocus(event);
        }

        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        }
      };

      var handleBlur = function handleBlur(event) {
        if (onBlur) {
          onBlur(event);
        }

        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        }
      };

      var handleInputChange = function handleInputChange(event) {
        var checked = event.target.checked;

        if (!isControlled) {
          setCheckedState(checked);
        }

        if (onChange) {
          onChange(event, checked);
        }
      };

      var disabled = disabledProp;

      if (muiFormControl) {
        if (typeof disabled === 'undefined') {
          disabled = muiFormControl.disabled;
        }
      }

      var checked = isControlled ? checkedProp : checkedState;
      var hasLabelFor = type === 'checkbox' || type === 'radio';
      return React__default.createElement(IconButton$1, _extends_1({
        component: "span",
        className: clsx(classes.root, checked && classes.checked, disabled && classes.disabled, classNameProp),
        disabled: disabled,
        tabIndex: null,
        role: undefined,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ref: ref
      }, other), checked ? checkedIcon : icon, React__default.createElement("input", _extends_1({
        autoFocus: autoFocus,
        checked: checkedProp,
        defaultChecked: defaultChecked,
        className: classes.input,
        disabled: disabled,
        id: hasLabelFor && id,
        name: name,
        onChange: handleInputChange,
        readOnly: readOnly,
        ref: inputRef,
        required: required,
        tabIndex: tabIndex,
        type: type,
        value: value
      }, inputProps)));
    }); // NB: If changed, please update Checkbox, Switch and Radio
    // so that the API documentation is updated.

    SwitchBase.propTypes = {
      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * If `true`, the component is checked.
       */
      checked: PropTypes__default.bool,

      /**
       * The icon to display when the component is checked.
       */
      checkedIcon: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       */
      defaultChecked: PropTypes__default.bool,

      /**
       * If `true`, the switch will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * The icon to display when the component is unchecked.
       */
      icon: PropTypes__default.node.isRequired,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /*
       * @ignore
       */
      name: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * Callback fired when the state is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.checked`.
       * @param {boolean} checked The `checked` value of the switch
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocus: PropTypes__default.func,

      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: PropTypes__default.bool,

      /**
       * If `true`, the `input` element will be required.
       */
      required: PropTypes__default.bool,

      /**
       * @ignore
       */
      tabIndex: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),

      /**
       * The input component property `type`.
       */
      type: PropTypes__default.string.isRequired,

      /**
       * The value of the component.
       */
      value: PropTypes__default.any
    };
    var SwitchBase$1 = withStyles(styles$u, {
      name: 'PrivateSwitchBase'
    })(withFormControlContext(SwitchBase));

    /**
     * @ignore - internal component.
     */

    var CheckBoxOutlineBlankIcon = createSvgIcon(React__default.createElement("path", {
      d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    }), 'CheckBoxOutlineBlank');

    /**
     * @ignore - internal component.
     */

    var CheckBoxIcon = createSvgIcon(React__default.createElement("path", {
      d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
    }), 'CheckBox');

    /**
     * @ignore - internal component.
     */

    var IndeterminateCheckBoxIcon = createSvgIcon(React__default.createElement("path", {
      d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
    }), 'IndeterminateCheckBox');

    var styles$v = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          color: theme.palette.text.secondary
        },

        /* Styles applied to the root element if `checked={true}`. */
        checked: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `indeterminate={true}`. */
        indeterminate: {},

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          '&$checked': {
            color: theme.palette.primary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent'
              }
            }
          },
          '&$disabled': {
            color: theme.palette.action.disabled
          }
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          '&$checked': {
            color: theme.palette.secondary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent'
              }
            }
          },
          '&$disabled': {
            color: theme.palette.action.disabled
          }
        }
      };
    };
    var defaultCheckedIcon = React__default.createElement(CheckBoxIcon, null);
    var defaultIcon = React__default.createElement(CheckBoxOutlineBlankIcon, null);
    var defaultIndeterminateIcon = React__default.createElement(IndeterminateCheckBoxIcon, null);
    var Checkbox = React__default.forwardRef(function Checkbox(props, ref) {
      var _props$checkedIcon = props.checkedIcon,
          checkedIcon = _props$checkedIcon === void 0 ? defaultCheckedIcon : _props$checkedIcon,
          classes = props.classes,
          _props$color = props.color,
          color = _props$color === void 0 ? 'secondary' : _props$color,
          _props$icon = props.icon,
          icon = _props$icon === void 0 ? defaultIcon : _props$icon,
          _props$indeterminate = props.indeterminate,
          indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
          _props$indeterminateI = props.indeterminateIcon,
          indeterminateIcon = _props$indeterminateI === void 0 ? defaultIndeterminateIcon : _props$indeterminateI,
          inputProps = props.inputProps,
          other = objectWithoutProperties(props, ["checkedIcon", "classes", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps"]);

      return React__default.createElement(SwitchBase$1, _extends_1({
        type: "checkbox",
        checkedIcon: indeterminate ? indeterminateIcon : checkedIcon,
        classes: {
          root: clsx(classes.root, classes["color".concat(capitalize(color))], indeterminate && classes.indeterminate),
          checked: classes.checked,
          disabled: classes.disabled
        },
        color: color,
        inputProps: _extends_1({
          'data-indeterminate': indeterminate
        }, inputProps),
        icon: indeterminate ? indeterminateIcon : icon,
        ref: ref
      }, other));
    });
    Checkbox.propTypes = {
      /**
       * If `true`, the component is checked.
       */
      checked: PropTypes__default.bool,

      /**
       * The icon to display when the component is checked.
       */
      checkedIcon: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary', 'default']),

      /**
       * If `true`, the switch will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * The icon to display when the component is unchecked.
       */
      icon: PropTypes__default.node,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * If `true`, the component appears indeterminate.
       * This does not set the native input element to indeterminate due
       * to inconsistent behavior across browsers.
       * However, we set a `data-indeterminate` attribute on the input.
       */
      indeterminate: PropTypes__default.bool,

      /**
       * The icon to display when the component is indeterminate.
       */
      indeterminateIcon: PropTypes__default.node,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Callback fired when the state is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.checked`.
       * @param {boolean} checked The `checked` value of the switch
       */
      onChange: PropTypes__default.func,

      /**
       * The input component property `type`.
       */
      type: PropTypes__default.string,

      /**
       * The value of the component. The DOM API casts this to a string.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$v, {
      name: 'MuiCheckbox'
    })(Checkbox);

    /**
     * @ignore - internal component.
     */

    var CancelIcon = createSvgIcon(React__default.createElement("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), 'Cancel');

    var styles$w = function styles(theme) {
      var height = 32;
      var backgroundColor = theme.palette.type === 'light' ? theme.palette.grey[300] : theme.palette.grey[700];
      var deleteIconColor = fade(theme.palette.text.primary, 0.26);
      return {
        /* Styles applied to the root element. */
        root: {
          fontFamily: theme.typography.fontFamily,
          fontSize: theme.typography.pxToRem(13),
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'center',
          height: height,
          color: theme.palette.getContrastText(backgroundColor),
          backgroundColor: backgroundColor,
          borderRadius: height / 2,
          whiteSpace: 'nowrap',
          transition: theme.transitions.create(['background-color', 'box-shadow']),
          // label will inherit this from root, then `clickable` class overrides this for both
          cursor: 'default',
          // We disable the focus ring for mouse, touch and keyboard users.
          outline: 'none',
          textDecoration: 'none',
          border: 'none',
          // Remove `button` border
          padding: 0,
          // Remove `button` padding
          verticalAlign: 'middle',
          boxSizing: 'border-box'
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          backgroundColor: theme.palette.primary.main,
          color: theme.palette.primary.contrastText
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          backgroundColor: theme.palette.secondary.main,
          color: theme.palette.secondary.contrastText
        },

        /* Styles applied to the root element if `onClick` is defined or `clickable={true}`. */
        clickable: {
          WebkitTapHighlightColor: 'transparent',
          // Remove grey highlight
          cursor: 'pointer',
          '&:hover, &:focus': {
            backgroundColor: emphasize(backgroundColor, 0.08)
          },
          '&:active': {
            boxShadow: theme.shadows[1],
            backgroundColor: emphasize(backgroundColor, 0.12)
          }
        },

        /* Styles applied to the root element if `onClick` and `color="primary"` is defined or `clickable={true}`. */
        clickableColorPrimary: {
          '&:hover, &:focus': {
            backgroundColor: emphasize(theme.palette.primary.main, 0.08)
          },
          '&:active': {
            backgroundColor: emphasize(theme.palette.primary.main, 0.12)
          }
        },

        /* Styles applied to the root element if `onClick` and `color="secondary"` is defined or `clickable={true}`. */
        clickableColorSecondary: {
          '&:hover, &:focus': {
            backgroundColor: emphasize(theme.palette.secondary.main, 0.08)
          },
          '&:active': {
            backgroundColor: emphasize(theme.palette.secondary.main, 0.12)
          }
        },

        /* Styles applied to the root element if `onDelete` is defined. */
        deletable: {
          '&:focus': {
            backgroundColor: emphasize(backgroundColor, 0.08)
          }
        },

        /* Styles applied to the root element if `onDelete` and `color="primary"` is defined. */
        deletableColorPrimary: {
          '&:focus': {
            backgroundColor: emphasize(theme.palette.primary.main, 0.2)
          }
        },

        /* Styles applied to the root element if `onDelete` and `color="secondary"` is defined. */
        deletableColorSecondary: {
          '&:focus': {
            backgroundColor: emphasize(theme.palette.secondary.main, 0.2)
          }
        },

        /* Styles applied to the root element if `variant="outlined"`. */
        outlined: {
          backgroundColor: 'transparent',
          border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
          '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
            backgroundColor: fade(theme.palette.text.primary, theme.palette.action.hoverOpacity)
          },
          '& $avatar': {
            marginLeft: -1
          }
        },

        /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
        outlinedPrimary: {
          color: theme.palette.primary.main,
          border: "1px solid ".concat(theme.palette.primary.main),
          '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
            backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity)
          }
        },

        /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
        outlinedSecondary: {
          color: theme.palette.secondary.main,
          border: "1px solid ".concat(theme.palette.secondary.main),
          '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
            backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity)
          }
        },

        /* Styles applied to the `avatar` element. */
        avatar: {
          marginRight: -4,
          width: height,
          height: height,
          color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
          fontSize: theme.typography.pxToRem(16)
        },

        /* Styles applied to the `avatar` element if `color="primary"`. */
        avatarColorPrimary: {
          color: theme.palette.primary.contrastText,
          backgroundColor: theme.palette.primary.dark
        },

        /* Styles applied to the `avatar` element if `color="secondary"`. */
        avatarColorSecondary: {
          color: theme.palette.secondary.contrastText,
          backgroundColor: theme.palette.secondary.dark
        },

        /* Styles applied to the `avatar` elements children. */
        avatarChildren: {
          width: 19,
          height: 19
        },

        /* Styles applied to the `icon` element. */
        icon: {
          color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
          marginLeft: 4,
          marginRight: -8
        },

        /* Styles applied to the `icon` element if `color="primary"`. */
        iconColorPrimary: {
          color: 'inherit'
        },

        /* Styles applied to the `icon` element if `color="secondary"`. */
        iconColorSecondary: {
          color: 'inherit'
        },

        /* Styles applied to the label `span` element`. */
        label: {
          display: 'flex',
          alignItems: 'center',
          paddingLeft: 12,
          paddingRight: 12,
          userSelect: 'none',
          whiteSpace: 'nowrap',
          cursor: 'inherit'
        },

        /* Styles applied to the `deleteIcon` element. */
        deleteIcon: {
          // Remove grey highlight
          WebkitTapHighlightColor: 'transparent',
          color: deleteIconColor,
          cursor: 'pointer',
          height: 'auto',
          margin: '0 4px 0 -8px',
          '&:hover': {
            color: fade(deleteIconColor, 0.4)
          }
        },

        /* Styles applied to the deleteIcon element if `color="primary"` and `variant="default"`. */
        deleteIconColorPrimary: {
          color: fade(theme.palette.primary.contrastText, 0.7),
          '&:hover, &:active': {
            color: theme.palette.primary.contrastText
          }
        },

        /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="default"`. */
        deleteIconColorSecondary: {
          color: fade(theme.palette.secondary.contrastText, 0.7),
          '&:hover, &:active': {
            color: theme.palette.secondary.contrastText
          }
        },

        /* Styles applied to the deleteIcon element if `color="primary"` and `variant="outlined"`. */
        deleteIconOutlinedColorPrimary: {
          color: fade(theme.palette.primary.main, 0.7),
          '&:hover, &:active': {
            color: theme.palette.primary.main
          }
        },

        /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="outlined"`. */
        deleteIconOutlinedColorSecondary: {
          color: fade(theme.palette.secondary.main, 0.7),
          '&:hover, &:active': {
            color: theme.palette.secondary.main
          }
        }
      };
    };
    /**
     * Chips represent complex entities in small blocks, such as a contact.
     */

    var Chip = React__default.forwardRef(function Chip(props, ref) {
      var avatarProp = props.avatar,
          classes = props.classes,
          classNameProp = props.className,
          clickableProp = props.clickable,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          deleteIconProp = props.deleteIcon,
          iconProp = props.icon,
          label = props.label,
          onClick = props.onClick,
          onDelete = props.onDelete,
          onKeyDown = props.onKeyDown,
          onKeyUp = props.onKeyUp,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'default' : _props$variant,
          other = objectWithoutProperties(props, ["avatar", "classes", "className", "clickable", "color", "component", "deleteIcon", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "variant"]);

      var chipRef = React__default.useRef(null);

      var handleDeleteIconClick = function handleDeleteIconClick(event) {
        // Stop the event from bubbling up to the `Chip`
        event.stopPropagation();

        if (onDelete) {
          onDelete(event);
        }
      };

      var handleKeyDown = function handleKeyDown(event) {
        if (onKeyDown) {
          onKeyDown(event);
        } // Ignore events from children of `Chip`.


        if (event.currentTarget !== event.target) {
          return;
        }

        var key = event.key;

        if (key === ' ' || key === 'Enter' || key === 'Backspace' || key === 'Delete' || key === 'Escape') {
          event.preventDefault();
        }
      };

      var handleKeyUp = function handleKeyUp(event) {
        if (onKeyUp) {
          onKeyUp(event);
        } // Ignore events from children of `Chip`.


        if (event.currentTarget !== event.target) {
          return;
        }

        var key = event.key;

        if (onClick && (key === ' ' || key === 'Enter')) {
          onClick(event);
        } else if (onDelete && (key === 'Backspace' || key === 'Delete')) {
          onDelete(event);
        } else if (key === 'Escape' && chipRef.current) {
          chipRef.current.blur();
        }
      };

      var clickable = clickableProp !== false && onClick ? true : clickableProp;
      var className = clsx(classes.root, classNameProp, variant === 'outlined' && [classes.outlined, color === 'primary' && classes.outlinedPrimary, color === 'secondary' && classes.outlinedSecondary], color !== 'default' && [classes["color".concat(capitalize(color))], clickable && classes["clickableColor".concat(capitalize(color))], onDelete && classes["deletableColor".concat(capitalize(color))]], clickable && classes.clickable, onDelete && classes.deletable);
      var deleteIcon = null;

      if (onDelete) {
        var customClasses = clsx(color !== 'default' && [variant !== 'outlined' && classes["deleteIconColor".concat(capitalize(color))], variant === 'outlined' && classes["deleteIconOutlinedColor".concat(capitalize(color))]]);
        deleteIcon = deleteIconProp && React__default.isValidElement(deleteIconProp) ? React__default.cloneElement(deleteIconProp, {
          className: clsx(deleteIconProp.props.className, classes.deleteIcon, customClasses),
          onClick: handleDeleteIconClick
        }) : React__default.createElement(CancelIcon, {
          className: clsx(classes.deleteIcon, customClasses),
          onClick: handleDeleteIconClick
        });
      }

      var avatar = null;

      if (avatarProp && React__default.isValidElement(avatarProp)) {
        avatar = React__default.cloneElement(avatarProp, {
          className: clsx(classes.avatar, avatarProp.props.className, color !== 'default' && classes["avatarColor".concat(capitalize(color))]),
          childrenClassName: clsx(classes.avatarChildren, avatarProp.props.childrenClassName)
        });
      }

      var icon = null;

      if (iconProp && React__default.isValidElement(iconProp)) {
        icon = React__default.cloneElement(iconProp, {
          className: clsx(classes.icon, iconProp.props.className, color !== 'default' && classes["iconColor".concat(capitalize(color))])
        });
      }

      warning_1(!avatar || !icon, 'Material-UI: the Chip component can not handle the avatar ' + 'and the icon property at the same time. Pick one.');
      var handleRef = useForkRef(chipRef, ref);
      return React__default.createElement(Component, _extends_1({
        role: clickable || onDelete ? 'button' : undefined,
        className: className,
        tabIndex: clickable || onDelete ? 0 : undefined,
        onClick: onClick,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        ref: handleRef
      }, other), avatar || icon, React__default.createElement("span", {
        className: classes.label
      }, label), deleteIcon);
    });
    Chip.propTypes = {
      /**
       * Avatar element.
       */
      avatar: PropTypes__default.element,

      /**
       * This property isn't supported.
       * Use the `component` property if you need to change the children structure.
       */
      children: unsupportedProp,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If true, the chip will appear clickable, and will raise when pressed,
       * even if the onClick property is not defined.
       * If false, the chip will not be clickable, even if onClick property is defined.
       * This can be used, for example,
       * along with the component property to indicate an anchor Chip is clickable.
       */
      clickable: PropTypes__default.bool,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'primary', 'secondary']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Override the default delete icon element. Shown only if `onDelete` is set.
       */
      deleteIcon: PropTypes__default.element,

      /**
       * Icon element.
       */
      icon: PropTypes__default.element,

      /**
       * The content of the label.
       */
      label: PropTypes__default.node,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * Callback function fired when the delete icon is clicked.
       * If set, the delete icon will be shown.
       */
      onDelete: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyDown: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyUp: PropTypes__default.func,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['default', 'outlined'])
    };
    withStyles(styles$w, {
      name: 'MuiChip'
    })(Chip);

    function ownerDocument(node) {
      return node && node.ownerDocument || document;
    }

    function useMountedRef() {
      var mountedRef = React__default.useRef(false);
      React__default.useEffect(function () {
        mountedRef.current = true;
        return function () {
          mountedRef.current = false;
        };
      }, []);
      return mountedRef;
    }

    function mapEventPropToEvent(eventProp) {
      return eventProp.substring(2).toLowerCase();
    }
    /**
     * Listen for click events that occur somewhere in the document, outside of the element itself.
     * For instance, if you need to hide a menu when people click anywhere else on your page.
     */


    function ClickAwayListener(props) {
      var children = props.children,
          _props$mouseEvent = props.mouseEvent,
          mouseEvent = _props$mouseEvent === void 0 ? 'onClick' : _props$mouseEvent,
          _props$touchEvent = props.touchEvent,
          touchEvent = _props$touchEvent === void 0 ? 'onTouchEnd' : _props$touchEvent,
          onClickAway = props.onClickAway;
      var mountedRef = useMountedRef();
      var movedRef = React__default.useRef(false);
      var nodeRef = React__default.useRef(null); // can be removed once we drop support for non ref forwarding class components

      var handleOwnRef = React__default.useCallback(function (instance) {
        // #StrictMode ready
        nodeRef.current = ReactDOM__default.findDOMNode(instance);
      }, []);
      var handleRef = useForkRef(children.ref, handleOwnRef);
      var handleClickAway = React__default.useCallback(function (event) {
        // Ignore events that have been `event.preventDefault()` marked.
        if (event.defaultPrevented) {
          return;
        } // IE 11 support, which trigger the handleClickAway even after the unbind


        if (!mountedRef.current) {
          return;
        } // Do not act if user performed touchmove


        if (movedRef.current) {
          movedRef.current = false;
          return;
        }

        var node = nodeRef.current; // The child might render null.

        if (!node) {
          return;
        }

        var doc = ownerDocument(node);

        if (doc.documentElement && doc.documentElement.contains(event.target) && !node.contains(event.target)) {
          onClickAway(event);
        }
      }, [mountedRef, onClickAway]);
      var handleTouchMove = React__default.useCallback(function () {
        movedRef.current = true;
      }, []);
      React__default.useEffect(function () {
        if (touchEvent !== false) {
          var mappedTouchEvent = mapEventPropToEvent(touchEvent);
          document.addEventListener(mappedTouchEvent, handleClickAway);
          document.addEventListener('touchmove', handleTouchMove);
          return function () {
            document.removeEventListener(mappedTouchEvent, handleClickAway);
            document.removeEventListener('touchmove', handleTouchMove);
          };
        }

        return undefined;
      }, [handleClickAway, handleTouchMove, touchEvent]);
      React__default.useEffect(function () {
        if (mouseEvent !== false) {
          var mappedMouseEvent = mapEventPropToEvent(mouseEvent);
          document.addEventListener(mappedMouseEvent, handleClickAway);
          return function () {
            document.removeEventListener(mappedMouseEvent, handleClickAway);
          };
        }

        return undefined;
      }, [handleClickAway, mouseEvent]);
      return React__default.createElement(React__default.Fragment, null, React__default.cloneElement(children, {
        ref: handleRef
      }));
    }

    ClickAwayListener.propTypes = {
      /**
       * The wrapped element.
       */
      children: elementAcceptingRef.isRequired,

      /**
       * The mouse event to listen to. You can disable the listener by providing `false`.
       */
      mouseEvent: PropTypes__default.oneOf(['onClick', 'onMouseDown', 'onMouseUp', false]),

      /**
       * Callback fired when a "click away" event is detected.
       */
      onClickAway: PropTypes__default.func.isRequired,

      /**
       * The touch event to listen to. You can disable the listener by providing `false`.
       */
      touchEvent: PropTypes__default.oneOf(['onTouchStart', 'onTouchEnd', false])
    };

    {
      // eslint-disable-next-line
      ClickAwayListener['propTypes' + ''] = exactProp(ClickAwayListener.propTypes);
    }

    var styles$x = function styles(theme) {
      return {
        /* Styles applied to the container element. */
        container: {
          height: 0,
          overflow: 'hidden',
          transition: theme.transitions.create('height')
        },

        /* Styles applied to the container element when the transition has entered. */
        entered: {
          height: 'auto',
          overflow: 'visible'
        },

        /* Styles applied to the container element when the transition has exited and `collapsedHeight` != 0px. */
        hidden: {
          visibility: 'hidden'
        },

        /* Styles applied to the outer wrapper element. */
        wrapper: {
          // Hack to get children with a negative margin to not falsify the height computation.
          display: 'flex'
        },

        /* Styles applied to the inner wrapper element. */
        wrapperInner: {
          width: '100%'
        }
      };
    };
    /**
     * The Collapse transition is used by the
     * [Vertical Stepper](/components/steppers/#vertical-stepper) StepContent component.
     * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
     */

    var Collapse = React__default.forwardRef(function Collapse(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$collapsedHeigh = props.collapsedHeight,
          collapsedHeight = _props$collapsedHeigh === void 0 ? '0px' : _props$collapsedHeigh,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          inProp = props.in,
          onEnter = props.onEnter,
          onEntered = props.onEntered,
          onEntering = props.onEntering,
          onExit = props.onExit,
          onExiting = props.onExiting,
          style = props.style,
          theme = props.theme,
          _props$timeout = props.timeout,
          timeout = _props$timeout === void 0 ? duration.standard : _props$timeout,
          other = objectWithoutProperties(props, ["children", "classes", "className", "collapsedHeight", "component", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExiting", "style", "theme", "timeout"]);

      var timer = React__default.useRef();
      var wrapperRef = React__default.useRef(null);
      var autoTransitionDuration = React__default.useRef();
      React__default.useEffect(function () {
        return function () {
          clearTimeout(timer.current);
        };
      }, []);

      var handleEnter = function handleEnter(node) {
        node.style.height = collapsedHeight;

        if (onEnter) {
          onEnter(node);
        }
      };

      var handleEntering = function handleEntering(node) {
        var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;

        var _getTransitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'enter'
        }),
            transitionDuration = _getTransitionProps.duration;

        if (timeout === 'auto') {
          var duration2 = theme.transitions.getAutoHeightDuration(wrapperHeight);
          node.style.transitionDuration = "".concat(duration2, "ms");
          autoTransitionDuration.current = duration2;
        } else {
          node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : "".concat(transitionDuration, "ms");
        }

        node.style.height = "".concat(wrapperHeight, "px");

        if (onEntering) {
          onEntering(node);
        }
      };

      var handleEntered = function handleEntered(node) {
        node.style.height = 'auto';

        if (onEntered) {
          onEntered(node);
        }
      };

      var handleExit = function handleExit(node) {
        var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;
        node.style.height = "".concat(wrapperHeight, "px");

        if (onExit) {
          onExit(node);
        }
      };

      var handleExiting = function handleExiting(node) {
        var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;

        var _getTransitionProps2 = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'exit'
        }),
            transitionDuration = _getTransitionProps2.duration;

        if (timeout === 'auto') {
          var duration2 = theme.transitions.getAutoHeightDuration(wrapperHeight);
          node.style.transitionDuration = "".concat(duration2, "ms");
          autoTransitionDuration.current = duration2;
        } else {
          node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : "".concat(transitionDuration, "ms");
        }

        node.style.height = collapsedHeight;

        if (onExiting) {
          onExiting(node);
        }
      };

      var addEndListener = function addEndListener(_, next) {
        if (timeout === 'auto') {
          timer.current = setTimeout(next, autoTransitionDuration.current || 0);
        }
      };

      return React__default.createElement(Transition, _extends_1({
        in: inProp,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExiting: handleExiting,
        addEndListener: addEndListener,
        timeout: timeout === 'auto' ? null : timeout
      }, other), function (state, childProps) {
        return React__default.createElement(Component, _extends_1({
          className: clsx(classes.container, state === 'entered' && classes.entered, state === 'exited' && !inProp && collapsedHeight === '0px' && classes.hidden, className),
          style: _extends_1({
            minHeight: collapsedHeight
          }, style),
          ref: ref
        }, childProps), React__default.createElement("div", {
          className: classes.wrapper,
          ref: wrapperRef
        }, React__default.createElement("div", {
          className: classes.wrapperInner
        }, children)));
      });
    });
    Collapse.propTypes = {
      /**
       * The content node to be collapsed.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The height of the container when collapsed.
       */
      collapsedHeight: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the component will transition in.
       */
      in: PropTypes__default.bool,

      /**
       * @ignore
       */
      onEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onEntered: PropTypes__default.func,

      /**
       * @ignore
       */
      onEntering: PropTypes__default.func,

      /**
       * @ignore
       */
      onExit: PropTypes__default.func,

      /**
       * @ignore
       */
      onExiting: PropTypes__default.func,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       *
       * Set to 'auto' to automatically calculate transition time based on height.
       */
      timeout: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      }), PropTypes__default.oneOf(['auto'])])
    };
    Collapse.muiSupportAuto = true;
    var Collapse$1 = withStyles(styles$x, {
      withTheme: true,
      name: 'MuiCollapse'
    })(Collapse);

    function requirePropFactory(componentNameInError) {

      var requireProp = function requireProp(requiredProp) {
        return function (props, propName, componentName, location, propFullName) {
          var propFullNameSafe = propFullName || propName;

          if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {
            return new Error("The property `".concat(propFullNameSafe, "` of ") + "`".concat(componentNameInError, "` must be used on `").concat(requiredProp, "`."));
          }

          return null;
        };
      };

      return requireProp;
    }

    function ownerWindow(node) {
      var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
      var doc = ownerDocument(node);
      return doc.defaultView || doc.parentView || fallback;
    }

    /**
     * Enables ref forwarding on a given component that uses `innerRef` to forward refs
     * This is useful for component implementations that predate `forwardRef` and
     * used other props to forward refs.
     *
     * Instead of `<Component innerRef={ref} />` you can write
     * `<withForwardRef(Component) ref={ref} />`.
     *
     * This HOC does not handle prop collision. In
     * `<withForwardRef(Component) ref={ref} innerRef={innerRef} />` `innerRef` will be dropped
     *
     * Only copies statics from material-ui over.
     *
     * @param {React.ComponentType} Component
     * @returns {React.ForwardRefComponent}
     */

    function withForwardedRef(Component) {
      var ForwardRefComponent = React__default.forwardRef(function (props, ref) {
        return (// We expect this component to be wrapped in `withStyles` in which `innerRef`
          // is already intercepted and therefore won't appear in `props` here.
          React__default.createElement(Component, _extends_1({}, props, {
            innerRef: ref
          }))
        );
      });

      {
        ForwardRefComponent.displayName = "ForwardRef(".concat(getDisplayName(Component), ")");
      }

      return hoistNonReactStatics_cjs(ForwardRefComponent, Component);
    }

    var styles$y = function styles(theme) {
      var _root;

      return {
        root: (_root = {
          width: '100%',
          marginLeft: 'auto',
          boxSizing: 'border-box',
          marginRight: 'auto',
          paddingLeft: theme.spacing(2),
          paddingRight: theme.spacing(2)
        }, defineProperty(_root, theme.breakpoints.up('sm'), {
          paddingLeft: theme.spacing(3),
          paddingRight: theme.spacing(3)
        }), defineProperty(_root, theme.breakpoints.up('md'), {
          paddingLeft: theme.spacing(4),
          paddingRight: theme.spacing(4)
        }), _root),
        fixed: Object.keys(theme.breakpoints.values).reduce(function (acc, breakpoint) {
          var value = theme.breakpoints.values[breakpoint];

          if (value !== 0) {
            acc[theme.breakpoints.up(breakpoint)] = {
              maxWidth: value
            };
          }

          return acc;
        }, {}),
        maxWidthXs: defineProperty({}, theme.breakpoints.up('xs'), {
          maxWidth: Math.max(theme.breakpoints.values.xs, 444)
        }),
        maxWidthSm: defineProperty({}, theme.breakpoints.up('sm'), {
          maxWidth: theme.breakpoints.values.sm
        }),
        maxWidthMd: defineProperty({}, theme.breakpoints.up('md'), {
          maxWidth: theme.breakpoints.values.md
        }),
        maxWidthLg: defineProperty({}, theme.breakpoints.up('lg'), {
          maxWidth: theme.breakpoints.values.lg
        }),
        maxWidthXl: defineProperty({}, theme.breakpoints.up('xl'), {
          maxWidth: theme.breakpoints.values.xl
        })
      };
    };
    var Container = React__default.forwardRef(function Container(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$fixed = props.fixed,
          fixed = _props$fixed === void 0 ? false : _props$fixed,
          _props$maxWidth = props.maxWidth,
          maxWidth = _props$maxWidth === void 0 ? 'lg' : _props$maxWidth,
          other = objectWithoutProperties(props, ["classes", "className", "component", "fixed", "maxWidth"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, fixed && classes.fixed, maxWidth !== false && classes["maxWidth".concat(capitalize(String(maxWidth)))], className),
        ref: ref
      }, other));
    });
    Container.propTypes = {
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Set the max-width to match the min-width of the current breakpoint.
       * This is useful if you'd prefer to design for a fixed set of sizes
       * instead of trying to accommodate a fully fluid viewport.
       * It's fluid by default.
       */
      fixed: PropTypes__default.bool,

      /**
       * Determine the max-width of the container.
       * The container width grows with the size of the screen.
       * Set to `false` to disable `maxWidth`.
       */
      maxWidth: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl', false])
    };
    withStyles(styles$y, {
      name: 'MuiContainer'
    })(Container);

    var useStyles$c = makeStyles(function (theme) {
      return {
        '@global': {
          html: {
            WebkitFontSmoothing: 'antialiased',
            // Antialiasing.
            MozOsxFontSmoothing: 'grayscale',
            // Antialiasing.
            // Change from `box-sizing: content-box` so that `width`
            // is not affected by `padding` or `border`.
            boxSizing: 'border-box'
          },
          '*, *::before, *::after': {
            boxSizing: 'inherit'
          },
          'strong, b': {
            fontWeight: theme.typography.fontWeightMedium
          },
          body: _extends_1({
            margin: 0,
            // Remove the margin in all browsers.
            color: theme.palette.text.primary
          }, theme.typography.body2, {
            backgroundColor: theme.palette.background.default,
            '@media print': {
              // Save printer ink.
              backgroundColor: theme.palette.common.white
            }
          })
        }
      };
    }, {
      name: 'MuiCssBaseline'
    });
    /**
     * Kickstart an elegant, consistent, and simple baseline to build upon.
     */

    function CssBaseline(props) {
      var _props$children = props.children,
          children = _props$children === void 0 ? null : _props$children;
      useStyles$c();
      return React__default.createElement(React__default.Fragment, null, children);
    }

    CssBaseline.propTypes = {
      /**
       * You can wrap a node.
       */
      children: PropTypes__default.node
    };

    {
      // eslint-disable-next-line
      CssBaseline['propTypes' + ''] = exactProp(CssBaseline.propTypes);
    }

    function getContainer(container) {
      container = typeof container === 'function' ? container() : container; // #StrictMode ready

      return ReactDOM__default.findDOMNode(container);
    }

    var useEnhancedEffect$2 = typeof window !== 'undefined' ? React__default.useLayoutEffect : React__default.useEffect;
    /**
     * Portals provide a first-class way to render children into a DOM node
     * that exists outside the DOM hierarchy of the parent component.
     */

    var Portal = React__default.forwardRef(function Portal(props, ref) {
      var children = props.children,
          container = props.container,
          disablePortal = props.disablePortal,
          onRendered = props.onRendered;

      var _React$useState = React__default.useState(null),
          _React$useState2 = slicedToArray(_React$useState, 2),
          mountNode = _React$useState2[0],
          setMountNode = _React$useState2[1];

      var childRef = React__default.useRef(null);
      var handleRef = useForkRef(children.ref, childRef);
      useEnhancedEffect$2(function () {
        if (!disablePortal) {
          setMountNode(getContainer(container) || document.body);
        }
      }, [container, disablePortal]);
      React__default.useEffect(function () {
        if (onRendered && mountNode) {
          onRendered();
        }
      }, [mountNode, onRendered]);
      React__default.useImperativeHandle(ref, function () {
        return mountNode || childRef.current;
      }, [mountNode]);

      if (disablePortal) {
        React__default.Children.only(children);
        return React__default.cloneElement(children, {
          ref: handleRef
        });
      }

      return mountNode ? ReactDOM__default.createPortal(children, mountNode) : mountNode;
    });
    Portal.propTypes = {
      /**
       * The children to render into the `container`.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * A node, component instance, or function that returns either.
       * The `container` will have the portal children appended to it.
       * By default, it uses the body of the top-level document object,
       * so it's simply `document.body` most of the time.
       */
      container: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),

      /**
       * Disable the portal behavior.
       * The children stay within it's parent DOM hierarchy.
       */
      disablePortal: PropTypes__default.bool,

      /**
       * Callback fired once the children has been mounted into the `container`.
       */
      onRendered: PropTypes__default.func
    };
    Portal.defaultProps = {
      disablePortal: false
    };

    {
      // eslint-disable-next-line
      Portal['propTypes' + ''] = exactProp(Portal.propTypes);
    }

    // A change of the browser zoom change the scrollbar size.
    // Credit https://github.com/twbs/bootstrap/blob/3ffe3a5d82f6f561b82ff78d82b32a7d14aed558/js/src/modal.js#L512-L519
    function getScrollbarSize() {
      var scrollDiv = document.createElement('div');
      scrollDiv.style.width = '99px';
      scrollDiv.style.height = '99px';
      scrollDiv.style.position = 'absolute';
      scrollDiv.style.top = '-9999px';
      scrollDiv.style.overflow = 'scroll';
      document.body.appendChild(scrollDiv);
      var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarSize;
    }

    function isOverflowing(container) {
      var doc = ownerDocument(container);
      var win = ownerWindow(doc);

      if (doc.body === container) {
        return win.innerWidth > doc.documentElement.clientWidth;
      }

      return container.scrollHeight > container.clientHeight;
    }

    var BLACKLIST = ['template', 'script', 'style'];

    function isHideable(node) {
      return node.nodeType === 1 && BLACKLIST.indexOf(node.tagName.toLowerCase()) === -1;
    }

    function siblings(container, mount, currentNode, callback) {
      var blacklist = [mount, currentNode];
      [].forEach.call(container.children, function (node) {
        if (blacklist.indexOf(node) === -1 && isHideable(node)) {
          callback(node);
        }
      });
    }

    function ariaHidden(node, show) {
      if (show) {
        node.setAttribute('aria-hidden', 'true');
      } else {
        node.removeAttribute('aria-hidden');
      }
    }
    function ariaHiddenSiblings(container, mountNode, currentNode, show) {
      siblings(container, mountNode, currentNode, function (node) {
        return ariaHidden(node, show);
      });
    }

    function findIndexOf(data, callback) {
      var idx = -1;
      data.some(function (item, index) {
        if (callback(item)) {
          idx = index;
          return true;
        }

        return false;
      });
      return idx;
    }

    function getPaddingRight(node) {
      return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
    }

    function setContainerStyle(data) {
      // We are only interested in the actual `style` here because we will override it.
      data.style = {
        overflow: data.container.style.overflow,
        paddingRight: data.container.style.paddingRight
      };
      var style = {
        overflow: 'hidden'
      };

      if (data.overflowing) {
        var scrollbarSize = getScrollbarSize(); // Use computed style, here to get the real padding to add our scrollbar width.

        style.paddingRight = "".concat(getPaddingRight(data.container) + scrollbarSize, "px"); // .mui-fixed is a global helper.

        var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');

        for (var i = 0; i < fixedNodes.length; i += 1) {
          var paddingRight = getPaddingRight(fixedNodes[i]);
          data.prevPaddings.push(paddingRight);
          fixedNodes[i].style.paddingRight = "".concat(paddingRight + scrollbarSize, "px");
        }
      }

      Object.keys(style).forEach(function (key) {
        data.container.style[key] = style[key];
      });
    }

    function removeContainerStyle(data) {
      // The modal might be closed before it had the chance to be mounted in the DOM.
      if (data.style) {
        Object.keys(data.style).forEach(function (key) {
          data.container.style[key] = data.style[key];
        });
      }

      var fixedNodes = ownerDocument(data.container).querySelectorAll('.mui-fixed');

      for (var i = 0; i < fixedNodes.length; i += 1) {
        fixedNodes[i].style.paddingRight = "".concat(data.prevPaddings[i], "px");
      }
    }
    /**
     * @ignore - do not document.
     *
     * Proper state management for containers and the modals in those containers.
     * Simplified, but inspired by react-overlay's ModalManager class.
     * Used by the Modal to ensure proper styling of containers.
     */


    var ModalManager =
    /*#__PURE__*/
    function () {
      function ModalManager() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        classCallCheck(this, ModalManager);

        var _options$hideSiblingN = options.hideSiblingNodes,
            hideSiblingNodes = _options$hideSiblingN === void 0 ? true : _options$hideSiblingN,
            _options$handleContai = options.handleContainerOverflow,
            handleContainerOverflow = _options$handleContai === void 0 ? true : _options$handleContai;
        this.hideSiblingNodes = hideSiblingNodes;
        this.handleContainerOverflow = handleContainerOverflow; // this.modals[modalIdx] = modal

        this.modals = []; // this.data[containerIdx] = {
        //   modals: [],
        //   container,
        //   overflowing,
        //   prevPaddings,
        // }

        this.data = [];
      }

      createClass(ModalManager, [{
        key: "add",
        value: function add(modal, container) {
          var modalIdx = this.modals.indexOf(modal);

          if (modalIdx !== -1) {
            return modalIdx;
          }

          modalIdx = this.modals.length;
          this.modals.push(modal); // If the modal we are adding is already in the DOM.

          if (modal.modalRef) {
            ariaHidden(modal.modalRef, false);
          }

          if (this.hideSiblingNodes) {
            ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, true);
          }

          var containerIdx = findIndexOf(this.data, function (item) {
            return item.container === container;
          });

          if (containerIdx !== -1) {
            this.data[containerIdx].modals.push(modal);
            return modalIdx;
          }

          var data = {
            modals: [modal],
            container: container,
            overflowing: isOverflowing(container),
            prevPaddings: []
          };
          this.data.push(data);
          return modalIdx;
        }
      }, {
        key: "mount",
        value: function mount(modal) {
          var containerIdx = findIndexOf(this.data, function (item) {
            return item.modals.indexOf(modal) !== -1;
          });
          var data = this.data[containerIdx];

          if (!data.style && this.handleContainerOverflow) {
            setContainerStyle(data);
          }
        }
      }, {
        key: "remove",
        value: function remove(modal) {
          var modalIdx = this.modals.indexOf(modal);

          if (modalIdx === -1) {
            return modalIdx;
          }

          var containerIdx = findIndexOf(this.data, function (item) {
            return item.modals.indexOf(modal) !== -1;
          });
          var data = this.data[containerIdx];
          data.modals.splice(data.modals.indexOf(modal), 1);
          this.modals.splice(modalIdx, 1); // If that was the last modal in a container, clean up the container.

          if (data.modals.length === 0) {
            if (this.handleContainerOverflow) {
              removeContainerStyle(data);
            } // In case the modal wasn't in the DOM yet.


            if (modal.modalRef) {
              ariaHidden(modal.modalRef, true);
            }

            if (this.hideSiblingNodes) {
              ariaHiddenSiblings(data.container, modal.mountNode, modal.modalRef, false);
            }

            this.data.splice(containerIdx, 1);
          } else if (this.hideSiblingNodes) {
            // Otherwise make sure the next top modal is visible to a screen reader.
            var nextTop = data.modals[data.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
            // aria-hidden because the dom element doesn't exist either
            // when modal was unmounted before modalRef gets null

            if (nextTop.modalRef) {
              ariaHidden(nextTop.modalRef, false);
            }
          }

          return modalIdx;
        }
      }, {
        key: "isTopModal",
        value: function isTopModal(modal) {
          return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
        }
      }]);

      return ModalManager;
    }();

    /* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex */

    function TrapFocus(props) {
      var children = props.children,
          _props$disableAutoFoc = props.disableAutoFocus,
          disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
          _props$disableEnforce = props.disableEnforceFocus,
          disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
          _props$disableRestore = props.disableRestoreFocus,
          disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
          getDoc = props.getDoc,
          isEnabled = props.isEnabled,
          open = props.open;
      var ignoreNextEnforceFocus = React__default.useRef();
      var sentinelStart = React__default.useRef(null);
      var sentinelEnd = React__default.useRef(null);
      var lastFocus = React__default.useRef();
      var rootRef = React__default.useRef(null); // can be removed once we drop support for non ref forwarding class components

      var handleOwnRef = React__default.useCallback(function (instance) {
        // #StrictMode ready
        rootRef.current = ReactDOM__default.findDOMNode(instance);
      }, []);
      var handleRef = useForkRef(children.ref, handleOwnRef); //  You may rely on React.useMemo as a performance optimization, not as a semantic guarantee.
      // https://reactjs.org/docs/hooks-reference.html#usememo

      React__default.useMemo(function () {
        if (!open) {
          return;
        }

        lastFocus.current = getDoc().activeElement;
      }, [open]); // eslint-disable-line react-hooks/exhaustive-deps

      React__default.useEffect(function () {
        if (!open) {
          return;
        }

        var doc = ownerDocument(rootRef.current); // We might render an empty child.

        if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
          if (!rootRef.current.hasAttribute('tabIndex')) {
            warning_1(false, ['Material-UI: the modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
            rootRef.current.setAttribute('tabIndex', -1);
          }

          rootRef.current.focus();
        }

        var enforceFocus = function enforceFocus() {
          if (disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
            ignoreNextEnforceFocus.current = false;
            return;
          }

          if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
            rootRef.current.focus();
          }
        };

        var loopFocus = function loopFocus(event) {
          // 9 = Tab
          if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
            return;
          } // Make sure the next tab starts from the right place.


          if (doc.activeElement === rootRef.current) {
            // We need to ignore the next enforceFocus as
            // it will try to move the focus back to the rootRef element.
            ignoreNextEnforceFocus.current = true;

            if (event.shiftKey) {
              sentinelEnd.current.focus();
            } else {
              sentinelStart.current.focus();
            }
          }
        };

        doc.addEventListener('focus', enforceFocus, true);
        doc.addEventListener('keydown', loopFocus, true);
        return function () {
          doc.removeEventListener('focus', enforceFocus, true);
          doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()

          if (!disableRestoreFocus) {
            // Not all elements in IE 11 have a focus method.
            // Because IE 11 market share is low, we accept the restore focus being broken
            // and we silent the issue.
            if (lastFocus.current.focus) {
              lastFocus.current.focus();
            }

            lastFocus.current = null;
          }
        };
      }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
      return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", {
        tabIndex: 0,
        ref: sentinelStart,
        "data-test": "sentinelStart"
      }), React__default.cloneElement(children, {
        ref: handleRef
      }), React__default.createElement("div", {
        tabIndex: 0,
        ref: sentinelEnd,
        "data-test": "sentinelEnd"
      }));
    }
    /**
     * @ignore - internal component.
     */


    TrapFocus.propTypes = {
      /**
       * A single child content element.
       */
      children: PropTypes__default.element.isRequired,

      /**
       * If `true`, the modal will not automatically shift focus to itself when it opens, and
       * replace it to the last focused element when it closes.
       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       */
      disableAutoFocus: PropTypes__default.bool,

      /**
       * If `true`, the modal will not prevent focus from leaving the modal while open.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       */
      disableEnforceFocus: PropTypes__default.bool,

      /**
       * If `true`, the modal will not restore focus to previously focused element once
       * modal is hidden.
       */
      disableRestoreFocus: PropTypes__default.bool,

      /**
       * Return the document to consider.
       * We use it to implement the restore focus between different browser documents.
       */
      getDoc: PropTypes__default.func.isRequired,

      /**
       * Do we still want to enforce the focus?
       * This property helps nesting TrapFocus elements.
       */
      isEnabled: PropTypes__default.func.isRequired,

      /**
       * If `true`, the modal is open.
       */
      open: PropTypes__default.bool.isRequired
    };

    var styles$z = {
      /* Styles applied to the root element. */
      root: {
        zIndex: -1,
        position: 'fixed',
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        // Remove grey highlight
        WebkitTapHighlightColor: 'transparent',
        // Disable scroll capabilities.
        touchAction: 'none'
      },

      /* Styles applied to the root element if `invisible={true}`. */
      invisible: {
        backgroundColor: 'transparent'
      }
    };
    /**
     * @ignore - internal component.
     */

    var SimpleBackdrop = React__default.forwardRef(function SimpleBackdrop(props, ref) {
      var invisible = props.invisible,
          open = props.open,
          other = objectWithoutProperties(props, ["invisible", "open"]);

      return open ? React__default.createElement("div", _extends_1({
        "aria-hidden": true,
        ref: ref
      }, other, {
        style: _extends_1({}, styles$z.root, invisible ? styles$z.invisible : {}, other.style)
      })) : null;
    });
    SimpleBackdrop.propTypes = {
      /**
       * If `true`, the backdrop is invisible.
       * It can be used when rendering a popover or a custom select component.
       */
      invisible: PropTypes__default.bool,

      /**
       * If `true`, the backdrop is open.
       */
      open: PropTypes__default.bool.isRequired
    };
    SimpleBackdrop.defaultProps = {
      invisible: false
    };

    function getContainer$1(container) {
      container = typeof container === 'function' ? container() : container;
      return ReactDOM__default.findDOMNode(container);
    }

    function getHasTransition(props) {
      return props.children ? props.children.props.hasOwnProperty('in') : false;
    }

    var styles$A = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'fixed',
          zIndex: theme.zIndex.modal,
          right: 0,
          bottom: 0,
          top: 0,
          left: 0
        },

        /* Styles applied to the root element if the `Modal` has exited. */
        hidden: {
          visibility: 'hidden'
        }
      };
    };
    /**
     * Modal is a lower-level construct that is leveraged by the following components:
     *
     * - [Dialog](/api/dialog/)
     * - [Drawer](/api/drawer/)
     * - [Menu](/api/menu/)
     * - [Popover](/api/popover/)
     *
     * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
     * rather than directly using Modal.
     *
     * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
     */

    var Modal =
    /*#__PURE__*/
    function (_React$Component) {
      inherits(Modal, _React$Component);

      function Modal(props) {
        var _this;

        classCallCheck(this, Modal);

        _this = possibleConstructorReturn(this, getPrototypeOf(Modal).call(this));

        _this.handleOpen = function () {
          var container = getContainer$1(_this.props.container) || _this.getDoc().body;

          _this.props.manager.add(assertThisInitialized(_this), container);

          if (_this.modalRef) {
            _this.handleOpened();
          }
        };

        _this.handleRendered = function () {
          if (_this.props.onRendered) {
            _this.props.onRendered();
          }

          if (_this.props.open) {
            _this.handleOpened();
          } else {
            ariaHidden(_this.modalRef, true);
          }
        };

        _this.handleOpened = function () {
          _this.props.manager.mount(assertThisInitialized(_this)); // Fix a bug on Chrome where the scroll isn't initially 0.


          _this.modalRef.scrollTop = 0;
        };

        _this.handleClose = function (reason) {
          var hasTransition = getHasTransition(_this.props);
          /* If the component does not have a transition or is unmounting remove the Modal
          otherwise let the transition handle removing the style, this prevents elements
          moving around when the Modal is closed. */

          if (!(hasTransition && _this.props.closeAfterTransition) || reason === 'unmount') {
            _this.props.manager.remove(assertThisInitialized(_this));
          }
        };

        _this.handleEnter = function () {
          _this.setState({
            exited: false
          });
        };

        _this.handleExited = function () {
          if (_this.props.closeAfterTransition) {
            _this.props.manager.remove(assertThisInitialized(_this));
          }

          _this.setState({
            exited: true
          });
        };

        _this.handleBackdropClick = function (event) {
          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this.props.onBackdropClick) {
            _this.props.onBackdropClick(event);
          }

          if (!_this.props.disableBackdropClick && _this.props.onClose) {
            _this.props.onClose(event, 'backdropClick');
          }
        };

        _this.handleKeyDown = function (event) {
          // We don't take event.defaultPrevented into account:
          //
          // event.preventDefault() is meant to stop default behaviours like
          // clicking a checkbox to check it, hitting a button to submit a form,
          // and hitting left arrow to move the cursor in a text input etc.
          // Only special HTML elements have these default behaviors.
          if (event.key !== 'Escape' || !_this.isTopModal()) {
            return;
          } // Swallow the event, in case someone is listening for the escape key on the body.


          event.stopPropagation();

          if (_this.props.onEscapeKeyDown) {
            _this.props.onEscapeKeyDown(event);
          }

          if (!_this.props.disableEscapeKeyDown && _this.props.onClose) {
            _this.props.onClose(event, 'escapeKeyDown');
          }
        };

        _this.handlePortalRef = function (ref) {
          _this.mountNode = ref;
        };

        _this.handleModalRef = function (ref) {
          _this.modalRef = ref;
          setRef(_this.props.innerRef, ref);
        };

        _this.isTopModal = function () {
          return _this.props.manager.isTopModal(assertThisInitialized(_this));
        };

        _this.getDoc = function () {
          return ownerDocument(_this.mountNode);
        };

        _this.state = {
          exited: !props.open
        };
        return _this;
      }

      createClass(Modal, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this.props.open) {
            this.handleOpen();
          }
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (prevProps.open && !this.props.open) {
            this.handleClose();
          } else if (!prevProps.open && this.props.open) {
            this.handleOpen();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this.props.open || getHasTransition(this.props) && !this.state.exited) {
            this.handleClose('unmount');
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props,
              BackdropComponent = _this$props.BackdropComponent,
              BackdropProps = _this$props.BackdropProps,
              children = _this$props.children,
              closeAfterTransition = _this$props.closeAfterTransition,
              container = _this$props.container,
              disableAutoFocus = _this$props.disableAutoFocus,
              disableBackdropClick = _this$props.disableBackdropClick,
              disableEnforceFocus = _this$props.disableEnforceFocus,
              disableEscapeKeyDown = _this$props.disableEscapeKeyDown,
              disablePortal = _this$props.disablePortal,
              disableRestoreFocus = _this$props.disableRestoreFocus,
              hideBackdrop = _this$props.hideBackdrop,
              innerRef = _this$props.innerRef,
              keepMounted = _this$props.keepMounted,
              manager = _this$props.manager,
              onBackdropClick = _this$props.onBackdropClick,
              onClose = _this$props.onClose,
              onEscapeKeyDown = _this$props.onEscapeKeyDown,
              onRendered = _this$props.onRendered,
              open = _this$props.open,
              theme = _this$props.theme,
              other = objectWithoutProperties(_this$props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "hideBackdrop", "innerRef", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open", "theme"]);

          var exited = this.state.exited;
          var hasTransition = getHasTransition(this.props);

          if (!keepMounted && !open && (!hasTransition || exited)) {
            return null;
          }

          var childProps = {}; // It's a Transition like component

          if (hasTransition) {
            childProps.onEnter = createChainedFunction(this.handleEnter, children.props.onEnter);
            childProps.onExited = createChainedFunction(this.handleExited, children.props.onExited);
          }

          if (children.props.role === undefined) {
            childProps.role = children.props.role || 'document';
          }

          if (children.props.tabIndex === undefined) {
            childProps.tabIndex = children.props.tabIndex || '-1';
          }

          var stylesRender = styles$A(theme || {
            zIndex: zIndex
          });
          return React__default.createElement(Portal, {
            ref: this.handlePortalRef,
            container: container,
            disablePortal: disablePortal,
            onRendered: this.handleRendered
          }, React__default.createElement("div", _extends_1({
            ref: this.handleModalRef,
            onKeyDown: this.handleKeyDown,
            role: "presentation"
          }, other, {
            style: _extends_1({}, stylesRender.root, !open && exited ? stylesRender.hidden : {}, other.style)
          }), hideBackdrop ? null : React__default.createElement(BackdropComponent, _extends_1({
            open: open,
            onClick: this.handleBackdropClick
          }, BackdropProps)), React__default.createElement(TrapFocus, {
            disableEnforceFocus: disableEnforceFocus,
            disableAutoFocus: disableAutoFocus,
            disableRestoreFocus: disableRestoreFocus,
            getDoc: this.getDoc,
            isEnabled: this.isTopModal,
            open: open
          }, React__default.cloneElement(children, childProps))));
        }
      }]);

      return Modal;
    }(React__default.Component);

    Modal.propTypes = {
      /**
       * A backdrop component. This property enables custom backdrop rendering.
       */
      BackdropComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the [`Backdrop`](/api/backdrop/) element.
       */
      BackdropProps: PropTypes__default.object,

      /**
       * A single child content element.
       */
      children: elementAcceptingRef.isRequired,

      /**
       * When set to true the Modal waits until a nested Transition is completed before closing.
       */
      closeAfterTransition: PropTypes__default.bool,

      /**
       * A node, component instance, or function that returns either.
       * The `container` will have the portal children appended to it.
       */
      container: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),

      /**
       * If `true`, the modal will not automatically shift focus to itself when it opens, and
       * replace it to the last focused element when it closes.
       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       */
      disableAutoFocus: PropTypes__default.bool,

      /**
       * If `true`, clicking the backdrop will not fire any callback.
       */
      disableBackdropClick: PropTypes__default.bool,

      /**
       * If `true`, the modal will not prevent focus from leaving the modal while open.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       */
      disableEnforceFocus: PropTypes__default.bool,

      /**
       * If `true`, hitting escape will not fire any callback.
       */
      disableEscapeKeyDown: PropTypes__default.bool,

      /**
       * Disable the portal behavior.
       * The children stay within it's parent DOM hierarchy.
       */
      disablePortal: PropTypes__default.bool,

      /**
       * If `true`, the modal will not restore focus to previously focused element once
       * modal is hidden.
       */
      disableRestoreFocus: PropTypes__default.bool,

      /**
       * If `true`, the backdrop is not rendered.
       */
      hideBackdrop: PropTypes__default.bool,

      /**
       * @ignore
       * from `withForwardRef`
       */
      innerRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Always keep the children in the DOM.
       * This property can be useful in SEO situation or
       * when you want to maximize the responsiveness of the Modal.
       */
      keepMounted: PropTypes__default.bool,

      /**
       * @ignore
       *
       * A modal manager used to track and manage the state of open
       * Modals. This enables customizing how modals interact within a container.
       */
      manager: PropTypes__default.object,

      /**
       * Callback fired when the backdrop is clicked.
       */
      onBackdropClick: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be closed.
       * The `reason` parameter can optionally be used to control the response to `onClose`.
       *
       * @param {object} event The event source of the callback
       * @param {string} reason Can be:`"escapeKeyDown"`, `"backdropClick"`
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired when the escape key is pressed,
       * `disableEscapeKeyDown` is false and the modal is in focus.
       */
      onEscapeKeyDown: PropTypes__default.func,

      /**
       * Callback fired once the children has been mounted into the `container`.
       * It signals that the `open={true}` property took effect.
       */
      onRendered: PropTypes__default.func,

      /**
       * If `true`, the modal is open.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * @ignore
       */
      theme: PropTypes__default.object
    };
    Modal.defaultProps = {
      BackdropComponent: SimpleBackdrop,
      closeAfterTransition: false,
      disableAutoFocus: false,
      disableBackdropClick: false,
      disableEnforceFocus: false,
      disableEscapeKeyDown: false,
      disablePortal: false,
      disableRestoreFocus: false,
      hideBackdrop: false,
      keepMounted: false,
      // Modals don't open on the server so this won't conflict with concurrent requests.
      manager: new ModalManager()
    };
    var Modal$1 = styles$1O.withTheme(withForwardedRef(Modal));

    var styles$B = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          '@media print': {
            position: 'absolute'
          }
        },

        /* Styles applied to the root element if `scroll="paper"`. */
        scrollPaper: {
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center'
        },

        /* Styles applied to the root element if `scroll="body"`. */
        scrollBody: {
          overflowY: 'auto',
          overflowX: 'hidden'
        },

        /* Styles applied to the container element. */
        container: {
          height: '100%',
          '@media print': {
            height: 'auto'
          },
          // We disable the focus ring for mouse, touch and keyboard users.
          outline: 'none'
        },

        /* Styles applied to the `Paper` component. */
        paper: {
          display: 'flex',
          flexDirection: 'column',
          margin: 48,
          position: 'relative',
          overflowY: 'auto',
          // Fix IE 11 issue, to remove at some point.
          '@media print': {
            overflowY: 'visible',
            boxShadow: 'none'
          }
        },

        /* Styles applied to the `Paper` component if `scroll="paper"`. */
        paperScrollPaper: {
          flex: '0 1 auto',
          maxHeight: 'calc(100% - 96px)'
        },

        /* Styles applied to the `Paper` component if `scroll="body"`. */
        paperScrollBody: {
          margin: '48px auto'
        },

        /* Styles applied to the `Paper` component if `maxWidth=false`. */
        paperWidthFalse: {
          '&$paperScrollBody': {
            margin: 48
          }
        },

        /* Styles applied to the `Paper` component if `maxWidth="xs"`. */
        paperWidthXs: {
          maxWidth: Math.max(theme.breakpoints.values.xs, 444),
          '&$paperScrollBody': defineProperty({}, theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 48 * 2), {
            margin: 48
          })
        },

        /* Styles applied to the `Paper` component if `maxWidth="sm"`. */
        paperWidthSm: {
          maxWidth: theme.breakpoints.values.sm,
          '&$paperScrollBody': defineProperty({}, theme.breakpoints.down(theme.breakpoints.values.sm + 48 * 2), {
            margin: 48
          })
        },

        /* Styles applied to the `Paper` component if `maxWidth="md"`. */
        paperWidthMd: {
          maxWidth: theme.breakpoints.values.md,
          '&$paperScrollBody': defineProperty({}, theme.breakpoints.down(theme.breakpoints.values.md + 48 * 2), {
            margin: 48
          })
        },

        /* Styles applied to the `Paper` component if `maxWidth="lg"`. */
        paperWidthLg: {
          maxWidth: theme.breakpoints.values.lg,
          '&$paperScrollBody': defineProperty({}, theme.breakpoints.down(theme.breakpoints.values.lg + 48 * 2), {
            margin: 48
          })
        },

        /* Styles applied to the `Paper` component if `maxWidth="xl"`. */
        paperWidthXl: {
          maxWidth: theme.breakpoints.values.xl,
          '&$paperScrollBody': defineProperty({}, theme.breakpoints.down(theme.breakpoints.values.xl + 48 * 2), {
            margin: 48
          })
        },

        /* Styles applied to the `Paper` component if `fullWidth={true}`. */
        paperFullWidth: {
          width: '100%',
          '&$paperScrollBody': {
            width: 'initial'
          }
        },

        /* Styles applied to the `Paper` component if `fullScreen={true}`. */
        paperFullScreen: {
          margin: 0,
          width: '100%',
          maxWidth: '100%',
          height: '100%',
          maxHeight: 'none',
          borderRadius: 0,
          '&$paperScrollBody': {
            margin: 0
          }
        }
      };
    };
    var defaultTransitionDuration = {
      enter: duration.enteringScreen,
      exit: duration.leavingScreen
    };
    /**
     * Dialogs are overlaid modal paper based components with a backdrop.
     */

    var Dialog = React__default.forwardRef(function Dialog(props, ref) {
      var BackdropProps = props.BackdropProps,
          children = props.children,
          classes = props.classes,
          className = props.className,
          _props$disableBackdro = props.disableBackdropClick,
          disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro,
          _props$disableEscapeK = props.disableEscapeKeyDown,
          disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
          _props$fullScreen = props.fullScreen,
          fullScreen = _props$fullScreen === void 0 ? false : _props$fullScreen,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$maxWidth = props.maxWidth,
          maxWidth = _props$maxWidth === void 0 ? 'sm' : _props$maxWidth,
          onBackdropClick = props.onBackdropClick,
          onClose = props.onClose,
          onEnter = props.onEnter,
          onEntered = props.onEntered,
          onEntering = props.onEntering,
          onEscapeKeyDown = props.onEscapeKeyDown,
          onExit = props.onExit,
          onExited = props.onExited,
          onExiting = props.onExiting,
          open = props.open,
          _props$PaperComponent = props.PaperComponent,
          PaperComponent = _props$PaperComponent === void 0 ? Paper$1 : _props$PaperComponent,
          _props$PaperProps = props.PaperProps,
          PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
          _props$scroll = props.scroll,
          scroll = _props$scroll === void 0 ? 'paper' : _props$scroll,
          _props$TransitionComp = props.TransitionComponent,
          TransitionComponent = _props$TransitionComp === void 0 ? Fade$1 : _props$TransitionComp,
          _props$transitionDura = props.transitionDuration,
          transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura,
          TransitionProps = props.TransitionProps,
          other = objectWithoutProperties(props, ["BackdropProps", "children", "classes", "className", "disableBackdropClick", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "onEnter", "onEntered", "onEntering", "onEscapeKeyDown", "onExit", "onExited", "onExiting", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"]);

      var mouseDownTarget = React__default.useRef();

      var handleMouseDown = function handleMouseDown(event) {
        mouseDownTarget.current = event.target;
      };

      var handleBackdropClick = function handleBackdropClick(event) {
        // Ignore the events not coming from the "backdrop"
        // We don't want to close the dialog when clicking the dialog content.
        if (event.target !== event.currentTarget) {
          return;
        } // Make sure the event starts and ends on the same DOM element.


        if (event.target !== mouseDownTarget.current) {
          return;
        }

        mouseDownTarget.current = null;

        if (onBackdropClick) {
          onBackdropClick(event);
        }

        if (!disableBackdropClick && onClose) {
          onClose(event, 'backdropClick');
        }
      };

      return React__default.createElement(Modal$1, _extends_1({
        className: clsx(classes.root, className),
        BackdropComponent: Backdrop$1,
        BackdropProps: _extends_1({
          transitionDuration: transitionDuration
        }, BackdropProps),
        closeAfterTransition: true,
        disableBackdropClick: disableBackdropClick,
        disableEscapeKeyDown: disableEscapeKeyDown,
        onEscapeKeyDown: onEscapeKeyDown,
        onClose: onClose,
        open: open,
        ref: ref,
        role: "dialog"
      }, other), React__default.createElement(TransitionComponent, _extends_1({
        appear: true,
        in: open,
        timeout: transitionDuration,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: onExited
      }, TransitionProps), React__default.createElement("div", {
        className: clsx(classes.container, classes["scroll".concat(capitalize(scroll))]),
        onClick: handleBackdropClick,
        onMouseDown: handleMouseDown,
        role: "document"
      }, React__default.createElement(PaperComponent, _extends_1({
        elevation: 24
      }, PaperProps, {
        className: clsx(classes.paper, classes["paperScroll".concat(capitalize(scroll))], classes["paperWidth".concat(capitalize(String(maxWidth)))], fullScreen && classes.paperFullScreen, fullWidth && classes.paperFullWidth, PaperProps.className)
      }), children))));
    });
    Dialog.propTypes = {
      /**
       * @ignore
       */
      BackdropProps: PropTypes__default.object,

      /**
       * Dialog children, usually the included sub-components.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, clicking the backdrop will not fire the `onClose` callback.
       */
      disableBackdropClick: PropTypes__default.bool,

      /**
       * If `true`, hitting escape will not fire the `onClose` callback.
       */
      disableEscapeKeyDown: PropTypes__default.bool,

      /**
       * If `true`, the dialog will be full-screen
       */
      fullScreen: PropTypes__default.bool,

      /**
       * If `true`, the dialog stretches to `maxWidth`.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * Determine the max-width of the dialog.
       * The dialog width grows with the size of the screen.
       * Set to `false` to disable `maxWidth`.
       */
      maxWidth: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl', false]),

      /**
       * Callback fired when the backdrop is clicked.
       */
      onBackdropClick: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be closed.
       *
       * @param {object} event The event source of the callback
       * @param {string} reason Can be:`"escapeKeyDown"`, `"backdropClick"`
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired before the dialog enters.
       */
      onEnter: PropTypes__default.func,

      /**
       * Callback fired when the dialog has entered.
       */
      onEntered: PropTypes__default.func,

      /**
       * Callback fired when the dialog is entering.
       */
      onEntering: PropTypes__default.func,

      /**
       * Callback fired when the escape key is pressed,
       * `disableKeyboard` is false and the modal is in focus.
       */
      onEscapeKeyDown: PropTypes__default.func,

      /**
       * Callback fired before the dialog exits.
       */
      onExit: PropTypes__default.func,

      /**
       * Callback fired when the dialog has exited.
       */
      onExited: PropTypes__default.func,

      /**
       * Callback fired when the dialog is exiting.
       */
      onExiting: PropTypes__default.func,

      /**
       * If `true`, the Dialog is open.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * The component used to render the body of the dialog.
       */
      PaperComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the [`Paper`](/api/paper/) element.
       */
      PaperProps: PropTypes__default.object,

      /**
       * Determine the container for scrolling the dialog.
       */
      scroll: PropTypes__default.oneOf(['body', 'paper']),

      /**
       * The component used for the transition.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })]),

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    withStyles(styles$B, {
      name: 'MuiDialog'
    })(Dialog);

    var styles$C = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        alignItems: 'center',
        padding: 8,
        justifyContent: 'flex-end'
      },

      /* Styles applied to the root element if `disableSpacing={false}`. */
      spacing: {
        '& > * + *': {
          marginLeft: 8
        }
      }
    };
    var DialogActions = React__default.forwardRef(function DialogActions(props, ref) {
      var _props$disableSpacing = props.disableSpacing,
          disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,
          classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["disableSpacing", "classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, !disableSpacing && classes.spacing, className),
        ref: ref
      }, other));
    });
    DialogActions.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the actions do not have additional margin.
       */
      disableSpacing: PropTypes__default.bool
    };
    withStyles(styles$C, {
      name: 'MuiDialogActions'
    })(DialogActions);

    var styles$D = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          flex: '1 1 auto',
          padding: '8px 24px',
          WebkitOverflowScrolling: 'touch',
          // Add iOS momentum scrolling.
          overflowY: 'auto'
        },

        /* Styles applied to the root element if `dividers={true}`. */
        dividers: {
          borderTop: "1px solid ".concat(theme.palette.divider),
          borderBottom: "1px solid ".concat(theme.palette.divider)
        }
      };
    };
    var DialogContent = React__default.forwardRef(function DialogContent(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$dividers = props.dividers,
          dividers = _props$dividers === void 0 ? false : _props$dividers,
          other = objectWithoutProperties(props, ["classes", "className", "dividers"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, dividers && classes.dividers, className),
        ref: ref
      }, other));
    });
    DialogContent.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Display the top and bottom dividers.
       */
      dividers: PropTypes__default.bool
    };
    withStyles(styles$D, {
      name: 'MuiDialogContent'
    })(DialogContent);

    var styles$E = {
      /* Styles applied to the root element. */
      root: {
        marginBottom: 16
      }
    };
    var DialogContentText = React__default.forwardRef(function DialogContentText(props, ref) {
      return React__default.createElement(Typography$1, _extends_1({
        component: "p",
        variant: "body1",
        color: "textSecondary",
        ref: ref
      }, props));
    });
    DialogContentText.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired
    };
    withStyles(styles$E, {
      name: 'MuiDialogContentText'
    })(DialogContentText);

    var styles$F = {
      /* Styles applied to the root element. */
      root: {
        margin: 0,
        padding: '16px 24px',
        flex: '0 0 auto'
      }
    };
    var DialogTitle = React__default.forwardRef(function DialogTitle(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$disableTypogra = props.disableTypography,
          disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
          other = objectWithoutProperties(props, ["children", "classes", "className", "disableTypography"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other), disableTypography ? children : React__default.createElement(Typography$1, {
        variant: "h6"
      }, children));
    });
    DialogTitle.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the children won't be wrapped by a typography component.
       * For instance, this can be useful to render an h4 instead of the default h2.
       */
      disableTypography: PropTypes__default.bool
    };
    withStyles(styles$F, {
      name: 'MuiDialogTitle'
    })(DialogTitle);

    var styles$G = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          height: 1,
          margin: 0,
          // Reset browser default style.
          border: 'none',
          flexShrink: 0,
          backgroundColor: theme.palette.divider
        },

        /* Styles applied to the root element if `absolute={true}`. */
        absolute: {
          position: 'absolute',
          bottom: 0,
          left: 0,
          width: '100%'
        },

        /* Styles applied to the root element if `variant="inset"`. */
        inset: {
          marginLeft: 72
        },

        /* Styles applied to the root element if `light={true}`. */
        light: {
          backgroundColor: fade(theme.palette.divider, 0.08)
        },

        /* Styles applied to the root element if `variant="middle"`. */
        middle: {
          marginLeft: theme.spacing(2),
          marginRight: theme.spacing(2)
        }
      };
    };
    var Divider = React__default.forwardRef(function Divider(props, ref) {
      var _props$absolute = props.absolute,
          absolute = _props$absolute === void 0 ? false : _props$absolute,
          classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'hr' : _props$component,
          _props$light = props.light,
          light = _props$light === void 0 ? false : _props$light,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'fullWidth' : _props$variant,
          other = objectWithoutProperties(props, ["absolute", "classes", "className", "component", "light", "variant"]);

      if (Component === 'li' && !other.role) {
        other.role = 'separator';
      }

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, variant === 'inset' && classes.inset, variant === 'middle' && classes.middle, absolute && classes.absolute, light && classes.light, className),
        ref: ref
      }, other));
    });
    Divider.propTypes = {
      /**
       * Absolutely position the element.
       */
      absolute: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the divider will have a lighter color.
       */
      light: PropTypes__default.bool,

      /**
       *  The variant to use.
       */
      variant: PropTypes__default.oneOf(['fullWidth', 'inset', 'middle'])
    };
    withStyles(styles$G, {
      name: 'MuiDivider'
    })(Divider);

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing. The function also has a property 'clear' 
     * that is a function which will clear the timer to prevent previously scheduled executions. 
     *
     * @source underscore.js
     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
     * @param {Function} function to wrap
     * @param {Number} timeout in ms (`100`)
     * @param {Boolean} whether to execute at the beginning (`false`)
     * @api public
     */
    function debounce(func, wait, immediate){
      var timeout, args, context, timestamp, result;
      if (null == wait) wait = 100;

      function later() {
        var last = Date.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function(){
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };

      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          
          clearTimeout(timeout);
          timeout = null;
        }
      };

      return debounced;
    }
    // Adds compatibility for ES modules
    debounce.debounce = debounce;

    var debounce_1 = debounce;

    var GUTTER = 24; // Translate the node so he can't be seen on the screen.
    // Later, we gonna translate back the node to his original location
    // with `translate3d(0, 0, 0)`.`

    function getTranslateValue(direction, node) {
      var rect = node.getBoundingClientRect();
      var transform;

      if (node.fakeTransform) {
        transform = node.fakeTransform;
      } else {
        var computedStyle = window.getComputedStyle(node);
        transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');
      }

      var offsetX = 0;
      var offsetY = 0;

      if (transform && transform !== 'none' && typeof transform === 'string') {
        var transformValues = transform.split('(')[1].split(')')[0].split(',');
        offsetX = parseInt(transformValues[4], 10);
        offsetY = parseInt(transformValues[5], 10);
      }

      if (direction === 'left') {
        return "translateX(100vw) translateX(-".concat(rect.left - offsetX, "px)");
      }

      if (direction === 'right') {
        return "translateX(-".concat(rect.left + rect.width + GUTTER - offsetX, "px)");
      }

      if (direction === 'up') {
        return "translateY(100vh) translateY(-".concat(rect.top - offsetY, "px)");
      } // direction === 'down'


      return "translateY(-".concat(rect.top + rect.height + GUTTER - offsetY, "px)");
    }

    function setTranslateValue(direction, node) {
      var transform = getTranslateValue(direction, node);

      if (transform) {
        node.style.webkitTransform = transform;
        node.style.transform = transform;
      }
    }
    var defaultTimeout$1 = {
      enter: duration.enteringScreen,
      exit: duration.leavingScreen
    };
    /**
     * The Slide transition is used by the [Drawer](/components/drawers/) component.
     * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
     */

    var Slide = React__default.forwardRef(function Slide(props, ref) {
      var children = props.children,
          _props$direction = props.direction,
          direction = _props$direction === void 0 ? 'down' : _props$direction,
          inProp = props.in,
          onEnter = props.onEnter,
          onEntering = props.onEntering,
          onExit = props.onExit,
          onExited = props.onExited,
          style = props.style,
          theme = props.theme,
          _props$timeout = props.timeout,
          timeout = _props$timeout === void 0 ? defaultTimeout$1 : _props$timeout,
          other = objectWithoutProperties(props, ["children", "direction", "in", "onEnter", "onEntering", "onExit", "onExited", "style", "theme", "timeout"]);

      var childrenRef = React__default.useRef(null);
      /**
       * used in cloneElement(children, { ref: handleRef })
       */

      var handleOwnRef = React__default.useCallback(function (instance) {
        // #StrictMode ready
        childrenRef.current = ReactDOM__default.findDOMNode(instance);
      }, []);
      var handleRefIntermediary = useForkRef(children.ref, handleOwnRef);
      var handleRef = useForkRef(handleRefIntermediary, ref);

      var handleEnter = function handleEnter() {
        var node = childrenRef.current;
        setTranslateValue(direction, node);
        reflow(node);

        if (onEnter) {
          onEnter(node);
        }
      };

      var handleEntering = function handleEntering() {
        var node = childrenRef.current;
        var transitionProps = getTransitionProps({
          timeout: timeout,
          style: style
        }, {
          mode: 'enter'
        });
        node.style.webkitTransition = theme.transitions.create('-webkit-transform', _extends_1({}, transitionProps, {
          easing: theme.transitions.easing.easeOut
        }));
        node.style.transition = theme.transitions.create('transform', _extends_1({}, transitionProps, {
          easing: theme.transitions.easing.easeOut
        }));
        node.style.webkitTransform = 'translate(0, 0)';
        node.style.transform = 'translate(0, 0)';

        if (onEntering) {
          onEntering(node);
        }
      };

      var handleExit = function handleExit() {
        var node = childrenRef.current;
        var transitionProps = getTransitionProps({
          timeout: timeout,
          style: style
        }, {
          mode: 'exit'
        });
        node.style.webkitTransition = theme.transitions.create('-webkit-transform', _extends_1({}, transitionProps, {
          easing: theme.transitions.easing.sharp
        }));
        node.style.transition = theme.transitions.create('transform', _extends_1({}, transitionProps, {
          easing: theme.transitions.easing.sharp
        }));
        setTranslateValue(direction, node);

        if (onExit) {
          onExit(node);
        }
      };

      var handleExited = function handleExited() {
        var node = childrenRef.current; // No need for transitions when the component is hidden

        node.style.webkitTransition = '';
        node.style.transition = '';

        if (onExited) {
          onExited(node);
        }
      };

      var updatePosition = React__default.useCallback(function () {
        if (childrenRef.current) {
          setTranslateValue(direction, childrenRef.current);
        }
      }, [direction]);
      React__default.useEffect(function () {
        // Skip configuration where the position is screen size invariant.
        if (!inProp && direction !== 'down' && direction !== 'right') {
          var handleResize = debounce_1(function () {
            if (childrenRef.current) {
              setTranslateValue(direction, childrenRef.current);
            }
          }, 166); // Corresponds to 10 frames at 60 Hz.

          window.addEventListener('resize', handleResize);
          return function () {
            handleResize.clear();
            window.removeEventListener('resize', handleResize);
          };
        }

        return undefined;
      }, [direction, inProp]);
      React__default.useEffect(function () {
        if (!inProp) {
          // We need to update the position of the drawer when the direction change and
          // when it's hidden.
          updatePosition();
        }
      }, [inProp, updatePosition]);
      return React__default.createElement(Transition, _extends_1({
        onEnter: handleEnter,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        appear: true,
        in: inProp,
        timeout: timeout
      }, other), function (state, childProps) {
        return React__default.cloneElement(children, _extends_1({
          ref: handleRef,
          style: _extends_1({
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, style, children.props.style)
        }, childProps));
      });
    });
    Slide.propTypes = {
      /**
       * A single child content element.
       */
      children: elementAcceptingRef,

      /**
       * Direction the child node will enter from.
       */
      direction: PropTypes__default.oneOf(['left', 'right', 'up', 'down']),

      /**
       * If `true`, show the component; triggers the enter or exit animation.
       */
      in: PropTypes__default.bool,

      /**
       * @ignore
       */
      onEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onEntering: PropTypes__default.func,

      /**
       * @ignore
       */
      onExit: PropTypes__default.func,

      /**
       * @ignore
       */
      onExited: PropTypes__default.func,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      timeout: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })])
    };
    var Slide$1 = withTheme(Slide);

    var styles$H = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {},

        /* Styles applied to the root element if `variant="permanent or persistent"`. */
        docked: {
          flex: '0 0 auto'
        },

        /* Styles applied to the `Paper` component. */
        paper: {
          overflowY: 'auto',
          display: 'flex',
          flexDirection: 'column',
          height: '100%',
          flex: '1 0 auto',
          zIndex: theme.zIndex.drawer,
          WebkitOverflowScrolling: 'touch',
          // Add iOS momentum scrolling.
          // temporary style
          position: 'fixed',
          top: 0,
          // We disable the focus ring for mouse, touch and keyboard users.
          // At some point, it would be better to keep it for keyboard users.
          // :focus-ring CSS pseudo-class will help.
          outline: 'none'
        },

        /* Styles applied to the `Paper` component if `anchor="left"`. */
        paperAnchorLeft: {
          left: 0,
          right: 'auto'
        },

        /* Styles applied to the `Paper` component if `anchor="right"`. */
        paperAnchorRight: {
          left: 'auto',
          right: 0
        },

        /* Styles applied to the `Paper` component if `anchor="top"`. */
        paperAnchorTop: {
          top: 0,
          left: 0,
          bottom: 'auto',
          right: 0,
          height: 'auto',
          maxHeight: '100%'
        },

        /* Styles applied to the `Paper` component if `anchor="bottom"`. */
        paperAnchorBottom: {
          top: 'auto',
          left: 0,
          bottom: 0,
          right: 0,
          height: 'auto',
          maxHeight: '100%'
        },

        /* Styles applied to the `Paper` component if `anchor="left"` & `variant` is not "temporary". */
        paperAnchorDockedLeft: {
          borderRight: "1px solid ".concat(theme.palette.divider)
        },

        /* Styles applied to the `Paper` component if `anchor="top"` & `variant` is not "temporary". */
        paperAnchorDockedTop: {
          borderBottom: "1px solid ".concat(theme.palette.divider)
        },

        /* Styles applied to the `Paper` component if `anchor="right"` & `variant` is not "temporary". */
        paperAnchorDockedRight: {
          borderLeft: "1px solid ".concat(theme.palette.divider)
        },

        /* Styles applied to the `Paper` component if `anchor="bottom"` & `variant` is not "temporary". */
        paperAnchorDockedBottom: {
          borderTop: "1px solid ".concat(theme.palette.divider)
        },

        /* Styles applied to the `Modal` component. */
        modal: {}
      };
    };
    var oppositeDirection = {
      left: 'right',
      right: 'left',
      top: 'down',
      bottom: 'up'
    };
    function isHorizontal(anchor) {
      return ['left', 'right'].indexOf(anchor) !== -1;
    }
    function getAnchor(theme, anchor) {
      return theme.direction === 'rtl' && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
    }
    var defaultTransitionDuration$1 = {
      enter: duration.enteringScreen,
      exit: duration.leavingScreen
    };
    /**
     * The properties of the [Modal](/api/modal/) component are available
     * when `variant="temporary"` is set.
     */

    var Drawer = React__default.forwardRef(function Drawer(props, ref) {
      var _props$anchor = props.anchor,
          anchorProp = _props$anchor === void 0 ? 'left' : _props$anchor,
          BackdropProps = props.BackdropProps,
          children = props.children,
          classes = props.classes,
          className = props.className,
          _props$elevation = props.elevation,
          elevation = _props$elevation === void 0 ? 16 : _props$elevation,
          _props$ModalProps = props.ModalProps;
      _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;

      var BackdropPropsProp = _props$ModalProps.BackdropProps,
          ModalProps = objectWithoutProperties(_props$ModalProps, ["BackdropProps"]),
          onClose = props.onClose,
          _props$open = props.open,
          open = _props$open === void 0 ? false : _props$open,
          PaperProps = props.PaperProps,
          SlideProps = props.SlideProps,
          theme = props.theme,
          _props$transitionDura = props.transitionDuration,
          transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration$1 : _props$transitionDura,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'temporary' : _props$variant,
          other = objectWithoutProperties(props, ["anchor", "BackdropProps", "children", "classes", "className", "elevation", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "theme", "transitionDuration", "variant"]); // Let's assume that the Drawer will always be rendered on user space.
      // We use this state is order to skip the appear transition during the
      // initial mount of the component.


      var mounted = React__default.useRef(false);
      React__default.useEffect(function () {
        mounted.current = true;
      }, []);
      var anchor = getAnchor(theme, anchorProp);
      var drawer = React__default.createElement(Paper$1, _extends_1({
        elevation: variant === 'temporary' ? elevation : 0,
        square: true,
        className: clsx(classes.paper, classes["paperAnchor".concat(capitalize(anchor))], variant !== 'temporary' && classes["paperAnchorDocked".concat(capitalize(anchor))])
      }, PaperProps), children);

      if (variant === 'permanent') {
        return React__default.createElement("div", _extends_1({
          className: clsx(classes.root, classes.docked, className),
          ref: ref
        }, other), drawer);
      }

      var slidingDrawer = React__default.createElement(Slide$1, _extends_1({
        in: open,
        direction: oppositeDirection[anchor],
        timeout: transitionDuration,
        appear: mounted.current
      }, SlideProps), drawer);

      if (variant === 'persistent') {
        return React__default.createElement("div", _extends_1({
          className: clsx(classes.root, classes.docked, className)
        }, other), slidingDrawer);
      } // variant === temporary


      return React__default.createElement(Modal$1, _extends_1({
        BackdropProps: _extends_1({}, BackdropProps, BackdropPropsProp, {
          transitionDuration: transitionDuration
        }),
        BackdropComponent: Backdrop$1,
        className: clsx(classes.root, classes.modal, className),
        open: open,
        onClose: onClose,
        ref: ref
      }, other, ModalProps), slidingDrawer);
    });
    Drawer.propTypes = {
      /**
       * Side from which the drawer will appear.
       */
      anchor: PropTypes__default.oneOf(['left', 'top', 'right', 'bottom']),

      /**
       * @ignore
       */
      BackdropProps: PropTypes__default.object,

      /**
       * The contents of the drawer.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The elevation of the drawer.
       */
      elevation: PropTypes__default.number,

      /**
       * Properties applied to the [`Modal`](/api/modal/) element.
       */
      ModalProps: PropTypes__default.object,

      /**
       * Callback fired when the component requests to be closed.
       *
       * @param {object} event The event source of the callback
       */
      onClose: PropTypes__default.func,

      /**
       * If `true`, the drawer is open.
       */
      open: PropTypes__default.bool,

      /**
       * Properties applied to the [`Paper`](/api/paper/) element.
       */
      PaperProps: PropTypes__default.object,

      /**
       * Properties applied to the [`Slide`](/api/slide/) element.
       */
      SlideProps: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })]),

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['permanent', 'persistent', 'temporary'])
    };
    var Drawer$1 = withStyles(styles$H, {
      name: 'MuiDrawer',
      flip: false,
      withTheme: true
    })(Drawer);

    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
    }

    var toArray = _toArray;

    var styles$I = function styles(theme) {
      var transition = {
        duration: theme.transitions.duration.shortest
      };
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          transition: theme.transitions.create(['margin'], transition),
          '&:before': {
            position: 'absolute',
            left: 0,
            top: -1,
            right: 0,
            height: 1,
            content: '""',
            opacity: 1,
            backgroundColor: theme.palette.divider,
            transition: theme.transitions.create(['opacity', 'background-color'], transition)
          },
          '&:first-child': {
            '&:before': {
              display: 'none'
            }
          },
          '&$expanded': {
            margin: '16px 0',
            '&:first-child': {
              marginTop: 0
            },
            '&:last-child': {
              marginBottom: 0
            },
            '&:before': {
              opacity: 0
            }
          },
          '&$expanded + &': {
            '&:before': {
              display: 'none'
            }
          },
          '&$disabled': {
            backgroundColor: theme.palette.action.disabledBackground
          }
        },

        /* Styles applied to the root element if `square={false}`. */
        rounded: {
          borderRadius: 0,
          '&:first-child': {
            borderTopLeftRadius: theme.shape.borderRadius,
            borderTopRightRadius: theme.shape.borderRadius
          },
          '&:last-child': {
            borderBottomLeftRadius: theme.shape.borderRadius,
            borderBottomRightRadius: theme.shape.borderRadius,
            // Fix a rendering issue on Edge
            '@supports (-ms-ime-align: auto)': {
              borderBottomLeftRadius: 0,
              borderBottomRightRadius: 0
            }
          }
        },

        /* Styles applied to the root element if `expanded={true}`. */
        expanded: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {}
      };
    };
    var ExpansionPanel = React__default.forwardRef(function ExpansionPanel(props, ref) {
      var childrenProp = props.children,
          classes = props.classes,
          className = props.className,
          _props$defaultExpande = props.defaultExpanded,
          defaultExpanded = _props$defaultExpande === void 0 ? false : _props$defaultExpande,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          expandedProp = props.expanded,
          onChange = props.onChange,
          _props$square = props.square,
          square = _props$square === void 0 ? false : _props$square,
          _props$TransitionComp = props.TransitionComponent,
          TransitionComponent = _props$TransitionComp === void 0 ? Collapse$1 : _props$TransitionComp,
          TransitionProps = props.TransitionProps,
          other = objectWithoutProperties(props, ["children", "classes", "className", "defaultExpanded", "disabled", "expanded", "onChange", "square", "TransitionComponent", "TransitionProps"]);

      var _React$useRef = React__default.useRef(expandedProp != null),
          isControlled = _React$useRef.current;

      var _React$useState = React__default.useState(defaultExpanded),
          _React$useState2 = slicedToArray(_React$useState, 2),
          expandedState = _React$useState2[0],
          setExpandedState = _React$useState2[1];

      var expanded = isControlled ? expandedProp : expandedState;

      var handleChange = function handleChange(event) {
        if (!isControlled) {
          setExpandedState(!expanded);
        }

        if (onChange) {
          onChange(event, !expanded);
        }
      };

      var _React$Children$toArr = React__default.Children.toArray(childrenProp),
          _React$Children$toArr2 = toArray(_React$Children$toArr),
          summary = _React$Children$toArr2[0],
          children = _React$Children$toArr2.slice(1);

      return React__default.createElement(Paper$1, _extends_1({
        className: clsx(classes.root, expanded && classes.expanded, disabled && classes.disabled, !square && classes.rounded, className),
        ref: ref,
        square: square
      }, other), React__default.cloneElement(summary, {
        disabled: disabled,
        expanded: expanded,
        onChange: handleChange
      }), React__default.createElement(TransitionComponent, _extends_1({
        in: expanded,
        timeout: "auto"
      }, TransitionProps), React__default.createElement("div", {
        "aria-labelledby": summary.props.id,
        id: summary.props['aria-controls'],
        role: "region"
      }, children)));
    });
    ExpansionPanel.propTypes = {
      /**
       * The content of the expansion panel.
       */
      children: chainPropTypes(PropTypes__default.node.isRequired, function (props) {
        var summary = React__default.Children.toArray(props.children)[0];

        if (summary.type === React__default.Fragment) {
          return new Error("Material-UI: the ExpansionPanel doesn't accept a Fragment as a child. " + 'Consider providing an array instead.');
        }

        if (!React__default.isValidElement(summary)) {
          return new Error('Material-UI: expected the first child of ExpansionPanel to be a valid element.');
        }

        return null;
      }),

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, expands the panel by default.
       */
      defaultExpanded: PropTypes__default.bool,

      /**
       * If `true`, the panel will be displayed in a disabled state.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, expands the panel, otherwise collapse it.
       * Setting this prop enables control over the panel.
       */
      expanded: PropTypes__default.bool,

      /**
       * Callback fired when the expand/collapse state is changed.
       *
       * @param {object} event The event source of the callback
       * @param {boolean} expanded The `expanded` state of the panel
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      square: PropTypes__default.bool,

      /**
       * The component used for the collapse effect.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    withStyles(styles$I, {
      name: 'MuiExpansionPanel'
    })(ExpansionPanel);

    var styles$J = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        alignItems: 'center',
        padding: 8,
        justifyContent: 'flex-end'
      },

      /* Styles applied to the root element if `disableSpacing={false}`. */
      spacing: {
        '& > * + *': {
          marginLeft: 8
        }
      }
    };
    var ExpansionPanelActions = React__default.forwardRef(function ExpansionPanelActions(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$disableSpacing = props.disableSpacing,
          disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,
          other = objectWithoutProperties(props, ["classes", "className", "disableSpacing"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, !disableSpacing && classes.spacing, className),
        ref: ref
      }, other));
    });
    ExpansionPanelActions.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the actions do not have additional margin.
       */
      disableSpacing: PropTypes__default.bool
    };
    withStyles(styles$J, {
      name: 'MuiExpansionPanelActions'
    })(ExpansionPanelActions);

    var styles$K = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        padding: '8px 24px 24px'
      }
    };
    var ExpansionPanelDetails = React__default.forwardRef(function ExpansionPanelDetails(props, ref) {
      var classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other));
    });
    ExpansionPanelDetails.propTypes = {
      /**
       * The content of the expansion panel details.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    withStyles(styles$K, {
      name: 'MuiExpansionPanelDetails'
    })(ExpansionPanelDetails);

    var styles$L = function styles(theme) {
      var transition = {
        duration: theme.transitions.duration.shortest
      };
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'flex',
          minHeight: 8 * 6,
          transition: theme.transitions.create(['min-height', 'background-color'], transition),
          padding: '0 24px 0 24px',
          '&:hover:not($disabled)': {
            cursor: 'pointer'
          },
          '&$expanded': {
            minHeight: 64
          },
          '&$focused': {
            backgroundColor: theme.palette.grey[300]
          },
          '&$disabled': {
            opacity: 0.38
          }
        },

        /* Styles applied to the root element, children wrapper element and `IconButton` component if `expanded={true}`. */
        expanded: {},

        /* Styles applied to the root and children wrapper elements when focused. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the children wrapper element. */
        content: {
          display: 'flex',
          flexGrow: 1,
          transition: theme.transitions.create(['margin'], transition),
          margin: '12px 0',
          '&$expanded': {
            margin: '20px 0'
          }
        },

        /* Styles applied to the `IconButton` component when `expandIcon` is supplied. */
        expandIcon: {
          transform: 'rotate(0deg)',
          transition: theme.transitions.create('transform', transition),
          '&:hover': {
            // Disable the hover effect for the IconButton,
            // because a hover effect should apply to the entire Expand button and
            // not only to the IconButton.
            backgroundColor: 'transparent'
          },
          '&$expanded': {
            transform: 'rotate(180deg)'
          }
        }
      };
    };
    var ExpansionPanelSummary = React__default.forwardRef(function ExpansionPanelSummary(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          expanded = props.expanded,
          expandIcon = props.expandIcon,
          IconButtonProps = props.IconButtonProps,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onClick = props.onClick,
          onFocusVisible = props.onFocusVisible,
          other = objectWithoutProperties(props, ["children", "classes", "className", "disabled", "expanded", "expandIcon", "IconButtonProps", "onBlur", "onChange", "onClick", "onFocusVisible"]);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          focusedState = _React$useState2[0],
          setFocusedState = _React$useState2[1];

      var handleFocusVisible = function handleFocusVisible(event) {
        setFocusedState(true);

        if (onFocusVisible) {
          onFocusVisible(event);
        }
      };

      var handleBlur = function handleBlur(event) {
        setFocusedState(false);

        if (onBlur) {
          onBlur(event);
        }
      };

      var handleChange = function handleChange(event) {
        if (onChange) {
          onChange(event);
        }

        if (onClick) {
          onClick(event);
        }
      };

      return React__default.createElement(ButtonBase$1, _extends_1({
        focusRipple: false,
        disableRipple: true,
        disabled: disabled,
        component: "div",
        "aria-expanded": expanded,
        className: clsx(classes.root, disabled && classes.disabled, expanded && classes.expanded, focusedState && classes.focused, className),
        onFocusVisible: handleFocusVisible,
        onBlur: handleBlur,
        onClick: handleChange,
        ref: ref
      }, other), React__default.createElement("div", {
        className: clsx(classes.content, expanded && classes.expanded)
      }, children), expandIcon && React__default.createElement(IconButton$1, _extends_1({
        disabled: disabled,
        className: clsx(classes.expandIcon, expanded && classes.expanded),
        edge: "end",
        component: "div",
        tabIndex: -1,
        "aria-hidden": true
      }, IconButtonProps), expandIcon));
    });
    ExpansionPanelSummary.propTypes = {
      /**
       * The content of the expansion panel summary.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       * If `true`, the summary will be displayed in a disabled state.
       */
      disabled: PropTypes__default.bool,

      /**
       * @ignore
       * If `true`, expands the summary, otherwise collapse it.
       */
      expanded: PropTypes__default.bool,

      /**
       * The icon to display as the expand indicator.
       */
      expandIcon: PropTypes__default.node,

      /**
       * Properties applied to the `IconButton` element wrapping the expand icon.
       */
      IconButtonProps: PropTypes__default.object,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * @ignore
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocusVisible: PropTypes__default.func
    };
    withStyles(styles$L, {
      name: 'MuiExpansionPanelSummary'
    })(ExpansionPanelSummary);

    var styles$M = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({}, theme.typography.button, {
          boxSizing: 'border-box',
          minHeight: 36,
          transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {
            duration: theme.transitions.duration.short
          }),
          borderRadius: '50%',
          padding: 0,
          minWidth: 0,
          width: 56,
          height: 56,
          boxShadow: theme.shadows[6],
          '&:active': {
            boxShadow: theme.shadows[12]
          },
          color: theme.palette.getContrastText(theme.palette.grey[300]),
          backgroundColor: theme.palette.grey[300],
          '&$focusVisible': {
            boxShadow: theme.shadows[6]
          },
          '&:hover': {
            backgroundColor: theme.palette.grey.A100,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.grey[300]
            },
            '&$disabled': {
              backgroundColor: theme.palette.action.disabledBackground
            },
            textDecoration: 'none'
          },
          '&$disabled': {
            color: theme.palette.action.disabled,
            boxShadow: theme.shadows[0],
            backgroundColor: theme.palette.action.disabledBackground
          }
        }),

        /* Styles applied to the span element that wraps the children. */
        label: {
          width: '100%',
          // assure the correct width for iOS Safari
          display: 'inherit',
          alignItems: 'inherit',
          justifyContent: 'inherit'
        },

        /* Styles applied to the root element if `color="primary"`. */
        primary: {
          color: theme.palette.primary.contrastText,
          backgroundColor: theme.palette.primary.main,
          '&:hover': {
            backgroundColor: theme.palette.primary.dark,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.primary.main
            }
          }
        },

        /* Styles applied to the root element if `color="secondary"`. */
        secondary: {
          color: theme.palette.secondary.contrastText,
          backgroundColor: theme.palette.secondary.main,
          '&:hover': {
            backgroundColor: theme.palette.secondary.dark,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: theme.palette.secondary.main
            }
          }
        },

        /* Styles applied to the root element if `variant="extended"`. */
        extended: {
          borderRadius: 48 / 2,
          padding: '0 16px',
          width: 'auto',
          minHeight: 'auto',
          minWidth: 48,
          height: 48,
          '&$sizeSmall': {
            width: 'auto',
            padding: '0 8px',
            borderRadius: 34 / 2,
            minWidth: 34,
            height: 34
          },
          '&$sizeMedium': {
            width: 'auto',
            padding: '0 16px',
            borderRadius: 40 / 2,
            minWidth: 40,
            height: 40
          }
        },

        /* Styles applied to the ButtonBase root element if the button is keyboard focused. */
        focusVisible: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `color="inherit"`. */
        colorInherit: {
          color: 'inherit'
        },

        /* Styles applied to the root element if `size="small"``. */
        sizeSmall: {
          width: 40,
          height: 40
        },

        /* Styles applied to the root element if `size="medium"``. */
        sizeMedium: {
          width: 48,
          height: 48
        }
      };
    };
    var Fab = React__default.forwardRef(function Fab(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$component = props.component,
          component = _props$component === void 0 ? 'button' : _props$component,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$disableFocusRi = props.disableFocusRipple,
          disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
          focusVisibleClassName = props.focusVisibleClassName,
          _props$size = props.size,
          size = _props$size === void 0 ? 'large' : _props$size,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'round' : _props$variant,
          other = objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"]);

      return React__default.createElement(ButtonBase$1, _extends_1({
        className: clsx(classes.root, variant === 'extended' && classes.extended, color === 'primary' && classes.primary, color === 'secondary' && classes.secondary, size !== 'large' && classes["size".concat(capitalize(size))], disabled && classes.disabled, color === 'inherit' && classes.colorInherit, className),
        component: component,
        disabled: disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        ref: ref
      }, other), React__default.createElement("span", {
        className: classes.label
      }, children));
    });
    Fab.propTypes = {
      /**
       * The content of the button.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'inherit', 'primary', 'secondary']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the button will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the  keyboard focus ripple will be disabled.
       * `disableRipple` must also be true.
       */
      disableFocusRipple: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * @ignore
       */
      focusVisibleClassName: PropTypes__default.string,

      /**
       * The URL to link to when the button is clicked.
       * If defined, an `a` element will be used as the root node.
       */
      href: PropTypes__default.string,

      /**
       * The size of the button.
       * `small` is equivalent to the dense button styling.
       */
      size: PropTypes__default.oneOf(['small', 'medium', 'large']),

      /**
       * @ignore
       */
      type: PropTypes__default.string,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['round', 'extended'])
    };
    withStyles(styles$M, {
      name: 'MuiFab'
    })(Fab);

    function formControlState(_ref) {
      var props = _ref.props,
          states = _ref.states,
          muiFormControl = _ref.muiFormControl;
      return states.reduce(function (acc, state) {
        acc[state] = props[state];

        if (muiFormControl) {
          if (typeof props[state] === 'undefined') {
            acc[state] = muiFormControl[state];
          }
        }

        return acc;
      }, {});
    }

    function getStyleValue(computedStyle, property) {
      return parseInt(computedStyle[property], 10) || 0;
    }

    var useEnhancedEffect$3 = typeof window !== 'undefined' ? React__default.useLayoutEffect : React__default.useEffect;
    var styles$N = {
      /* Styles applied to the shadow textarea element. */
      shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: 'hidden',
        // Remove from the content flow
        position: 'absolute',
        // Ignore the scrollbar width
        overflow: 'hidden',
        height: '0'
      }
    };
    /**
     * @ignore - internal component.
     *
     * To make public in v4+.
     */

    var Textarea = React__default.forwardRef(function Textarea(props, ref) {
      var onChange = props.onChange,
          rows = props.rows,
          rowsMax = props.rowsMax,
          style = props.style,
          value = props.value,
          other = objectWithoutProperties(props, ["onChange", "rows", "rowsMax", "style", "value"]);

      var _React$useRef = React__default.useRef(value != null),
          isControlled = _React$useRef.current;

      var inputRef = React__default.useRef(null);

      var _React$useState = React__default.useState({}),
          _React$useState2 = slicedToArray(_React$useState, 2),
          state = _React$useState2[0],
          setState = _React$useState2[1];

      var shadowRef = React__default.useRef(null);
      var handleRef = useForkRef(ref, inputRef);
      var syncHeight = React__default.useCallback(function () {
        var input = inputRef.current;
        var inputShallow = shadowRef.current;
        var computedStyle = window.getComputedStyle(input);
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || 'x'; // The height of the inner content

        var innerHeight = inputShallow.scrollHeight;
        var boxSizing = computedStyle['box-sizing']; // Measure height of a textarea with a single row

        inputShallow.value = 'x';
        var singleRowHeight = inputShallow.scrollHeight; // The height of the outer content

        var outerHeight = innerHeight;

        if (rows != null) {
          outerHeight = Math.max(Number(rows) * singleRowHeight, outerHeight);
        }

        if (rowsMax != null) {
          outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);
        }

        outerHeight = Math.max(outerHeight, singleRowHeight);

        if (boxSizing === 'content-box') {
          outerHeight -= getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
        } else if (boxSizing === 'border-box') {
          outerHeight += getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width');
        }

        setState(function (prevState) {
          // Need a large enough different to update the height.
          // This prevents infinite rendering loop.
          if (innerHeight > 0 && Math.abs((prevState.innerHeight || 0) - innerHeight) > 1) {
            return {
              innerHeight: innerHeight,
              outerHeight: outerHeight
            };
          }

          return prevState;
        });
      }, [setState, rows, rowsMax, props.placeholder]);
      React__default.useEffect(function () {
        var handleResize = debounce_1(function () {
          syncHeight();
        }, 166); // Corresponds to 10 frames at 60 Hz.

        window.addEventListener('resize', handleResize);
        return function () {
          handleResize.clear();
          window.removeEventListener('resize', handleResize);
        };
      }, [syncHeight]);
      useEnhancedEffect$3(function () {
        syncHeight();
      });

      var handleChange = function handleChange(event) {
        if (!isControlled) {
          syncHeight();
        }

        if (onChange) {
          onChange(event);
        }
      };

      return React__default.createElement(React__default.Fragment, null, React__default.createElement("textarea", _extends_1({
        value: value,
        onChange: handleChange,
        ref: handleRef,
        style: _extends_1({
          height: state.outerHeight,
          overflow: state.outerHeight === state.innerHeight ? 'hidden' : null
        }, style)
      }, other)), React__default.createElement("textarea", {
        "aria-hidden": true,
        className: props.className,
        readOnly: true,
        ref: shadowRef,
        tabIndex: -1,
        style: _extends_1({}, styles$N.shadow, style)
      }));
    });
    Textarea.propTypes = {
      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      placeholder: PropTypes__default.string,

      /**
       * Minimum umber of rows to display.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      value: PropTypes__default.any
    };

    // Supports determination of isControlled().
    // Controlled input accepts its current value as a prop.
    //
    // @see https://facebook.github.io/react/docs/forms.html#controlled-components
    // @param value
    // @returns {boolean} true if string (including '') or number (including zero)
    function hasValue(value) {
      return value != null && !(Array.isArray(value) && value.length === 0);
    } // Determine if field is empty or filled.
    // Response determines if label is presented above field or as placeholder.
    //
    // @param obj
    // @param SSR
    // @returns {boolean} False when not present or empty string.
    //                    True when any number or string with length.

    function isFilled(obj) {
      var SSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
    } // Determine if an Input is adorned on start.
    // It's corresponding to the left with LTR.
    //
    // @param obj
    // @returns {boolean} False when no adornments.
    //                    True when adorned at the start.

    function isAdornedStart(obj) {
      return obj.startAdornment;
    }

    var styles$O = function styles(theme) {
      var light = theme.palette.type === 'light';
      var placeholder = {
        color: 'currentColor',
        opacity: light ? 0.42 : 0.5,
        transition: theme.transitions.create('opacity', {
          duration: theme.transitions.duration.shorter
        })
      };
      var placeholderHidden = {
        opacity: '0 !important'
      };
      var placeholderVisible = {
        opacity: light ? 0.42 : 0.5
      };
      return {
        /* Styles applied to the root element. */
        root: {
          // Mimics the default input display property used by browsers for an input.
          fontFamily: theme.typography.fontFamily,
          color: theme.palette.text.primary,
          fontSize: theme.typography.pxToRem(16),
          lineHeight: '1.1875em',
          // Reset (19px), match the native input line-height
          boxSizing: 'border-box',
          // Prevent padding issue with fullWidth.
          cursor: 'text',
          display: 'inline-flex',
          alignItems: 'center',
          '&$disabled': {
            color: theme.palette.text.disabled,
            cursor: 'default'
          }
        },

        /* Styles applied to the root element if the component is a descendant of `FormControl`. */
        formControl: {},

        /* Styles applied to the root element if the component is focused. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `startAdornment` is provided. */
        adornedStart: {},

        /* Styles applied to the root element if `endAdornment` is provided. */
        adornedEnd: {},

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the `input` element if `margin="dense"`. */
        marginDense: {},

        /* Styles applied to the root element if `multiline={true}`. */
        multiline: {
          padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px")
        },

        /* Styles applied to the root element if `fullWidth={true}`. */
        fullWidth: {
          width: '100%'
        },

        /* Styles applied to the `input` element. */
        input: {
          font: 'inherit',
          color: 'currentColor',
          padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
          border: 0,
          boxSizing: 'content-box',
          background: 'none',
          height: '1.1875em',
          // Reset (19px), match the native input line-height
          margin: 0,
          // Reset for Safari
          // Remove grey highlight
          WebkitTapHighlightColor: 'transparent',
          display: 'block',
          // Make the flex item shrink with Firefox
          minWidth: 0,
          width: '100%',
          // Fix IE 11 width issue
          '&::-webkit-input-placeholder': placeholder,
          '&::-moz-placeholder': placeholder,
          // Firefox 19+
          '&:-ms-input-placeholder': placeholder,
          // IE 11
          '&::-ms-input-placeholder': placeholder,
          // Edge
          '&:focus': {
            outline: 0
          },
          // Reset Firefox invalid required input style
          '&:invalid': {
            boxShadow: 'none'
          },
          '&::-webkit-search-decoration': {
            // Remove the padding when type=search.
            '-webkit-appearance': 'none'
          },
          // Show and hide the placeholder logic
          'label[data-shrink=false] + $formControl &': {
            '&::-webkit-input-placeholder': placeholderHidden,
            '&::-moz-placeholder': placeholderHidden,
            // Firefox 19+
            '&:-ms-input-placeholder': placeholderHidden,
            // IE 11
            '&::-ms-input-placeholder': placeholderHidden,
            // Edge
            '&:focus::-webkit-input-placeholder': placeholderVisible,
            '&:focus::-moz-placeholder': placeholderVisible,
            // Firefox 19+
            '&:focus:-ms-input-placeholder': placeholderVisible,
            // IE 11
            '&:focus::-ms-input-placeholder': placeholderVisible // Edge

          },
          '&$disabled': {
            opacity: 1 // Reset iOS opacity

          }
        },

        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {
          paddingTop: 4 - 1
        },

        /* Styles applied to the `input` element if `multiline={true}`. */
        inputMultiline: {
          height: 'auto',
          resize: 'none',
          padding: 0
        },

        /* Styles applied to the `input` element if `type="search"`. */
        inputTypeSearch: {
          // Improve type search style.
          '-moz-appearance': 'textfield',
          '-webkit-appearance': 'textfield'
        },

        /* Styles applied to the `input` element if `startAdornment` is provided. */
        inputAdornedStart: {},

        /* Styles applied to the `input` element if `endAdornment` is provided. */
        inputAdornedEnd: {}
      };
    };
    /**
     * `InputBase` contains as few styles as possible.
     * It aims to be a simple building block for creating an input.
     * It contains a load of style reset and some state logic.
     */

    var InputBase = React__default.forwardRef(function InputBase(props, ref) {
      var ariaDescribedby = props['aria-describedby'],
          autoComplete = props.autoComplete,
          autoFocus = props.autoFocus,
          classes = props.classes,
          classNameProp = props.className,
          defaultValue = props.defaultValue,
          disabled = props.disabled,
          endAdornment = props.endAdornment,
          error = props.error,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          id = props.id,
          _props$inputComponent = props.inputComponent,
          inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
          _props$inputProps = props.inputProps;
      _props$inputProps = _props$inputProps === void 0 ? {} : _props$inputProps;

      var inputPropsClassName = _props$inputProps.className,
          inputPropsProp = objectWithoutProperties(_props$inputProps, ["className"]),
          inputRefProp = props.inputRef,
          margin = props.margin,
          _props$multiline = props.multiline,
          multiline = _props$multiline === void 0 ? false : _props$multiline,
          name = props.name,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onClick = props.onClick,
          onEmpty = props.onEmpty,
          onFilled = props.onFilled,
          onFocus = props.onFocus,
          onKeyDown = props.onKeyDown,
          onKeyUp = props.onKeyUp,
          placeholder = props.placeholder,
          readOnly = props.readOnly,
          renderPrefix = props.renderPrefix,
          rows = props.rows,
          rowsMax = props.rowsMax,
          startAdornment = props.startAdornment,
          _props$type = props.type,
          type = _props$type === void 0 ? 'text' : _props$type,
          value = props.value,
          other = objectWithoutProperties(props, ["aria-describedby", "autoComplete", "autoFocus", "classes", "className", "defaultValue", "disabled", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "multiline", "name", "onBlur", "onChange", "onClick", "onEmpty", "onFilled", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderPrefix", "rows", "rowsMax", "startAdornment", "type", "value"]);

      var _React$useRef = React__default.useRef(value != null),
          isControlled = _React$useRef.current;

      var inputRef = React__default.useRef();
      var handleInputRefWarning = React__default.useCallback(function (instance) {
        warning_1(!instance || instance instanceof HTMLInputElement || instance.focus, ['Material-UI: you have provided a `inputComponent` to the input component', 'that does not correctly handle the `inputRef` property.', 'Make sure the `inputRef` property is called with a HTMLInputElement.'].join('\n'));
      }, []);
      var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);
      var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);
      var handleInputRef = useForkRef(inputRef, handleInputRefProp);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          focused = _React$useState2[0],
          setFocused = _React$useState2[1];

      var muiFormControl = React__default.useContext(FormControlContext);
      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['disabled', 'error', 'margin', 'required', 'filled']
      });
      fcs.focused = muiFormControl ? muiFormControl.focused : focused; // The blur won't fire when the disabled state is set on a focused input.
      // We need to book keep the focused state manually.

      React__default.useEffect(function () {
        if (!muiFormControl && disabled && focused) {
          setFocused(false);

          if (onBlur) {
            onBlur();
          }
        }
      }, [muiFormControl, disabled, focused, onBlur]);
      var checkDirty = React__default.useCallback(function (obj) {
        if (isFilled(obj)) {
          if (muiFormControl && muiFormControl.onFilled) {
            muiFormControl.onFilled();
          }

          if (onFilled) {
            onFilled();
          }

          return;
        }

        if (muiFormControl && muiFormControl.onEmpty) {
          muiFormControl.onEmpty();
        }

        if (onEmpty) {
          onEmpty();
        }
      }, [muiFormControl, onEmpty, onFilled]);
      React__default.useEffect(function () {
        if (isControlled) {
          checkDirty({
            value: value
          });
        }
      }, [value, checkDirty, isControlled]);
      React__default.useEffect(function () {
        if (!isControlled) {
          checkDirty(inputRef.current);
        }
      }, [checkDirty, isControlled]);

      var handleFocus = function handleFocus(event) {
        // Fix a bug with IE 11 where the focus/blur events are triggered
        // while the input is disabled.
        if (fcs.disabled) {
          event.stopPropagation();
          return;
        }

        if (onFocus) {
          onFocus(event);
        }

        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        } else {
          setFocused(true);
        }
      };

      var handleBlur = function handleBlur(event) {
        if (onBlur) {
          onBlur(event);
        }

        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        } else {
          setFocused(false);
        }
      };

      var handleChange = function handleChange(event) {
        if (!isControlled) {
          checkDirty({
            value: (event.target || inputRef.current).value
          });
        } // Perform in the willUpdate


        if (onChange) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          onChange.apply(void 0, [event].concat(args));
        }
      };

      var handleClick = function handleClick(event) {
        if (inputRef.current && event.currentTarget === event.target) {
          inputRef.current.focus();
        }

        if (onClick) {
          onClick(event);
        }
      };

      var InputComponent = inputComponent;

      var inputProps = _extends_1({}, inputPropsProp, {
        ref: handleInputRef
      });

      if (typeof InputComponent !== 'string') {
        inputProps = _extends_1({
          // Rename ref to inputRef as we don't know the
          // provided `inputComponent` structure.
          inputRef: handleInputRef,
          type: type
        }, inputProps, {
          ref: null
        });
      } else if (multiline) {
        if (rows && !rowsMax) {
          InputComponent = 'textarea';
        } else {
          inputProps = _extends_1({
            rows: rows,
            rowsMax: rowsMax
          }, inputProps);
          InputComponent = Textarea;
        }
      } else {
        inputProps = _extends_1({
          type: type
        }, inputProps);
      }

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, fcs.margin === 'dense' && classes.marginDense, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, classNameProp),
        onClick: handleClick,
        ref: ref
      }, other), renderPrefix ? renderPrefix(_extends_1({}, fcs, {
        startAdornment: startAdornment
      })) : null, startAdornment, React__default.createElement(FormControlContext.Provider, {
        value: null
      }, React__default.createElement(InputComponent, _extends_1({
        "aria-invalid": fcs.error,
        "aria-describedby": ariaDescribedby,
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        className: clsx(classes.input, fcs.disabled && classes.disabled, type === 'search' && classes.inputTypeSearch, multiline && classes.inputMultiline, fcs.margin === 'dense' && classes.inputMarginDense, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, inputPropsClassName),
        defaultValue: defaultValue,
        disabled: fcs.disabled,
        id: id,
        name: name,
        onBlur: handleBlur,
        onChange: handleChange,
        onFocus: handleFocus,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        placeholder: placeholder,
        readOnly: readOnly,
        required: fcs.required,
        rows: rows,
        value: value
      }, inputProps))), endAdornment);
    });
    InputBase.propTypes = {
      /**
       * @ignore
       */
      'aria-describedby': PropTypes__default.string,

      /**
       * This property helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: PropTypes__default.string,

      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the wrapper element.
       */
      className: PropTypes__default.string,

      /**
       * The default `input` element value, useful when not controlling the component.
       */
      defaultValue: PropTypes__default.any,

      /**
       * If `true`, the `input` element will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * End `InputAdornment` for this component.
       */
      endAdornment: PropTypes__default.node,

      /**
       * If `true`, the input will indicate an error. This is normally obtained via context from
       * FormControl.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the input will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * The component used for the `input` element.
       * Either a string to use a DOM element or a component.
       */
      inputComponent: PropTypes__default.elementType,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense', 'none']),

      /**
       * If `true`, a textarea element will be rendered.
       */
      multiline: PropTypes__default.bool,

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * Callback fired when the value is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * @ignore
       */
      onEmpty: PropTypes__default.func,

      /**
       * @ignore
       */
      onFilled: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocus: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyDown: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyUp: PropTypes__default.func,

      /**
       * The short hint displayed in the input before the user enters a value.
       */
      placeholder: PropTypes__default.string,

      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: PropTypes__default.bool,

      /**
       * @ignore
       */
      renderPrefix: PropTypes__default.func,

      /**
       * If `true`, the `input` element will be required.
       */
      required: PropTypes__default.bool,

      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Start `InputAdornment` for this component.
       */
      startAdornment: PropTypes__default.node,

      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       */
      type: PropTypes__default.string,

      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: PropTypes__default.any
    };
    var InputBase$1 = withStyles(styles$O, {
      name: 'MuiInputBase'
    })(InputBase);

    var styles$P = function styles(theme) {
      var light = theme.palette.type === 'light';
      var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
      var backgroundColor = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)';
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          backgroundColor: backgroundColor,
          borderTopLeftRadius: theme.shape.borderRadius,
          borderTopRightRadius: theme.shape.borderRadius,
          transition: theme.transitions.create('background-color', {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          '&:hover': {
            backgroundColor: light ? 'rgba(0, 0, 0, 0.13)' : 'rgba(255, 255, 255, 0.13)',
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: backgroundColor
            }
          },
          '&$focused': {
            backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)'
          },
          '&$disabled': {
            backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
          }
        },

        /* Styles applied to the root element if `disableUnderline={false}`. */
        underline: {
          '&:after': {
            borderBottom: "2px solid ".concat(theme.palette.primary[light ? 'dark' : 'light']),
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
            content: '""',
            position: 'absolute',
            right: 0,
            transform: 'scaleX(0)',
            transition: theme.transitions.create('transform', {
              duration: theme.transitions.duration.shorter,
              easing: theme.transitions.easing.easeOut
            }),
            pointerEvents: 'none' // Transparent to the hover style.

          },
          '&$focused:after': {
            transform: 'scaleX(1)'
          },
          '&$error:after': {
            borderBottomColor: theme.palette.error.main,
            transform: 'scaleX(1)' // error is always underlined in red

          },
          '&:before': {
            borderBottom: "1px solid ".concat(bottomLineColor),
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
            content: '"\\00a0"',
            position: 'absolute',
            right: 0,
            transition: theme.transitions.create('border-bottom-color', {
              duration: theme.transitions.duration.shorter
            }),
            pointerEvents: 'none' // Transparent to the hover style.

          },
          '&:hover:before': {
            borderBottom: "1px solid ".concat(theme.palette.text.primary)
          },
          '&$disabled:before': {
            borderBottomStyle: 'dotted'
          }
        },

        /* Styles applied to the root element if the component is focused. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `startAdornment` is provided. */
        adornedStart: {
          paddingLeft: 12
        },

        /* Styles applied to the root element if `endAdornment` is provided. */
        adornedEnd: {
          paddingRight: 12
        },

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `multiline={true}`. */
        multiline: {
          padding: '27px 12px 10px'
        },

        /* Styles applied to the `input` element. */
        input: {
          padding: '27px 12px 10px'
        },

        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {
          paddingTop: 24,
          paddingBottom: 6
        },

        /* Styles applied to the `input` element if `multiline={true}`. */
        inputMultiline: {
          padding: 0
        },

        /* Styles applied to the `input` element if `startAdornment` is provided. */
        inputAdornedStart: {
          paddingLeft: 0
        },

        /* Styles applied to the `input` element if `endAdornment` is provided. */
        inputAdornedEnd: {
          paddingRight: 0
        }
      };
    };
    var FilledInput = React__default.forwardRef(function FilledInput(props, ref) {
      var disableUnderline = props.disableUnderline,
          classes = props.classes,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$inputComponent = props.inputComponent,
          inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
          _props$multiline = props.multiline,
          multiline = _props$multiline === void 0 ? false : _props$multiline,
          _props$type = props.type,
          type = _props$type === void 0 ? 'text' : _props$type,
          other = objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

      return React__default.createElement(InputBase$1, _extends_1({
        classes: _extends_1({}, classes, {
          root: clsx(classes.root, !disableUnderline && classes.underline),
          underline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
      }, other));
    });
    FilledInput.propTypes = {
      /**
       * This property helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: PropTypes__default.string,

      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the wrapper element.
       */
      className: PropTypes__default.string,

      /**
       * The default `input` element value, useful when not controlling the component.
       */
      defaultValue: PropTypes__default.any,

      /**
       * If `true`, the `input` element will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the input will not have an underline.
       */
      disableUnderline: PropTypes__default.bool,

      /**
       * End `InputAdornment` for this component.
       */
      endAdornment: PropTypes__default.node,

      /**
       * If `true`, the input will indicate an error. This is normally obtained via context from
       * FormControl.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the input will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * The component used for the native input.
       * Either a string to use a DOM element or a component.
       */
      inputComponent: PropTypes__default.elementType,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense', 'none']),

      /**
       * If `true`, a textarea element will be rendered.
       */
      multiline: PropTypes__default.bool,

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * Callback fired when the value is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * The short hint displayed in the input before the user enters a value.
       */
      placeholder: PropTypes__default.string,

      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: PropTypes__default.bool,

      /**
       * If `true`, the `input` element will be required.
       */
      required: PropTypes__default.bool,

      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Start `InputAdornment` for this component.
       */
      startAdornment: PropTypes__default.node,

      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       */
      type: PropTypes__default.string,

      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: PropTypes__default.any
    };
    FilledInput.muiName = 'Input';
    var FilledInput$1 = withStyles(styles$P, {
      name: 'MuiFilledInput'
    })(FilledInput);

    var styles$Q = {
      /* Styles applied to the root element. */
      root: {
        display: 'inline-flex',
        flexDirection: 'column',
        position: 'relative',
        // Reset fieldset default style.
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: 'top' // Fix alignment issue on Safari.

      },

      /* Styles applied to the root element if `margin="normal"`. */
      marginNormal: {
        marginTop: 16,
        marginBottom: 8
      },

      /* Styles applied to the root element if `margin="dense"`. */
      marginDense: {
        marginTop: 8,
        marginBottom: 4
      },

      /* Styles applied to the root element if `fullWidth={true}`. */
      fullWidth: {
        width: '100%'
      }
    };
    /**
     * Provides context such as filled/focused/error/required for form inputs.
     * Relying on the context provides high flexibility and ensures that the state always stays
     * consistent across the children of the `FormControl`.
     * This context is used by the following components:
     *  - FormLabel
     *  - FormHelperText
     *  - Input
     *  - InputLabel
     *
     * Only one input can be used within a FormControl.
     */

    var FormControl = React__default.forwardRef(function FormControl(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$error = props.error,
          error = _props$error === void 0 ? false : _props$error,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$margin = props.margin,
          margin = _props$margin === void 0 ? 'none' : _props$margin,
          _props$required = props.required,
          required = _props$required === void 0 ? false : _props$required,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'standard' : _props$variant,
          other = objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "fullWidth", "margin", "required", "variant"]);

      var _React$useState = React__default.useState(function () {
        // We need to iterate through the children and find the Input in order
        // to fully support server-side rendering.
        var initialAdornedStart = false;

        if (children) {
          React__default.Children.forEach(children, function (child) {
            if (!isMuiElement(child, ['Input', 'Select'])) {
              return;
            }

            var input = isMuiElement(child, ['Select']) ? child.props.input : child;

            if (input && isAdornedStart(input.props)) {
              initialAdornedStart = true;
            }
          });
        }

        return initialAdornedStart;
      }),
          _React$useState2 = slicedToArray(_React$useState, 1),
          adornedStart = _React$useState2[0];

      var _React$useState3 = React__default.useState(function () {
        // We need to iterate through the children and find the Input in order
        // to fully support server-side rendering.
        var initialFilled = false;

        if (children) {
          React__default.Children.forEach(children, function (child) {
            if (!isMuiElement(child, ['Input', 'Select'])) {
              return;
            }

            if (isFilled(child.props, true)) {
              initialFilled = true;
            }
          });
        }

        return initialFilled;
      }),
          _React$useState4 = slicedToArray(_React$useState3, 2),
          filled = _React$useState4[0],
          setFilled = _React$useState4[1];

      var _React$useState5 = React__default.useState(false),
          _React$useState6 = slicedToArray(_React$useState5, 2),
          focused = _React$useState6[0],
          setFocused = _React$useState6[1];

      if (disabled && focused) {
        setFocused(false);
      }

      var handleFocus = function handleFocus() {
        setFocused(true);
      };

      var handleBlur = function handleBlur() {
        setFocused(false);
      };

      var handleDirty = function handleDirty() {
        if (!filled) {
          setFilled(true);
        }
      };

      var handleClean = function handleClean() {
        if (filled) {
          setFilled(false);
        }
      };

      var childContext = {
        adornedStart: adornedStart,
        disabled: disabled,
        error: error,
        filled: filled,
        focused: focused,
        margin: margin,
        onBlur: handleBlur,
        onEmpty: handleClean,
        onFilled: handleDirty,
        onFocus: handleFocus,
        required: required,
        variant: variant
      };
      return React__default.createElement(FormControlContext.Provider, {
        value: childContext
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, margin !== 'none' && classes["margin".concat(capitalize(margin))], fullWidth && classes.fullWidth, className),
        ref: ref
      }, other), children));
    });
    FormControl.propTypes = {
      /**
       * The contents of the form control.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the label, input and helper text should be displayed in a disabled state.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the label should be displayed in an error state.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the component will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
       */
      margin: PropTypes__default.oneOf(['none', 'dense', 'normal']),

      /**
       * If `true`, the label will indicate that the input is required.
       */
      required: PropTypes__default.bool,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    var FormControl$1 = withStyles(styles$Q, {
      name: 'MuiFormControl'
    })(FormControl);

    var styles$R = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'inline-flex',
          alignItems: 'center',
          cursor: 'pointer',
          // For correct alignment with the text.
          verticalAlign: 'middle',
          // Remove grey highlight
          WebkitTapHighlightColor: 'transparent',
          marginLeft: -11,
          marginRight: 16,
          // used for row presentation of radio/checkbox
          '&$disabled': {
            cursor: 'default'
          }
        },

        /* Styles applied to the root element if `labelPlacement="start"`. */
        labelPlacementStart: {
          flexDirection: 'row-reverse',
          marginLeft: 16,
          // used for row presentation of radio/checkbox
          marginRight: -11
        },

        /* Styles applied to the root element if `labelPlacement="top"`. */
        labelPlacementTop: {
          flexDirection: 'column-reverse',
          marginLeft: 16
        },

        /* Styles applied to the root element if `labelPlacement="bottom"`. */
        labelPlacementBottom: {
          flexDirection: 'column',
          marginLeft: 16
        },

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the label's Typography component. */
        label: {
          '&$disabled': {
            color: theme.palette.text.disabled
          }
        }
      };
    };
    /**
     * Drop in replacement of the `Radio`, `Switch` and `Checkbox` component.
     * Use this component if you want to display an extra label.
     */

    var FormControlLabel = React__default.forwardRef(function FormControlLabel(props, ref) {
      var checked = props.checked,
          classes = props.classes,
          classNameProp = props.className,
          control = props.control,
          disabledProp = props.disabled,
          inputRef = props.inputRef,
          label = props.label,
          _props$labelPlacement = props.labelPlacement,
          labelPlacement = _props$labelPlacement === void 0 ? 'end' : _props$labelPlacement,
          muiFormControl = props.muiFormControl,
          name = props.name,
          onChange = props.onChange,
          value = props.value,
          other = objectWithoutProperties(props, ["checked", "classes", "className", "control", "disabled", "inputRef", "label", "labelPlacement", "muiFormControl", "name", "onChange", "value"]);

      var disabled = disabledProp;

      if (typeof disabled === 'undefined' && typeof control.props.disabled !== 'undefined') {
        disabled = control.props.disabled;
      }

      if (typeof disabled === 'undefined' && muiFormControl) {
        disabled = muiFormControl.disabled;
      }

      var controlProps = {
        disabled: disabled
      };
      ['checked', 'name', 'onChange', 'value', 'inputRef'].forEach(function (key) {
        if (typeof control.props[key] === 'undefined' && typeof props[key] !== 'undefined') {
          controlProps[key] = props[key];
        }
      });
      return React__default.createElement("label", _extends_1({
        className: clsx(classes.root, labelPlacement !== 'end' && classes["labelPlacement".concat(capitalize(labelPlacement))], disabled && classes.disabled, classNameProp),
        ref: ref
      }, other), React__default.cloneElement(control, controlProps), React__default.createElement(Typography$1, {
        component: "span",
        className: clsx(classes.label, disabled && classes.disabled)
      }, label));
    });
    FormControlLabel.propTypes = {
      /**
       * If `true`, the component appears selected.
       */
      checked: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * A control element. For instance, it can be be a `Radio`, a `Switch` or a `Checkbox`.
       */
      control: PropTypes__default.element,

      /**
       * If `true`, the control will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * The text to be used in an enclosing label element.
       */
      label: PropTypes__default.node,

      /**
       * The position of the label.
       */
      labelPlacement: PropTypes__default.oneOf(['end', 'start', 'top', 'bottom']),

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /*
       * @ignore
       */
      name: PropTypes__default.string,

      /**
       * Callback fired when the state is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.checked`.
       * @param {boolean} checked The `checked` value of the switch
       */
      onChange: PropTypes__default.func,

      /**
       * The value of the component.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$R, {
      name: 'MuiFormControlLabel'
    })(withFormControlContext(FormControlLabel));

    var styles$S = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        flexDirection: 'column',
        flexWrap: 'wrap'
      },

      /* Styles applied to the root element if `row={true}`. */
      row: {
        flexDirection: 'row'
      }
    };
    /**
     * `FormGroup` wraps controls such as `Checkbox` and `Switch`.
     * It provides compact row layout.
     * For the `Radio`, you should be using the `RadioGroup` component instead of this one.
     */

    var FormGroup = React__default.forwardRef(function FormGroup(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$row = props.row,
          row = _props$row === void 0 ? false : _props$row,
          other = objectWithoutProperties(props, ["classes", "className", "row"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, row && classes.row, className),
        ref: ref
      }, other));
    });
    FormGroup.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Display group of elements in a compact row.
       */
      row: PropTypes__default.bool
    };
    var FormGroup$1 = withStyles(styles$S, {
      name: 'MuiFormGroup'
    })(FormGroup);

    var styles$T = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({
          color: theme.palette.text.secondary
        }, theme.typography.caption, {
          textAlign: 'left',
          marginTop: 8,
          lineHeight: '1em',
          minHeight: '1em',
          margin: 0,
          '&$disabled': {
            color: theme.palette.text.disabled
          },
          '&$error': {
            color: theme.palette.error.main
          }
        }),

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `margin="dense"`. */
        marginDense: {
          marginTop: 4
        },

        /* Styles applied to the root element if `variant="filled"` or `variant="outlined"`. */
        contained: {
          margin: '8px 12px 0'
        },

        /* Styles applied to the root element if `focused={true}`. */
        focused: {},

        /* Styles applied to the root element if `filled={true}`. */
        filled: {},

        /* Styles applied to the root element if `required={true}`. */
        required: {}
      };
    };
    var FormHelperText = React__default.forwardRef(function FormHelperText(props, ref) {
      var classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'p' : _props$component,
          disabled = props.disabled,
          error = props.error,
          filled = props.filled,
          focused = props.focused,
          margin = props.margin,
          muiFormControl = props.muiFormControl,
          required = props.required,
          variant = props.variant,
          other = objectWithoutProperties(props, ["classes", "className", "component", "disabled", "error", "filled", "focused", "margin", "muiFormControl", "required", "variant"]);

      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['variant', 'margin', 'disabled', 'error', 'filled', 'focused', 'required']
      });
      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, (fcs.variant === 'filled' || fcs.variant === 'outlined') && classes.contained, fcs.margin === 'dense' && classes.marginDense, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, classNameProp),
        ref: ref
      }, other));
    });
    FormHelperText.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the helper text should be displayed in a disabled state.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, helper text should be displayed in an error state.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the helper text should use filled classes key.
       */
      filled: PropTypes__default.bool,

      /**
       * If `true`, the helper text should use focused classes key.
       */
      focused: PropTypes__default.bool,

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense']),

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /**
       * If `true`, the helper text should use required classes key.
       */
      required: PropTypes__default.bool,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    var FormHelperText$1 = withStyles(styles$T, {
      name: 'MuiFormHelperText'
    })(withFormControlContext(FormHelperText));

    var styles$U = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({
          color: theme.palette.text.secondary
        }, theme.typography.body1, {
          lineHeight: 1,
          padding: 0,
          '&$focused': {
            color: theme.palette.primary[theme.palette.type === 'light' ? 'dark' : 'light']
          },
          '&$disabled': {
            color: theme.palette.text.disabled
          },
          '&$error': {
            color: theme.palette.error.main
          }
        }),

        /* Styles applied to the root element if `focused={true}`. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `filled={true}`. */
        filled: {},

        /* Styles applied to the root element if `required={true}`. */
        required: {},

        /* Styles applied to the asterisk element. */
        asterisk: {
          '&$error': {
            color: theme.palette.error.main
          }
        }
      };
    };
    var FormLabel = React__default.forwardRef(function FormLabel(props, ref) {
      var children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'label' : _props$component,
          disabled = props.disabled,
          error = props.error,
          filled = props.filled,
          focused = props.focused,
          muiFormControl = props.muiFormControl,
          required = props.required,
          other = objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "filled", "focused", "muiFormControl", "required"]);

      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['required', 'focused', 'disabled', 'error', 'filled']
      });
      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, classNameProp),
        ref: ref
      }, other), children, fcs.required && React__default.createElement("span", {
        className: clsx(classes.asterisk, fcs.error && classes.error)
      }, "\u2009", '*'));
    });
    FormLabel.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the label should be displayed in a disabled state.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the label should be displayed in an error state.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the label should use filled classes key.
       */
      filled: PropTypes__default.bool,

      /**
       * If `true`, the input of this label is focused (used by `FormGroup` components).
       */
      focused: PropTypes__default.bool,

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /**
       * If `true`, the label will indicate that the input is required.
       */
      required: PropTypes__default.bool
    };
    var FormLabel$1 = withStyles(styles$U, {
      name: 'MuiFormLabel'
    })(withFormControlContext(FormLabel));

    var SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    var GRID_SIZES = ['auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

    function generateGrid(globalStyles, theme, breakpoint) {
      var styles = {};
      GRID_SIZES.forEach(function (size) {
        var key = "grid-".concat(breakpoint, "-").concat(size);

        if (size === true) {
          // For the auto layouting
          styles[key] = {
            flexBasis: 0,
            flexGrow: 1,
            maxWidth: '100%'
          };
          return;
        }

        if (size === 'auto') {
          styles[key] = {
            flexBasis: 'auto',
            flexGrow: 0,
            maxWidth: 'none'
          };
          return;
        } // Keep 7 significant numbers.


        var width = "".concat(Math.round(size / 12 * 10e7) / 10e5, "%"); // Close to the bootstrap implementation:
        // https://github.com/twbs/bootstrap/blob/8fccaa2439e97ec72a4b7dc42ccc1f649790adb0/scss/mixins/_grid.scss#L41

        styles[key] = {
          flexBasis: width,
          flexGrow: 0,
          maxWidth: width
        };
      }); // No need for a media query for the first size.

      if (breakpoint === 'xs') {
        Object.assign(globalStyles, styles);
      } else {
        globalStyles[theme.breakpoints.up(breakpoint)] = styles;
      }
    }

    function generateGutter(theme, breakpoint) {
      var styles = {};
      SPACINGS.forEach(function (spacing) {
        var themeSpacing = theme.spacing(spacing);

        if (themeSpacing === 0) {
          return;
        }

        styles["spacing-".concat(breakpoint, "-").concat(spacing)] = {
          margin: -themeSpacing / 2,
          width: "calc(100% + ".concat(themeSpacing, "px)"),
          '& > $item': {
            padding: themeSpacing / 2
          }
        };
      });
      return styles;
    } // Default CSS values
    // flex: '0 1 auto',
    // flexDirection: 'row',
    // alignItems: 'flex-start',
    // flexWrap: 'nowrap',
    // justifyContent: 'flex-start',


    var styles$V = function styles(theme) {
      return _extends_1({
        /* Styles applied to the root element */
        root: {},

        /* Styles applied to the root element if `container={true}`. */
        container: {
          boxSizing: 'border-box',
          display: 'flex',
          flexWrap: 'wrap',
          width: '100%'
        },

        /* Styles applied to the root element if `item={true}`. */
        item: {
          boxSizing: 'border-box',
          margin: '0' // For instance, it's useful when used with a `figure` element.

        },

        /* Styles applied to the root element if `zeroMinWidth={true}`. */
        zeroMinWidth: {
          minWidth: 0
        },

        /* Styles applied to the root element if `direction="column"`. */
        'direction-xs-column': {
          flexDirection: 'column'
        },

        /* Styles applied to the root element if `direction="column-reverse"`. */
        'direction-xs-column-reverse': {
          flexDirection: 'column-reverse'
        },

        /* Styles applied to the root element if `direction="rwo-reverse"`. */
        'direction-xs-row-reverse': {
          flexDirection: 'row-reverse'
        },

        /* Styles applied to the root element if `wrap="nowrap"`. */
        'wrap-xs-nowrap': {
          flexWrap: 'nowrap'
        },

        /* Styles applied to the root element if `wrap="reverse"`. */
        'wrap-xs-wrap-reverse': {
          flexWrap: 'wrap-reverse'
        },

        /* Styles applied to the root element if `alignItems="center"`. */
        'align-items-xs-center': {
          alignItems: 'center'
        },

        /* Styles applied to the root element if `alignItems="flex-start"`. */
        'align-items-xs-flex-start': {
          alignItems: 'flex-start'
        },

        /* Styles applied to the root element if `alignItems="flex-end"`. */
        'align-items-xs-flex-end': {
          alignItems: 'flex-end'
        },

        /* Styles applied to the root element if `alignItems="baseline"`. */
        'align-items-xs-baseline': {
          alignItems: 'baseline'
        },

        /* Styles applied to the root element if `alignContent="center"`. */
        'align-content-xs-center': {
          alignContent: 'center'
        },

        /* Styles applied to the root element if `alignContent="flex-start"`. */
        'align-content-xs-flex-start': {
          alignContent: 'flex-start'
        },

        /* Styles applied to the root element if `alignContent="flex-end"`. */
        'align-content-xs-flex-end': {
          alignContent: 'flex-end'
        },

        /* Styles applied to the root element if `alignContent="space-between"`. */
        'align-content-xs-space-between': {
          alignContent: 'space-between'
        },

        /* Styles applied to the root element if `alignContent="space-around"`. */
        'align-content-xs-space-around': {
          alignContent: 'space-around'
        },

        /* Styles applied to the root element if `justify="center"`. */
        'justify-xs-center': {
          justifyContent: 'center'
        },

        /* Styles applied to the root element if `justify="flex-end"`. */
        'justify-xs-flex-end': {
          justifyContent: 'flex-end'
        },

        /* Styles applied to the root element if `justify="space-between"`. */
        'justify-xs-space-between': {
          justifyContent: 'space-between'
        },

        /* Styles applied to the root element if `justify="space-around"`. */
        'justify-xs-space-around': {
          justifyContent: 'space-around'
        },

        /* Styles applied to the root element if `justify="space-evenly"`. */
        'justify-xs-space-evenly': {
          justifyContent: 'space-evenly'
        }
      }, generateGutter(theme, 'xs'), keys.reduce(function (accumulator, key) {
        // Use side effect over immutability for better performance.
        generateGrid(accumulator, theme, key);
        return accumulator;
      }, {}));
    };
    var Grid = React__default.forwardRef(function (props, ref) {
      var _props$alignContent = props.alignContent,
          alignContent = _props$alignContent === void 0 ? 'stretch' : _props$alignContent,
          _props$alignItems = props.alignItems,
          alignItems = _props$alignItems === void 0 ? 'stretch' : _props$alignItems,
          classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$container = props.container,
          container = _props$container === void 0 ? false : _props$container,
          _props$direction = props.direction,
          direction = _props$direction === void 0 ? 'row' : _props$direction,
          _props$item = props.item,
          item = _props$item === void 0 ? false : _props$item,
          _props$justify = props.justify,
          justify = _props$justify === void 0 ? 'flex-start' : _props$justify,
          _props$lg = props.lg,
          lg = _props$lg === void 0 ? false : _props$lg,
          _props$md = props.md,
          md = _props$md === void 0 ? false : _props$md,
          _props$sm = props.sm,
          sm = _props$sm === void 0 ? false : _props$sm,
          _props$spacing = props.spacing,
          spacing = _props$spacing === void 0 ? 0 : _props$spacing,
          _props$wrap = props.wrap,
          wrap = _props$wrap === void 0 ? 'wrap' : _props$wrap,
          _props$xl = props.xl,
          xl = _props$xl === void 0 ? false : _props$xl,
          _props$xs = props.xs,
          xs = _props$xs === void 0 ? false : _props$xs,
          _props$zeroMinWidth = props.zeroMinWidth,
          zeroMinWidth = _props$zeroMinWidth === void 0 ? false : _props$zeroMinWidth,
          other = objectWithoutProperties(props, ["alignContent", "alignItems", "classes", "className", "component", "container", "direction", "item", "justify", "lg", "md", "sm", "spacing", "wrap", "xl", "xs", "zeroMinWidth"]);

      var className = clsx(classes.root, classNameProp, container && [classes.container, spacing !== 0 && classes["spacing-xs-".concat(String(spacing))]], item && classes.item, zeroMinWidth && classes.zeroMinWidth, direction !== 'row' && classes["direction-xs-".concat(String(direction))], wrap !== 'wrap' && classes["wrap-xs-".concat(String(wrap))], alignItems !== 'stretch' && classes["align-items-xs-".concat(String(alignItems))], alignContent !== 'stretch' && classes["align-content-xs-".concat(String(alignContent))], justify !== 'flex-start' && classes["justify-xs-".concat(String(justify))], xs !== false && classes["grid-xs-".concat(String(xs))], sm !== false && classes["grid-sm-".concat(String(sm))], md !== false && classes["grid-md-".concat(String(md))], lg !== false && classes["grid-lg-".concat(String(lg))], xl !== false && classes["grid-xl-".concat(String(xl))]);
      return React__default.createElement(Component, _extends_1({
        className: className,
        ref: ref
      }, other));
    });

    {
      // can't use named function expression since the function body references `Grid`
      // which would point to the render function instead of the actual component
      Grid.displayName = 'ForwardRef(Grid)';
    }

    Grid.propTypes = {
      /**
       * Defines the `align-content` style property.
       * It's applied for all screen sizes.
       */
      alignContent: PropTypes__default.oneOf(['stretch', 'center', 'flex-start', 'flex-end', 'space-between', 'space-around']),

      /**
       * Defines the `align-items` style property.
       * It's applied for all screen sizes.
       */
      alignItems: PropTypes__default.oneOf(['flex-start', 'center', 'flex-end', 'stretch', 'baseline']),

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the component will have the flex *container* behavior.
       * You should be wrapping *items* with a *container*.
       */
      container: PropTypes__default.bool,

      /**
       * Defines the `flex-direction` style property.
       * It is applied for all screen sizes.
       */
      direction: PropTypes__default.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),

      /**
       * If `true`, the component will have the flex *item* behavior.
       * You should be wrapping *items* with a *container*.
       */
      item: PropTypes__default.bool,

      /**
       * Defines the `justify-content` style property.
       * It is applied for all screen sizes.
       */
      justify: PropTypes__default.oneOf(['flex-start', 'center', 'flex-end', 'space-between', 'space-around', 'space-evenly']),

      /**
       * Defines the number of grids the component is going to use.
       * It's applied for the `lg` breakpoint and wider screens if not overridden.
       */
      lg: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),

      /**
       * Defines the number of grids the component is going to use.
       * It's applied for the `md` breakpoint and wider screens if not overridden.
       */
      md: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),

      /**
       * Defines the number of grids the component is going to use.
       * It's applied for the `sm` breakpoint and wider screens if not overridden.
       */
      sm: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),

      /**
       * Defines the space between the type `item` component.
       * It can only be used on a type `container` component.
       */
      spacing: PropTypes__default.oneOf(SPACINGS),

      /**
       * Defines the `flex-wrap` style property.
       * It's applied for all screen sizes.
       */
      wrap: PropTypes__default.oneOf(['nowrap', 'wrap', 'wrap-reverse']),

      /**
       * Defines the number of grids the component is going to use.
       * It's applied for the `xl` breakpoint and wider screens.
       */
      xl: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),

      /**
       * Defines the number of grids the component is going to use.
       * It's applied for all the screen sizes with the lowest priority.
       */
      xs: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),

      /**
       * If `true`, it sets `min-width: 0` on the item.
       * Refer to the limitations section of the documentation to better understand the use case.
       */
      zeroMinWidth: PropTypes__default.bool
    };
    var StyledGrid = withStyles(styles$V, {
      name: 'MuiGrid'
    })(Grid);

    {
      var requireProp = requirePropFactory('Grid');
      StyledGrid.propTypes = _extends_1({}, StyledGrid.propTypes, {
        alignContent: requireProp('container'),
        alignItems: requireProp('container'),
        direction: requireProp('container'),
        justify: requireProp('container'),
        lg: requireProp('item'),
        md: requireProp('item'),
        sm: requireProp('item'),
        spacing: requireProp('container'),
        wrap: requireProp('container'),
        xs: requireProp('item'),
        zeroMinWidth: requireProp('item')
      });
    }

    var styles$W = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        flexWrap: 'wrap',
        overflowY: 'auto',
        listStyle: 'none',
        padding: 0,
        WebkitOverflowScrolling: 'touch' // Add iOS momentum scrolling.

      }
    };
    var GridList = React__default.forwardRef(function GridList(props, ref) {
      var _props$cellHeight = props.cellHeight,
          cellHeight = _props$cellHeight === void 0 ? 180 : _props$cellHeight,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$cols = props.cols,
          cols = _props$cols === void 0 ? 2 : _props$cols,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'ul' : _props$component,
          _props$spacing = props.spacing,
          spacing = _props$spacing === void 0 ? 4 : _props$spacing,
          style = props.style,
          other = objectWithoutProperties(props, ["cellHeight", "children", "classes", "className", "cols", "component", "spacing", "style"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, classNameProp),
        ref: ref,
        style: _extends_1({
          margin: -spacing / 2
        }, style)
      }, other), React__default.Children.map(children, function (child) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        warning_1(child.type !== React__default.Fragment, ["Material-UI: the GridList component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        var childCols = child.props.cols || 1;
        var childRows = child.props.rows || 1;
        return React__default.cloneElement(child, {
          style: Object.assign({
            width: "".concat(100 / cols * childCols, "%"),
            height: cellHeight === 'auto' ? 'auto' : cellHeight * childRows + spacing,
            padding: spacing / 2
          }, child.props.style)
        });
      }));
    });
    GridList.propTypes = {
      /**
       * Number of px for one cell height.
       * You can set `'auto'` if you want to let the children determine the height.
       */
      cellHeight: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.oneOf(['auto'])]),

      /**
       * Grid Tiles that will be in Grid List.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Number of columns.
       */
      cols: PropTypes__default.number,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Number of px for the spacing between tiles.
       */
      spacing: PropTypes__default.number,

      /**
       * @ignore
       */
      style: PropTypes__default.object
    };
    withStyles(styles$W, {
      name: 'MuiGridList'
    })(GridList);

    var styles$X = {
      /* Styles applied to the root element. */
      root: {
        boxSizing: 'border-box',
        flexShrink: 0
      },

      /* Styles applied to the `div` element that wraps the children. */
      tile: {
        position: 'relative',
        display: 'block',
        // In case it's not rendered with a div.
        height: '100%',
        overflow: 'hidden'
      },

      /* Styles applied to an `img` element child, if needed to ensure it covers the tile. */
      imgFullHeight: {
        height: '100%',
        transform: 'translateX(-50%)',
        position: 'relative',
        left: '50%'
      },

      /* Styles applied to an `img` element child, if needed to ensure it covers the tile. */
      imgFullWidth: {
        width: '100%',
        position: 'relative',
        transform: 'translateY(-50%)',
        top: '50%'
      }
    };

    var fit = function fit(imgEl, classes) {
      if (!imgEl || !imgEl.complete) {
        return;
      }

      if (imgEl.width / imgEl.height > imgEl.parentNode.offsetWidth / imgEl.parentNode.offsetHeight) {
        var _imgEl$classList, _imgEl$classList2;

        (_imgEl$classList = imgEl.classList).remove.apply(_imgEl$classList, toConsumableArray(classes.imgFullWidth.split(' ')));

        (_imgEl$classList2 = imgEl.classList).add.apply(_imgEl$classList2, toConsumableArray(classes.imgFullHeight.split(' ')));
      } else {
        var _imgEl$classList3, _imgEl$classList4;

        (_imgEl$classList3 = imgEl.classList).remove.apply(_imgEl$classList3, toConsumableArray(classes.imgFullHeight.split(' ')));

        (_imgEl$classList4 = imgEl.classList).add.apply(_imgEl$classList4, toConsumableArray(classes.imgFullWidth.split(' ')));
      }
    };

    function ensureImageCover(imgEl, classes) {
      if (!imgEl) {
        return;
      }

      if (imgEl.complete) {
        fit(imgEl, classes);
      } else {
        imgEl.addEventListener('load', function () {
          fit(imgEl, classes);
        });
      }
    }

    var GridListTile = React__default.forwardRef(function GridListTile(props, ref) {
      // cols rows default values are for docs only
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$cols = props.cols,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'li' : _props$component,
          _props$rows = props.rows,
          other = objectWithoutProperties(props, ["children", "classes", "className", "cols", "component", "rows"]);

      var imgRef = React__default.useRef(null);
      React__default.useEffect(function () {
        ensureImageCover(imgRef.current, classes);
      });
      React__default.useEffect(function () {
        var handleResize = debounce_1(function () {
          fit(imgRef.current, classes);
        }, 166); // Corresponds to 10 frames at 60 Hz.

        window.addEventListener('resize', handleResize);
        return function () {
          handleResize.clear();
          window.removeEventListener('resize', handleResize);
        };
      }, [classes]);
      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other), React__default.createElement("div", {
        className: classes.tile
      }, React__default.Children.map(children, function (child) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        if (child.type === 'img' || isMuiElement(child, ['Image'])) {
          return React__default.cloneElement(child, {
            ref: imgRef
          });
        }

        return child;
      })));
    });
    GridListTile.propTypes = {
      /**
       * Theoretically you can pass any node as children, but the main use case is to pass an img,
       * in which case GridListTile takes care of making the image "cover" available space
       * (similar to `background-size: cover` or to `object-fit: cover`).
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Width of the tile in number of grid cells.
       */
      cols: PropTypes__default.number,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Height of the tile in number of grid cells.
       */
      rows: PropTypes__default.number
    };
    withStyles(styles$X, {
      name: 'MuiGridListTile'
    })(GridListTile);

    var styles$Y = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'absolute',
          left: 0,
          right: 0,
          height: 48,
          background: 'rgba(0, 0, 0, 0.5)',
          display: 'flex',
          alignItems: 'center',
          fontFamily: theme.typography.fontFamily
        },

        /* Styles applied to the root element if `titlePosition="bottom"`. */
        titlePositionBottom: {
          bottom: 0
        },

        /* Styles applied to the root element if `titlePosition="top"`. */
        titlePositionTop: {
          top: 0
        },

        /* Styles applied to the root element if a `subtitle` is provided. */
        rootSubtitle: {
          height: 68
        },

        /* Styles applied to the title and subtitle container element. */
        titleWrap: {
          flexGrow: 1,
          marginLeft: 16,
          marginRight: 16,
          color: theme.palette.common.white,
          overflow: 'hidden'
        },

        /* Styles applied to the container element if `actionPosition="left"`. */
        titleWrapActionPosLeft: {
          marginLeft: 0
        },

        /* Styles applied to the container element if `actionPosition="right"`. */
        titleWrapActionPosRight: {
          marginRight: 0
        },

        /* Styles applied to the title container element. */
        title: {
          fontSize: theme.typography.pxToRem(16),
          lineHeight: '24px',
          textOverflow: 'ellipsis',
          overflow: 'hidden',
          whiteSpace: 'nowrap'
        },

        /* Styles applied to the subtitle container element. */
        subtitle: {
          fontSize: theme.typography.pxToRem(12),
          lineHeight: 1,
          textOverflow: 'ellipsis',
          overflow: 'hidden',
          whiteSpace: 'nowrap'
        },

        /* Styles applied to the actionIcon if supplied. */
        actionIcon: {},

        /* Styles applied to the actionIcon if `actionPosition="left"`. */
        actionIconActionPosLeft: {
          order: -1
        }
      };
    };
    var GridListTileBar = React__default.forwardRef(function GridListTileBar(props, ref) {
      var actionIcon = props.actionIcon,
          _props$actionPosition = props.actionPosition,
          actionPosition = _props$actionPosition === void 0 ? 'right' : _props$actionPosition,
          classes = props.classes,
          classNameProp = props.className,
          subtitle = props.subtitle,
          title = props.title,
          _props$titlePosition = props.titlePosition,
          titlePosition = _props$titlePosition === void 0 ? 'bottom' : _props$titlePosition,
          other = objectWithoutProperties(props, ["actionIcon", "actionPosition", "classes", "className", "subtitle", "title", "titlePosition"]);

      var actionPos = actionIcon && actionPosition;
      var className = clsx(classes.root, titlePosition === 'bottom' && classes.titlePositionBottom, titlePosition === 'top' && classes.titlePositionTop, subtitle && classes.rootSubtitle, classNameProp); // Remove the margin between the title / subtitle wrapper, and the Action Icon

      var titleWrapClassName = clsx(classes.titleWrap, actionPos === 'left' && classes.titleWrapActionPosLeft, actionPos === 'right' && classes.titleWrapActionPosRight);
      return React__default.createElement("div", _extends_1({
        className: className,
        ref: ref
      }, other), React__default.createElement("div", {
        className: titleWrapClassName
      }, React__default.createElement("div", {
        className: classes.title
      }, title), subtitle ? React__default.createElement("div", {
        className: classes.subtitle
      }, subtitle) : null), actionIcon ? React__default.createElement("div", {
        className: clsx(classes.actionIcon, actionPos === 'left' && classes.actionIconActionPosLeft)
      }, actionIcon) : null);
    });
    GridListTileBar.propTypes = {
      /**
       * An IconButton element to be used as secondary action target
       * (primary action target is the tile itself).
       */
      actionIcon: PropTypes__default.node,

      /**
       * Position of secondary action IconButton.
       */
      actionPosition: PropTypes__default.oneOf(['left', 'right']),

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * String or element serving as subtitle (support text).
       */
      subtitle: PropTypes__default.node,

      /**
       * Title to be displayed on tile.
       */
      title: PropTypes__default.node,

      /**
       * Position of the title bar.
       */
      titlePosition: PropTypes__default.oneOf(['top', 'bottom'])
    };
    withStyles(styles$Y, {
      name: 'MuiGridListTileBar'
    })(GridListTileBar);

    function getScale(value) {
      return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
    }

    var styles$Z = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        // Use translateZ to scrolling issue on Chrome.
        transform: "".concat(getScale(1), " translateZ(0)")
      }
    };
    /**
     * The Grow transition is used by the [Tooltip](/components/tooltips/) and
     * [Popover](/components/popover/) components.
     * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
     */

    var Grow = React__default.forwardRef(function Grow(props, ref) {
      var children = props.children,
          inProp = props.in,
          onEnter = props.onEnter,
          onExit = props.onExit,
          style = props.style,
          theme = props.theme,
          _props$timeout = props.timeout,
          timeout = _props$timeout === void 0 ? 'auto' : _props$timeout,
          other = objectWithoutProperties(props, ["children", "in", "onEnter", "onExit", "style", "theme", "timeout"]);

      var timer = React__default.useRef();
      var autoTimeout = React__default.useRef();
      var handleRef = useForkRef(children.ref, ref);

      var handleEnter = function handleEnter(node) {
        reflow(node); // So the animation always start from the start.

        var _getTransitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'enter'
        }),
            transitionDuration = _getTransitionProps.duration,
            delay = _getTransitionProps.delay;

        var duration = 0;

        if (timeout === 'auto') {
          duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
          autoTimeout.current = duration;
        } else {
          duration = transitionDuration;
        }

        node.style.transition = [theme.transitions.create('opacity', {
          duration: duration,
          delay: delay
        }), theme.transitions.create('transform', {
          duration: duration * 0.666,
          delay: delay
        })].join(',');

        if (onEnter) {
          onEnter(node);
        }
      };

      var handleExit = function handleExit(node) {
        var duration = 0;

        var _getTransitionProps2 = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'exit'
        }),
            transitionDuration = _getTransitionProps2.duration,
            delay = _getTransitionProps2.delay;

        if (timeout === 'auto') {
          duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
          autoTimeout.current = duration;
        } else {
          duration = transitionDuration;
        }

        node.style.transition = [theme.transitions.create('opacity', {
          duration: duration,
          delay: delay
        }), theme.transitions.create('transform', {
          duration: duration * 0.666,
          delay: delay || duration * 0.333
        })].join(',');
        node.style.opacity = '0';
        node.style.transform = getScale(0.75);

        if (onExit) {
          onExit(node);
        }
      };

      var addEndListener = function addEndListener(_, next) {
        if (timeout === 'auto') {
          timer.current = setTimeout(next, autoTimeout.current || 0);
        }
      };

      React__default.useEffect(function () {
        return function () {
          clearTimeout(timer.current);
        };
      }, []);
      return React__default.createElement(Transition, _extends_1({
        appear: true,
        in: inProp,
        onEnter: handleEnter,
        onExit: handleExit,
        addEndListener: addEndListener,
        timeout: timeout === 'auto' ? null : timeout
      }, other), function (state, childProps) {
        return React__default.cloneElement(children, _extends_1({
          style: _extends_1({
            opacity: 0,
            transform: getScale(0.75),
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, styles$Z[state], style, children.props.style),
          ref: handleRef
        }, childProps));
      });
    });
    Grow.propTypes = {
      /**
       * A single child content element.
       */
      children: PropTypes__default.element,

      /**
       * If `true`, show the component; triggers the enter or exit animation.
       */
      in: PropTypes__default.bool,

      /**
       * @ignore
       */
      onEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onExit: PropTypes__default.func,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       *
       * Set to 'auto' to automatically calculate transition time based on height.
       */
      timeout: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      }), PropTypes__default.oneOf(['auto'])])
    };
    Grow.muiSupportAuto = true;
    var Grow$1 = withTheme(Grow);

    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var warning$2 = function() {};

    {
      var printWarning$2 = function printWarning(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = 'Warning: ' +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      warning$2 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === undefined) {
          throw new Error(
              '`warning(condition, format, ...args)` requires a warning ' +
              'message argument'
          );
        }
        if (!condition) {
          printWarning$2.apply(null, [format].concat(args));
        }
      };
    }

    var warning_1$2 = warning$2;

    var reactEventListener_cjs = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

    var _classCallCheck = _interopDefault(classCallCheck);
    var _createClass = _interopDefault(createClass);
    var _possibleConstructorReturn = _interopDefault(possibleConstructorReturn);
    var _getPrototypeOf = _interopDefault(getPrototypeOf);
    var _inherits = _interopDefault(inherits);
    var _typeof = _interopDefault(_typeof_1);
    var _objectWithoutProperties = _interopDefault(objectWithoutProperties);
    var _extends = _interopDefault(_extends_1);
    var React = _interopDefault(React__default);
    var PropTypes = _interopDefault(PropTypes__default);
    var warning = _interopDefault(warning_1$2);

    function defineProperty(object, property, attr) {
      return Object.defineProperty(object, property, attr);
    } // Passive options
    // Inspired by https://github.com/Modernizr/Modernizr/blob/master/feature-detects/dom/passiveeventlisteners.js


    var passiveOption = function () {
      var cache = null;
      return function () {
        if (cache !== null) {
          return cache;
        }

        var supportsPassiveOption = false;

        try {
          window.addEventListener('test', null, defineProperty({}, 'passive', {
            get: function get() {
              supportsPassiveOption = true;
            }
          }));
        } catch (err) {//
        }

        cache = supportsPassiveOption;
        return supportsPassiveOption;
      }();
    }();

    var defaultEventOptions = {
      capture: false,
      passive: false
    };

    function mergeDefaultEventOptions(options) {
      return _extends({}, defaultEventOptions, options);
    }

    function getEventListenerArgs(eventName, callback, options) {
      var args = [eventName, callback];
      args.push(passiveOption ? options : options.capture);
      return args;
    }

    function on(target, eventName, callback, options) {
      // eslint-disable-next-line prefer-spread
      target.addEventListener.apply(target, getEventListenerArgs(eventName, callback, options));
    }

    function off(target, eventName, callback, options) {
      // eslint-disable-next-line prefer-spread
      target.removeEventListener.apply(target, getEventListenerArgs(eventName, callback, options));
    }

    function forEachListener(props, iteratee) {
      var children = props.children,
          target = props.target,
          eventProps = _objectWithoutProperties(props, ["children", "target"]);

      Object.keys(eventProps).forEach(function (name) {
        if (name.substring(0, 2) !== 'on') {
          return;
        }

        var prop = eventProps[name];

        var type = _typeof(prop);

        var isObject = type === 'object';
        var isFunction = type === 'function';

        if (!isObject && !isFunction) {
          return;
        }

        var capture = name.substr(-7).toLowerCase() === 'capture';
        var eventName = name.substring(2).toLowerCase();
        eventName = capture ? eventName.substring(0, eventName.length - 7) : eventName;

        if (isObject) {
          iteratee(eventName, prop.handler, prop.options);
        } else {
          iteratee(eventName, prop, mergeDefaultEventOptions({
            capture: capture
          }));
        }
      });
    }

    function withOptions(handler, options) {
      warning(options, 'react-event-listener: should be specified options in withOptions.');
      return {
        handler: handler,
        options: mergeDefaultEventOptions(options)
      };
    }

    var EventListener =
    /*#__PURE__*/
    function (_React$PureComponent) {
      _inherits(EventListener, _React$PureComponent);

      function EventListener() {
        _classCallCheck(this, EventListener);

        return _possibleConstructorReturn(this, _getPrototypeOf(EventListener).apply(this, arguments));
      }

      _createClass(EventListener, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.applyListeners(on);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          this.applyListeners(off, prevProps);
          this.applyListeners(on);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.applyListeners(off);
        }
      }, {
        key: "applyListeners",
        value: function applyListeners(onOrOff) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;
          var target = props.target;

          if (target) {
            var element = target;

            if (typeof target === 'string') {
              element = window[target];
            }

            forEachListener(props, onOrOff.bind(null, element));
          }
        }
      }, {
        key: "render",
        value: function render() {
          return this.props.children || null;
        }
      }]);

      return EventListener;
    }(React.PureComponent);

    EventListener.propTypes = {
      /**
       * You can provide a single child too.
       */
      children: PropTypes.node,

      /**
       * The DOM target to listen to.
       */
      target: PropTypes.oneOfType([PropTypes.object, PropTypes.string]).isRequired
    };

    exports.withOptions = withOptions;
    exports.default = EventListener;
    });

    var EventListener = unwrapExports(reactEventListener_cjs);
    var reactEventListener_cjs_1 = reactEventListener_cjs.withOptions;

    var isWidthUp = function isWidthUp(breakpoint, width) {
      var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (inclusive) {
        return keys.indexOf(breakpoint) <= keys.indexOf(width);
      }

      return keys.indexOf(breakpoint) < keys.indexOf(width);
    }; // By default, returns true if screen width is the same or less than the given breakpoint.

    var isWidthDown = function isWidthDown(breakpoint, width) {
      var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (inclusive) {
        return keys.indexOf(width) <= keys.indexOf(breakpoint);
      }

      return keys.indexOf(width) < keys.indexOf(breakpoint);
    };

    var withWidth = function withWidth() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return function (Component) {
        var _options$withTheme = options.withTheme,
            withThemeOption = _options$withTheme === void 0 ? false : _options$withTheme,
            _options$noSSR = options.noSSR,
            noSSR = _options$noSSR === void 0 ? false : _options$noSSR,
            initialWidthOption = options.initialWidth,
            _options$resizeInterv = options.resizeInterval,
            resizeInterval = _options$resizeInterv === void 0 ? 166 : _options$resizeInterv;

        var WithWidth =
        /*#__PURE__*/
        function (_React$Component) {
          inherits(WithWidth, _React$Component);

          function WithWidth(props) {
            var _this;

            classCallCheck(this, WithWidth);

            _this = possibleConstructorReturn(this, getPrototypeOf(WithWidth).call(this, props));
            _this.state = {
              width: noSSR ? _this.getWidth() : undefined
            };

            if (typeof window !== 'undefined') {
              _this.handleResize = debounce_1(function () {
                var width2 = _this.getWidth();

                if (width2 !== _this.state.width) {
                  _this.setState({
                    width: width2
                  });
                }
              }, resizeInterval);
            }

            return _this;
          }

          createClass(WithWidth, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              var width = this.getWidth();

              if (width !== this.state.width) {
                this.setState({
                  width: width
                });
              }
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              this.handleResize.clear();
            }
          }, {
            key: "getWidth",
            value: function getWidth() {
              var innerWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.innerWidth;
              var breakpoints = this.props.theme.breakpoints;
              var width = null;
              /**
               * Start with the slowest value as low end devices often have a small screen.
               *
               * innerWidth |xs      sm      md      lg      xl
               *            |-------|-------|-------|-------|------>
               * width      |  xs   |  sm   |  md   |  lg   |  xl
               */

              var index = 1;

              while (width === null && index < keys.length) {
                var currentWidth = keys[index]; // @media are inclusive, so reproduce the behavior here.

                if (innerWidth < breakpoints.values[currentWidth]) {
                  width = keys[index - 1];
                  break;
                }

                index += 1;
              }

              width = width || 'xl';
              return width;
            }
          }, {
            key: "render",
            value: function render() {
              var _getThemeProps = styles$1O.getThemeProps({
                theme: this.props.theme,
                name: 'MuiWithWidth',
                props: _extends_1({}, this.props)
              }),
                  initialWidth = _getThemeProps.initialWidth,
                  theme = _getThemeProps.theme,
                  width = _getThemeProps.width,
                  other = objectWithoutProperties(_getThemeProps, ["initialWidth", "theme", "width"]);

              var more = _extends_1({
                width: width || this.state.width || initialWidth || initialWidthOption
              }, other); // When rendering the component on the server,
              // we have no idea about the client browser screen width.
              // In order to prevent blinks and help the reconciliation of the React tree
              // we are not rendering the child component.
              //
              // An alternative is to use the `initialWidth` property.


              if (more.width === undefined) {
                return null;
              }

              if (withThemeOption) {
                more.theme = theme;
              }

              return React__default.createElement(React__default.Fragment, null, React__default.createElement(Component, more), React__default.createElement(EventListener, {
                target: "window",
                onResize: this.handleResize
              }));
            }
          }]);

          return WithWidth;
        }(React__default.Component);

        WithWidth.propTypes = {
          /**
           * As `window.innerWidth` is unavailable on the server,
           * we default to rendering an empty component during the first mount.
           * You might want to use an heuristic to approximate
           * the screen width of the client browser screen width.
           *
           * For instance, you could be using the user-agent or the client-hints.
           * https://caniuse.com/#search=client%20hint
           */
          initialWidth: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),

          /**
           * @ignore
           */
          theme: PropTypes__default.object.isRequired,

          /**
           * Bypass the width calculation logic.
           */
          width: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
        };

        {
          WithWidth.displayName = "WithWidth(".concat(getDisplayName(Component), ")");
        }

        hoistNonReactStatics_cjs(WithWidth, Component);
        return withTheme(WithWidth);
      };
    };

    /**
     * @ignore - internal component.
     */

    function HiddenJs(props) {
      var children = props.children,
          only = props.only,
          width = props.width;
      var visible = true; // `only` check is faster to get out sooner if used.

      if (only) {
        if (Array.isArray(only)) {
          for (var i = 0; i < only.length; i += 1) {
            var breakpoint = only[i];

            if (width === breakpoint) {
              visible = false;
              break;
            }
          }
        } else if (only && width === only) {
          visible = false;
        }
      } // Allow `only` to be combined with other props. If already hidden, no need to check others.


      if (visible) {
        // determine visibility based on the smallest size up
        for (var _i = 0; _i < keys.length; _i += 1) {
          var _breakpoint = keys[_i];
          var breakpointUp = props["".concat(_breakpoint, "Up")];
          var breakpointDown = props["".concat(_breakpoint, "Down")];

          if (breakpointUp && isWidthUp(_breakpoint, width) || breakpointDown && isWidthDown(_breakpoint, width)) {
            visible = false;
            break;
          }
        }
      }

      if (!visible) {
        return null;
      }

      return children;
    }

    HiddenJs.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Specify which implementation to use.  'js' is the default, 'css' works better for
       * server-side rendering.
       */
      implementation: PropTypes__default.oneOf(['js', 'css']),

      /**
       * You can use this property when choosing the `js` implementation with server-side rendering.
       *
       * As `window.innerWidth` is unavailable on the server,
       * we default to rendering an empty component during the first mount.
       * You might want to use an heuristic to approximate
       * the screen width of the client browser screen width.
       *
       * For instance, you could be using the user-agent or the client-hints.
       * https://caniuse.com/#search=client%20hint
       */
      initialWidth: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),

      /**
       * If true, screens this size and down will be hidden.
       */
      lgDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      lgUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      mdDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      mdUp: PropTypes__default.bool,

      /**
       * Hide the given breakpoint(s).
       */
      only: PropTypes__default.oneOfType([PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']), PropTypes__default.arrayOf(PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']))]),

      /**
       * If true, screens this size and down will be hidden.
       */
      smDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      smUp: PropTypes__default.bool,

      /**
       * @ignore
       * width prop provided by withWidth decorator.
       */
      width: PropTypes__default.string.isRequired,

      /**
       * If true, screens this size and down will be hidden.
       */
      xlDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xlUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      xsDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xsUp: PropTypes__default.bool
    };

    {
      HiddenJs.propTypes = exactProp(HiddenJs.propTypes);
    }

    var HiddenJs$1 = withWidth()(HiddenJs);

    var styles$_ = function styles(theme) {
      var hidden = {
        display: 'none'
      };
      return keys.reduce(function (acc, key) {
        acc["only".concat(capitalize(key))] = defineProperty({}, theme.breakpoints.only(key), hidden);
        acc["".concat(key, "Up")] = defineProperty({}, theme.breakpoints.up(key), hidden);
        acc["".concat(key, "Down")] = defineProperty({}, theme.breakpoints.down(key), hidden);
        return acc;
      }, {});
    };
    /**
     * @ignore - internal component.
     */


    function HiddenCss(props) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          lgDown = props.lgDown,
          lgUp = props.lgUp,
          mdDown = props.mdDown,
          mdUp = props.mdUp,
          only = props.only,
          smDown = props.smDown,
          smUp = props.smUp,
          xlDown = props.xlDown,
          xlUp = props.xlUp,
          xsDown = props.xsDown,
          xsUp = props.xsUp,
          other = objectWithoutProperties(props, ["children", "classes", "className", "lgDown", "lgUp", "mdDown", "mdUp", "only", "smDown", "smUp", "xlDown", "xlUp", "xsDown", "xsUp"]);

      warning_1(Object.keys(other).length === 0 || Object.keys(other).length === 1 && other.hasOwnProperty('ref'), "Material-UI: unsupported properties received ".concat(Object.keys(other).join(', '), " by `<Hidden />`."));
      var clsx = [];

      if (className) {
        clsx.push(className);
      }

      for (var i = 0; i < keys.length; i += 1) {
        var breakpoint = keys[i];
        var breakpointUp = props["".concat(breakpoint, "Up")];
        var breakpointDown = props["".concat(breakpoint, "Down")];

        if (breakpointUp) {
          clsx.push(classes["".concat(breakpoint, "Up")]);
        }

        if (breakpointDown) {
          clsx.push(classes["".concat(breakpoint, "Down")]);
        }
      }

      if (only) {
        var onlyBreakpoints = Array.isArray(only) ? only : [only];
        onlyBreakpoints.forEach(function (breakpoint) {
          clsx.push(classes["only".concat(capitalize(breakpoint))]);
        });
      }

      return React__default.createElement("div", {
        className: clsx.join(' ')
      }, children);
    }

    HiddenCss.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Specify which implementation to use.  'js' is the default, 'css' works better for
       * server-side rendering.
       */
      implementation: PropTypes__default.oneOf(['js', 'css']),

      /**
       * If true, screens this size and down will be hidden.
       */
      lgDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      lgUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      mdDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      mdUp: PropTypes__default.bool,

      /**
       * Hide the given breakpoint(s).
       */
      only: PropTypes__default.oneOfType([PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']), PropTypes__default.arrayOf(PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']))]),

      /**
       * If true, screens this size and down will be hidden.
       */
      smDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      smUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      xlDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xlUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      xsDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xsUp: PropTypes__default.bool
    };
    var HiddenCss$1 = withStyles(styles$_, {
      name: 'PrivateHiddenCss'
    })(HiddenCss);

    /**
     * Responsively hides children based on the selected implementation.
     */

    function Hidden(props) {
      var implementation = props.implementation,
          other = objectWithoutProperties(props, ["implementation"]);

      if (implementation === 'js') {
        return React__default.createElement(HiddenJs$1, other);
      }

      return React__default.createElement(HiddenCss$1, other);
    }

    Hidden.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Specify which implementation to use.  'js' is the default, 'css' works better for
       * server-side rendering.
       */
      implementation: PropTypes__default.oneOf(['js', 'css']),

      /**
       * You can use this property when choosing the `js` implementation with server-side rendering.
       *
       * As `window.innerWidth` is unavailable on the server,
       * we default to rendering an empty component during the first mount.
       * You might want to use an heuristic to approximate
       * the screen width of the client browser screen width.
       *
       * For instance, you could be using the user-agent or the client-hints.
       * https://caniuse.com/#search=client%20hint
       */
      initialWidth: PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),

      /**
       * If true, screens this size and down will be hidden.
       */
      lgDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      lgUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      mdDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      mdUp: PropTypes__default.bool,

      /**
       * Hide the given breakpoint(s).
       */
      only: PropTypes__default.oneOfType([PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']), PropTypes__default.arrayOf(PropTypes__default.oneOf(['xs', 'sm', 'md', 'lg', 'xl']))]),

      /**
       * If true, screens this size and down will be hidden.
       */
      smDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      smUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      xlDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xlUp: PropTypes__default.bool,

      /**
       * If true, screens this size and down will be hidden.
       */
      xsDown: PropTypes__default.bool,

      /**
       * If true, screens this size and up will be hidden.
       */
      xsUp: PropTypes__default.bool
    };
    Hidden.defaultProps = {
      implementation: 'js',
      lgDown: false,
      lgUp: false,
      mdDown: false,
      mdUp: false,
      smDown: false,
      smUp: false,
      xlDown: false,
      xlUp: false,
      xsDown: false,
      xsUp: false
    };

    var styles$$ = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          userSelect: 'none',
          fontSize: theme.typography.pxToRem(24),
          width: '1em',
          height: '1em',
          // Chrome fix for https://bugs.chromium.org/p/chromium/issues/detail?id=820541
          // To remove at some point.
          overflow: 'hidden',
          flexShrink: 0
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          color: theme.palette.secondary.main
        },

        /* Styles applied to the root element if `color="action"`. */
        colorAction: {
          color: theme.palette.action.active
        },

        /* Styles applied to the root element if `color="error"`. */
        colorError: {
          color: theme.palette.error.main
        },

        /* Styles applied to the root element if `color="disabled"`. */
        colorDisabled: {
          color: theme.palette.action.disabled
        },
        fontSizeInherit: {
          fontSize: 'inherit'
        },

        /* Styles applied to the root element if `fontSize="small"`. */
        fontSizeSmall: {
          fontSize: theme.typography.pxToRem(20)
        },

        /* Styles applied to the root element if `fontSize="large"`. */
        fontSizeLarge: {
          fontSize: theme.typography.pxToRem(36)
        }
      };
    };
    var Icon = React__default.forwardRef(function Icon(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'inherit' : _props$color,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'span' : _props$component,
          _props$fontSize = props.fontSize,
          fontSize = _props$fontSize === void 0 ? 'default' : _props$fontSize,
          other = objectWithoutProperties(props, ["classes", "className", "color", "component", "fontSize"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx('material-icons', classes.root, color !== 'inherit' && classes["color".concat(capitalize(color))], fontSize !== 'default' && classes["fontSize".concat(capitalize(fontSize))], className),
        "aria-hidden": true,
        ref: ref
      }, other));
    });
    Icon.propTypes = {
      /**
       * The name of the icon font ligature.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['inherit', 'primary', 'secondary', 'action', 'error', 'disabled']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
       */
      fontSize: PropTypes__default.oneOf(['inherit', 'default', 'small', 'large'])
    };
    Icon.muiName = 'Icon';
    withStyles(styles$$, {
      name: 'MuiIcon'
    })(Icon);

    var styles$10 = function styles(theme) {
      var light = theme.palette.type === 'light';
      var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative'
        },

        /* Styles applied to the root element if the component is a descendant of `FormControl`. */
        formControl: {
          'label + &': {
            marginTop: 16
          }
        },

        /* Styles applied to the root element if the component is focused. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `disableUnderline={false}`. */
        underline: {
          '&:after': {
            borderBottom: "2px solid ".concat(theme.palette.primary[light ? 'dark' : 'light']),
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
            content: '""',
            position: 'absolute',
            right: 0,
            transform: 'scaleX(0)',
            transition: theme.transitions.create('transform', {
              duration: theme.transitions.duration.shorter,
              easing: theme.transitions.easing.easeOut
            }),
            pointerEvents: 'none' // Transparent to the hover style.

          },
          '&$focused:after': {
            transform: 'scaleX(1)'
          },
          '&$error:after': {
            borderBottomColor: theme.palette.error.main,
            transform: 'scaleX(1)' // error is always underlined in red

          },
          '&:before': {
            borderBottom: "1px solid ".concat(bottomLineColor),
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
            content: '"\\00a0"',
            position: 'absolute',
            right: 0,
            transition: theme.transitions.create('border-bottom-color', {
              duration: theme.transitions.duration.shorter
            }),
            pointerEvents: 'none' // Transparent to the hover style.

          },
          '&:hover:not($disabled):before': {
            borderBottom: "2px solid ".concat(theme.palette.text.primary),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              borderBottom: "1px solid ".concat(bottomLineColor)
            }
          },
          '&$disabled:before': {
            borderBottomStyle: 'dotted'
          }
        },

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `multiline={true}`. */
        multiline: {},

        /* Styles applied to the root element if `fullWidth={true}`. */
        fullWidth: {},

        /* Styles applied to the `input` element. */
        input: {},

        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {},

        /* Styles applied to the `input` element if `multiline={true}`. */
        inputMultiline: {},

        /* Styles applied to the `input` element if `type="search"`. */
        inputTypeSearch: {}
      };
    };
    var Input = React__default.forwardRef(function Input(props, ref) {
      var disableUnderline = props.disableUnderline,
          classes = props.classes,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$inputComponent = props.inputComponent,
          inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
          _props$multiline = props.multiline,
          multiline = _props$multiline === void 0 ? false : _props$multiline,
          _props$type = props.type,
          type = _props$type === void 0 ? 'text' : _props$type,
          other = objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

      return React__default.createElement(InputBase$1, _extends_1({
        classes: _extends_1({}, classes, {
          root: clsx(classes.root, !disableUnderline && classes.underline),
          underline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
      }, other));
    });
    Input.propTypes = {
      /**
       * This property helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: PropTypes__default.string,

      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the wrapper element.
       */
      className: PropTypes__default.string,

      /**
       * The default `input` element value, useful when not controlling the component.
       */
      defaultValue: PropTypes__default.any,

      /**
       * If `true`, the `input` element will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the input will not have an underline.
       */
      disableUnderline: PropTypes__default.bool,

      /**
       * End `InputAdornment` for this component.
       */
      endAdornment: PropTypes__default.node,

      /**
       * If `true`, the input will indicate an error. This is normally obtained via context from
       * FormControl.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the input will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * The component used for the native input.
       * Either a string to use a DOM element or a component.
       */
      inputComponent: PropTypes__default.elementType,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense', 'none']),

      /**
       * If `true`, a textarea element will be rendered.
       */
      multiline: PropTypes__default.bool,

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * Callback fired when the value is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * The short hint displayed in the input before the user enters a value.
       */
      placeholder: PropTypes__default.string,

      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: PropTypes__default.bool,

      /**
       * If `true`, the `input` element will be required.
       */
      required: PropTypes__default.bool,

      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Start `InputAdornment` for this component.
       */
      startAdornment: PropTypes__default.node,

      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       */
      type: PropTypes__default.string,

      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: PropTypes__default.any
    };
    Input.muiName = 'Input';
    var Input$1 = withStyles(styles$10, {
      name: 'MuiInput'
    })(Input);

    var styles$11 = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        height: '0.01em',
        // Fix IE 11 flexbox alignment. To remove at some point.
        maxHeight: '2em',
        alignItems: 'center'
      },

      /* Styles applied to the root element if `variant="filled"`. */
      filled: {
        '&$positionStart': {
          marginTop: 16
        }
      },

      /* Styles applied to the root element if `position="start"`. */
      positionStart: {
        marginRight: 8
      },

      /* Styles applied to the root element if `position="end"`. */
      positionEnd: {
        marginLeft: 8
      },

      /* Styles applied to the root element if `disablePointerEvents=true`. */
      disablePointerEvents: {
        pointerEvents: 'none'
      }
    };
    var InputAdornment = React__default.forwardRef(function InputAdornment(props, ref) {
      var children = props.children,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          classes = props.classes,
          className = props.className,
          _props$disablePointer = props.disablePointerEvents,
          disablePointerEvents = _props$disablePointer === void 0 ? false : _props$disablePointer,
          _props$disableTypogra = props.disableTypography,
          disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
          muiFormControl = props.muiFormControl,
          position = props.position,
          variantProp = props.variant,
          other = objectWithoutProperties(props, ["children", "component", "classes", "className", "disablePointerEvents", "disableTypography", "muiFormControl", "position", "variant"]);

      var variant = variantProp;

      if (variantProp && muiFormControl) {
        warning_1(variantProp !== muiFormControl.variant, 'Material-UI: The `InputAdornment` variant infers the variant property ' + 'you do not have to provide one.');
      }

      if (muiFormControl && !variant) {
        variant = muiFormControl.variant;
      }

      return React__default.createElement(FormControlContext.Provider, {
        value: null
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, variant === 'filled' && classes.filled, position === 'start' && classes.positionStart, position === 'end' && classes.positionEnd, disablePointerEvents && classes.disablePointerEvents, className),
        ref: ref
      }, other), typeof children === 'string' && !disableTypography ? React__default.createElement(Typography$1, {
        color: "textSecondary"
      }, children) : children));
    });
    InputAdornment.propTypes = {
      /**
       * The content of the component, normally an `IconButton` or string.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Disable pointer events on the root.
       * This allows for the content of the adornment to focus the input on click.
       */
      disablePointerEvents: PropTypes__default.bool,

      /**
       * If children is a string then disable wrapping in a Typography component.
       */
      disableTypography: PropTypes__default.bool,

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /**
       * The position this adornment should appear relative to the `Input`.
       */
      position: PropTypes__default.oneOf(['start', 'end']),

      /**
       * The variant to use.
       * Note: If you are using the `TextField` component or the `FormControl` component
       * you do not have to set this manually.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    withStyles(styles$11, {
      name: 'MuiInputAdornment'
    })(withFormControlContext(InputAdornment));

    var styles$12 = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'block',
          transformOrigin: 'top left'
        },

        /* Styles applied to the root element if `focused={true}`. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `required={true}`. */
        required: {},

        /* Styles applied to the asterisk element. */
        asterisk: {},

        /* Styles applied to the root element if the component is a descendant of `FormControl`. */
        formControl: {
          position: 'absolute',
          left: 0,
          top: 0,
          // slight alteration to spec spacing to match visual spec result
          transform: 'translate(0, 24px) scale(1)'
        },

        /* Styles applied to the root element if `margin="dense"`. */
        marginDense: {
          // Compensation for the `Input.inputDense` style.
          transform: 'translate(0, 21px) scale(1)'
        },

        /* Styles applied to the `input` element if `shrink={true}`. */
        shrink: {
          transform: 'translate(0, 1.5px) scale(0.75)',
          transformOrigin: 'top left'
        },

        /* Styles applied to the `input` element if `disableAnimation={false}`. */
        animated: {
          transition: theme.transitions.create(['color', 'transform'], {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          })
        },

        /* Styles applied to the root element if `variant="filled"`. */
        filled: {
          // Chrome's autofill feature gives the input field a yellow background.
          // Since the input field is behind the label in the HTML tree,
          // the input field is drawn last and hides the label with an opaque background color.
          // zIndex: 1 will raise the label above opaque background-colors of input.
          zIndex: 1,
          pointerEvents: 'none',
          transform: 'translate(12px, 20px) scale(1)',
          '&$marginDense': {
            transform: 'translate(12px, 17px) scale(1)'
          },
          '&$shrink': {
            transform: 'translate(12px, 10px) scale(0.75)',
            '&$marginDense': {
              transform: 'translate(12px, 7px) scale(0.75)'
            }
          }
        },

        /* Styles applied to the root element if `variant="outlined"`. */
        outlined: {
          // see comment above on filled.zIndex
          zIndex: 1,
          pointerEvents: 'none',
          transform: 'translate(14px, 20px) scale(1)',
          '&$marginDense': {
            transform: 'translate(14px, 17px) scale(1)'
          },
          '&$shrink': {
            transform: 'translate(14px, -6px) scale(0.75)'
          }
        }
      };
    };
    var InputLabel = React__default.forwardRef(function InputLabel(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$disableAnimati = props.disableAnimation,
          disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati,
          margin = props.margin,
          muiFormControl = props.muiFormControl,
          shrinkProp = props.shrink,
          variant = props.variant,
          other = objectWithoutProperties(props, ["classes", "className", "disableAnimation", "margin", "muiFormControl", "shrink", "variant"]);

      var shrink = shrinkProp;

      if (typeof shrink === 'undefined' && muiFormControl) {
        shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
      }

      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['margin', 'variant']
      });
      return React__default.createElement(FormLabel$1, _extends_1({
        "data-shrink": shrink,
        className: clsx(classes.root, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, fcs.margin === 'dense' && classes.marginDense, fcs.variant === 'filled' && classes.filled, fcs.variant === 'outlined' && classes.outlined, className),
        classes: {
          focused: classes.focused,
          disabled: classes.disabled,
          error: classes.error,
          required: classes.required,
          asterisk: classes.asterisk
        },
        ref: ref
      }, other));
    });
    InputLabel.propTypes = {
      /**
       * The contents of the `InputLabel`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the transition animation is disabled.
       */
      disableAnimation: PropTypes__default.bool,

      /**
       * If `true`, apply disabled class.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the label will be displayed in an error state.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the input of this label is focused.
       */
      focused: PropTypes__default.bool,

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense']),

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /**
       * if `true`, the label will indicate that the input is required.
       */
      required: PropTypes__default.bool,

      /**
       * If `true`, the label is shrunk.
       */
      shrink: PropTypes__default.bool,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    var InputLabel$1 = withStyles(styles$12, {
      name: 'MuiInputLabel'
    })(withFormControlContext(InputLabel));

    var TRANSITION_DURATION = 4; // seconds

    var styles$13 = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          overflow: 'hidden',
          height: 4
        },

        /* Styles applied to the root & bar2 element if `color="primary"`; bar2 if `variant-"buffer"`. */
        colorPrimary: {
          backgroundColor: lighten(theme.palette.primary.light, 0.6)
        },

        /* Styles applied to the root & bar2 elements if `color="secondary"`; bar2 if `variant="buffer"`. */
        colorSecondary: {
          backgroundColor: lighten(theme.palette.secondary.light, 0.4)
        },

        /* Styles applied to the root element if `variant="determinate"`. */
        determinate: {},

        /* Styles applied to the root element if `variant="indeterminate"`. */
        indeterminate: {},

        /* Styles applied to the root element if `variant="buffer"`. */
        buffer: {
          backgroundColor: 'transparent'
        },

        /* Styles applied to the root element if `variant="query"`. */
        query: {
          transform: 'rotate(180deg)'
        },

        /* Styles applied to the additional bar element if `variant="buffer"`. */
        dashed: {
          position: 'absolute',
          marginTop: 0,
          height: '100%',
          width: '100%',
          animation: 'buffer 3s infinite linear',
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$buffer'
        },

        /* Styles applied to the additional bar element if `variant="buffer"` & `color="primary"`. */
        dashedColorPrimary: {
          backgroundImage: "radial-gradient(".concat(lighten(theme.palette.primary.light, 0.6), " 0%, ").concat(lighten(theme.palette.primary.light, 0.6), " 16%, transparent 42%)"),
          backgroundSize: '10px 10px',
          backgroundPosition: '0px -23px'
        },

        /* Styles applied to the additional bar element if `variant="buffer"` & `color="secondary"`. */
        dashedColorSecondary: {
          backgroundImage: "radial-gradient(".concat(lighten(theme.palette.secondary.light, 0.4), " 0%, ").concat(lighten(theme.palette.secondary.light, 0.6), " 16%, transparent 42%)"),
          backgroundSize: '10px 10px',
          backgroundPosition: '0px -23px'
        },

        /* Styles applied to the layered bar1 & bar2 elements. */
        bar: {
          width: '100%',
          position: 'absolute',
          left: 0,
          bottom: 0,
          top: 0,
          transition: 'transform 0.2s linear',
          transformOrigin: 'left'
        },

        /* Styles applied to the bar elements if `color="primary"`; bar2 if `variant` not "buffer". */
        barColorPrimary: {
          backgroundColor: theme.palette.primary.main
        },

        /* Styles applied to the bar elements if `color="secondary"`; bar2 if `variant` not "buffer". */
        barColorSecondary: {
          backgroundColor: theme.palette.secondary.main
        },

        /* Styles applied to the bar1 element if `variant="indeterminate or query"`. */
        bar1Indeterminate: {
          width: 'auto',
          animation: 'mui-indeterminate1 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite',
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-indeterminate1'
        },

        /* Styles applied to the bar1 element if `variant="determinate"`. */
        bar1Determinate: {
          transition: "transform .".concat(TRANSITION_DURATION, "s linear")
        },

        /* Styles applied to the bar1 element if `variant="buffer"`. */
        bar1Buffer: {
          zIndex: 1,
          transition: "transform .".concat(TRANSITION_DURATION, "s linear")
        },

        /* Styles applied to the bar2 element if `variant="indeterminate or query"`. */
        bar2Indeterminate: {
          width: 'auto',
          animation: 'mui-indeterminate2 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite',
          // Backward compatible logic between JSS v9 and v10.
          // To remove with the release of Material-UI v4
          animationName: '$mui-indeterminate2',
          animationDelay: '1.15s'
        },

        /* Styles applied to the bar2 element if `variant="buffer"`. */
        bar2Buffer: {
          transition: "transform .".concat(TRANSITION_DURATION, "s linear")
        },
        // Legends:
        // || represents the viewport
        // -  represents a light background
        // x  represents a dark background
        '@keyframes mui-indeterminate1': {
          //  |-----|---x-||-----||-----|
          '0%': {
            left: '-35%',
            right: '100%'
          },
          //  |-----|-----||-----||xxxx-|
          '60%': {
            left: '100%',
            right: '-90%'
          },
          '100%': {
            left: '100%',
            right: '-90%'
          }
        },
        '@keyframes mui-indeterminate2': {
          //  |xxxxx|xxxxx||-----||-----|
          '0%': {
            left: '-200%',
            right: '100%'
          },
          //  |-----|-----||-----||-x----|
          '60%': {
            left: '107%',
            right: '-8%'
          },
          '100%': {
            left: '107%',
            right: '-8%'
          }
        },
        '@keyframes buffer': {
          '0%': {
            opacity: 1,
            backgroundPosition: '0px -23px'
          },
          '50%': {
            opacity: 0,
            backgroundPosition: '0px -23px'
          },
          '100%': {
            opacity: 1,
            backgroundPosition: '-200px -23px'
          }
        }
      };
    };
    /**
     * ## ARIA
     *
     * If the progress bar is describing the loading progress of a particular region of a page,
     * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`
     * attribute to `true` on that region until it has finished loading.
     */

    var LinearProgress = React__default.forwardRef(function LinearProgress(props, ref) {
      var classes = props.classes,
          classNameProp = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'primary' : _props$color,
          value = props.value,
          valueBuffer = props.valueBuffer,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'indeterminate' : _props$variant,
          other = objectWithoutProperties(props, ["classes", "className", "color", "value", "valueBuffer", "variant"]);

      var className = clsx(classes.root, color === 'primary' && classes.colorPrimary, color === 'secondary' && classes.colorSecondary, variant === 'determinate' && classes.determinate, variant === 'indeterminate' && classes.indeterminate, variant === 'buffer' && classes.buffer, variant === 'query' && classes.query, classNameProp);
      var dashedClass = clsx(classes.dashed, color === 'primary' && classes.dashedColorPrimary, color === 'secondary' && classes.dashedColorSecondary);
      var bar1ClassName = clsx(classes.bar, color === 'primary' && classes.barColorPrimary, color === 'secondary' && classes.barColorSecondary, (variant === 'indeterminate' || variant === 'query') && classes.bar1Indeterminate, variant === 'determinate' && classes.bar1Determinate, variant === 'buffer' && classes.bar1Buffer);
      var bar2ClassName = clsx(classes.bar, (variant === 'indeterminate' || variant === 'query') && classes.bar2Indeterminate, variant === 'buffer' && [color === 'primary' && classes.colorPrimary, color === 'secondary' && classes.colorSecondary, classes.bar2Buffer], variant !== 'buffer' && [color === 'primary' && classes.barColorPrimary, color === 'secondary' && classes.barColorSecondary]);
      var rootProps = {};
      var inlineStyles = {
        bar1: {},
        bar2: {}
      };

      if (variant === 'determinate' || variant === 'buffer') {
        if (value !== undefined) {
          rootProps['aria-valuenow'] = Math.round(value);
          inlineStyles.bar1.transform = "translateX(".concat(value - 100, "%)");
        } else {
          warning_1(false, 'Material-UI: you need to provide a value property ' + 'when using the determinate or buffer variant of LinearProgress .');
        }
      }

      if (variant === 'buffer') {
        if (valueBuffer !== undefined) {
          inlineStyles.bar2.transform = "translateX(".concat((valueBuffer || 0) - 100, "%)");
        } else {
          warning_1(false, 'Material-UI: you need to provide a valueBuffer property ' + 'when using the buffer variant of LinearProgress.');
        }
      }

      return React__default.createElement("div", _extends_1({
        className: className,
        role: "progressbar"
      }, rootProps, {
        ref: ref
      }, other), variant === 'buffer' ? React__default.createElement("div", {
        className: dashedClass
      }) : null, React__default.createElement("div", {
        className: bar1ClassName,
        style: inlineStyles.bar1
      }), variant === 'determinate' ? null : React__default.createElement("div", {
        className: bar2ClassName,
        style: inlineStyles.bar2
      }));
    });
    LinearProgress.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary']),

      /**
       * The value of the progress indicator for the determinate and buffer variants.
       * Value between 0 and 100.
       */
      value: PropTypes__default.number,

      /**
       * The value for the buffer variant.
       * Value between 0 and 100.
       */
      valueBuffer: PropTypes__default.number,

      /**
       * The variant to use.
       * Use indeterminate or query when there is no progress value.
       */
      variant: PropTypes__default.oneOf(['determinate', 'indeterminate', 'buffer', 'query'])
    };
    var LinearProgress$1 = withStyles(styles$13, {
      name: 'MuiLinearProgress'
    })(LinearProgress);

    var styles$14 = {
      /* Styles applied to the root element. */
      root: {},

      /* Styles applied to the root element if `underline="none"`. */
      underlineNone: {
        textDecoration: 'none'
      },

      /* Styles applied to the root element if `underline="hover"`. */
      underlineHover: {
        textDecoration: 'none',
        '&:hover': {
          textDecoration: 'underline'
        }
      },

      /* Styles applied to the root element if `underline="always"`. */
      underlineAlways: {
        textDecoration: 'underline'
      },
      // Same reset as ButtonBase.root

      /* Styles applied to the root element if `component="button"`. */
      button: {
        position: 'relative',
        // Remove grey highlight
        WebkitTapHighlightColor: 'transparent',
        backgroundColor: 'transparent',
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 'none',
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: 'pointer',
        userSelect: 'none',
        verticalAlign: 'middle',
        '-moz-appearance': 'none',
        // Reset
        '-webkit-appearance': 'none',
        // Reset
        '&::-moz-focus-inner': {
          borderStyle: 'none' // Remove Firefox dotted outline.

        }
      }
    };
    var Link = React__default.forwardRef(function Link(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          component = _props$component === void 0 ? 'a' : _props$component,
          _props$color = props.color,
          color = _props$color === void 0 ? 'primary' : _props$color,
          TypographyClasses = props.TypographyClasses,
          _props$underline = props.underline,
          underline = _props$underline === void 0 ? 'hover' : _props$underline,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'inherit' : _props$variant,
          other = objectWithoutProperties(props, ["classes", "className", "component", "color", "TypographyClasses", "underline", "variant"]);

      return React__default.createElement(Typography$1, _extends_1({
        className: clsx(classes.root, component === 'button' && classes.button, classes["underline".concat(capitalize(underline))], className),
        classes: TypographyClasses,
        color: color,
        component: component,
        ref: ref,
        variant: variant
      }, other));
    });
    Link.propTypes = {
      /**
       * The content of the link.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the link.
       */
      color: PropTypes__default.oneOf(['default', 'error', 'inherit', 'primary', 'secondary', 'textPrimary', 'textSecondary']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * `classes` property applied to the [`Typography`](/api/typography/) element.
       */
      TypographyClasses: PropTypes__default.object,

      /**
       *  Controls when the link should have an underline.
       */
      underline: PropTypes__default.oneOf(['none', 'hover', 'always']),

      /**
       * Applies the theme typography styles.
       */
      variant: PropTypes__default.string
    };
    withStyles(styles$14, {
      name: 'MuiLink'
    })(Link);

    /**
     * @ignore - internal component.
     */

    var ListContext = React__default.createContext({});

    var styles$15 = {
      /* Styles applied to the root element. */
      root: {
        listStyle: 'none',
        margin: 0,
        padding: 0,
        position: 'relative'
      },

      /* Styles applied to the root element if `disablePadding={false}`. */
      padding: {
        paddingTop: 8,
        paddingBottom: 8
      },

      /* Styles applied to the root element if dense. */
      dense: {},

      /* Styles applied to the root element if a `subheader` is provided. */
      subheader: {
        paddingTop: 0
      }
    };
    var List = React__default.forwardRef(function List(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'ul' : _props$component,
          _props$dense = props.dense,
          dense = _props$dense === void 0 ? false : _props$dense,
          _props$disablePadding = props.disablePadding,
          disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,
          subheader = props.subheader,
          other = objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);

      var context = React__default.useMemo(function () {
        return {
          dense: dense
        };
      }, [dense]);
      return React__default.createElement(ListContext.Provider, {
        value: context
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader, className),
        ref: ref
      }, other), subheader, children));
    });
    List.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, compact vertical padding designed for keyboard and mouse input will be used for
       * the list and list items.
       * The property is available to descendant components as the `dense` context.
       */
      dense: PropTypes__default.bool,

      /**
       * If `true`, vertical padding will be removed from the list.
       */
      disablePadding: PropTypes__default.bool,

      /**
       * The content of the subheader, normally `ListSubheader`.
       */
      subheader: PropTypes__default.node
    };
    var List$1 = withStyles(styles$15, {
      name: 'MuiList'
    })(List);

    var styles$16 = function styles(theme) {
      return {
        /* Styles applied to the (normally root) `component` element. May be wrapped by a `container`. */
        root: {
          display: 'flex',
          justifyContent: 'flex-start',
          alignItems: 'center',
          position: 'relative',
          textDecoration: 'none',
          width: '100%',
          boxSizing: 'border-box',
          textAlign: 'left',
          paddingTop: 8,
          paddingBottom: 8,
          '&$focusVisible': {
            backgroundColor: theme.palette.action.selected
          },
          '&$selected, &$selected:hover': {
            backgroundColor: theme.palette.action.selected
          },
          '&$disabled': {
            opacity: 0.5
          }
        },

        /* Styles applied to the `container` element if `children` includes `ListItemSecondaryAction`. */
        container: {
          position: 'relative'
        },

        /* Styles applied to the `component`'s `focusVisibleClassName` property if `button={true}`. */
        focusVisible: {},

        /* Styles applied to the `component` element if dense. */
        dense: {
          paddingTop: 4,
          paddingBottom: 4
        },

        /* Styles applied to the `component` element if `alignItems="flex-start"`. */
        alignItemsFlexStart: {
          alignItems: 'flex-start'
        },

        /* Styles applied to the inner `component` element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the inner `component` element if `divider={true}`. */
        divider: {
          borderBottom: "1px solid ".concat(theme.palette.divider),
          backgroundClip: 'padding-box'
        },

        /* Styles applied to the inner `component` element if `disableGutters={false}`. */
        gutters: {
          paddingLeft: 16,
          paddingRight: 16
        },

        /* Styles applied to the inner `component` element if `button={true}`. */
        button: {
          transition: theme.transitions.create('background-color', {
            duration: theme.transitions.duration.shortest
          }),
          '&:hover': {
            textDecoration: 'none',
            backgroundColor: theme.palette.action.hover,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },

        /* Styles applied to the `component` element if `children` includes `ListItemSecondaryAction`. */
        secondaryAction: {
          // Add some space to avoid collision as `ListItemSecondaryAction`
          // is absolutely positioned.
          paddingRight: 48
        },

        /* Styles applied to the root element if `selected={true}`. */
        selected: {}
      };
    };
    var useEnhancedEffect$4 = typeof window === 'undefined' ? React__default.useEffect : React__default.useLayoutEffect;
    /**
     * Uses an additional container component if `ListItemSecondaryAction` is the last child.
     */

    var ListItem = React__default.forwardRef(function ListItem(props, ref) {
      var _props$alignItems = props.alignItems,
          alignItems = _props$alignItems === void 0 ? 'center' : _props$alignItems,
          autoFocus = props.autoFocus,
          _props$button = props.button,
          button = _props$button === void 0 ? false : _props$button,
          childrenProp = props.children,
          classes = props.classes,
          className = props.className,
          componentProp = props.component,
          _props$ContainerCompo = props.ContainerComponent,
          ContainerComponent = _props$ContainerCompo === void 0 ? 'li' : _props$ContainerCompo,
          _props$ContainerProps = props.ContainerProps;
      _props$ContainerProps = _props$ContainerProps === void 0 ? {} : _props$ContainerProps;

      var ContainerClassName = _props$ContainerProps.className,
          ContainerProps = objectWithoutProperties(_props$ContainerProps, ["className"]),
          dense = props.dense,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$disableGutters = props.disableGutters,
          disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
          _props$divider = props.divider,
          divider = _props$divider === void 0 ? false : _props$divider,
          focusVisibleClassName = props.focusVisibleClassName,
          _props$selected = props.selected,
          selected = _props$selected === void 0 ? false : _props$selected,
          other = objectWithoutProperties(props, ["alignItems", "autoFocus", "button", "children", "classes", "className", "component", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "divider", "focusVisibleClassName", "selected"]);

      var context = React__default.useContext(ListContext);
      var childContext = {
        dense: dense || context.dense || false,
        alignItems: alignItems
      };
      var listItemRef = React__default.useRef(null);
      useEnhancedEffect$4(function () {
        if (autoFocus) {
          if (listItemRef.current) {
            listItemRef.current.focus();
          } else {
            warning_1(false, 'Material-UI: unable to set focus to a ListItem whose component has not been rendered.');
          }
        }
      }, [autoFocus]);
      var children = React__default.Children.toArray(childrenProp);
      var hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ['ListItemSecondaryAction']);
      var handleOwnRef = React__default.useCallback(function (instance) {
        // #StrictMode ready
        listItemRef.current = ReactDOM__default.findDOMNode(instance);
      }, []);
      var handleRef = useForkRef(handleOwnRef, ref);

      var componentProps = _extends_1({
        className: clsx(classes.root, childContext.dense && classes.dense, !disableGutters && classes.gutters, divider && classes.divider, disabled && classes.disabled, button && classes.button, alignItems === 'flex-start' && classes.alignItemsFlexStart, hasSecondaryAction && classes.secondaryAction, selected && classes.selected, className),
        disabled: disabled
      }, other);

      var Component = componentProp || 'li';

      if (button) {
        componentProps.component = componentProp || 'div';
        componentProps.focusVisibleClassName = clsx(classes.focusVisible, focusVisibleClassName);
        Component = ButtonBase$1;
      }

      if (hasSecondaryAction) {
        // Use div by default.
        Component = !componentProps.component && !componentProp ? 'div' : Component; // Avoid nesting of li > li.

        if (ContainerComponent === 'li') {
          if (Component === 'li') {
            Component = 'div';
          } else if (componentProps.component === 'li') {
            componentProps.component = 'div';
          }
        }

        return React__default.createElement(ListContext.Provider, {
          value: childContext
        }, React__default.createElement(ContainerComponent, _extends_1({
          className: clsx(classes.container, ContainerClassName),
          ref: handleRef
        }, ContainerProps), React__default.createElement(Component, componentProps, children), children.pop()));
      }

      return React__default.createElement(ListContext.Provider, {
        value: childContext
      }, React__default.createElement(Component, _extends_1({
        ref: handleRef
      }, componentProps), children));
    });
    ListItem.propTypes = {
      /**
       * Defines the `align-items` style property.
       */
      alignItems: PropTypes__default.oneOf(['flex-start', 'center']),

      /**
       * If `true`, the list item will be focused during the first mount.
       * Focus will also be triggered if the value changes from false to true.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * If `true`, the list item will be a button (using `ButtonBase`).
       */
      button: PropTypes__default.bool,

      /**
       * The content of the component. If a `ListItemSecondaryAction` is used it must
       * be the last child.
       */
      children: chainPropTypes(PropTypes__default.node, function (props) {
        var children = React__default.Children.toArray(props.children); // React.Children.toArray(props.children).findLastIndex(isListItemSecondaryAction)

        var secondaryActionIndex = -1;

        for (var i = children.length - 1; i >= 0; i -= 1) {
          var child = children[i];

          if (isMuiElement(child, ['ListItemSecondaryAction'])) {
            secondaryActionIndex = i;
            break;
          }
        } //  is ListItemSecondaryAction the last child of ListItem


        if (secondaryActionIndex !== -1 && secondaryActionIndex !== children.length - 1) {
          return new Error('Material-UI: you used an element after ListItemSecondaryAction. ' + 'For ListItem to detect that it has a secondary action ' + 'you must pass it as the last child to ListItem.');
        }

        return null;
      }),

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       * By default, it's a `li` when `button` is `false` and a `div` when `button` is `true`.
       */
      component: PropTypes__default.elementType,

      /**
       * The container component used when a `ListItemSecondaryAction` is the last child.
       */
      ContainerComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the container component if used.
       */
      ContainerProps: PropTypes__default.object,

      /**
       * If `true`, compact vertical padding designed for keyboard and mouse input will be used.
       */
      dense: PropTypes__default.bool,

      /**
       * If `true`, the list item will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the left and right padding is removed.
       */
      disableGutters: PropTypes__default.bool,

      /**
       * If `true`, a 1px light border is added to the bottom of the list item.
       */
      divider: PropTypes__default.bool,

      /**
       * @ignore
       */
      focusVisibleClassName: PropTypes__default.string,

      /**
       * Use to apply selected styling.
       */
      selected: PropTypes__default.bool
    };
    var ListItem$1 = withStyles(styles$16, {
      name: 'MuiListItem'
    })(ListItem);

    var styles$17 = {
      /* Styles applied to the root element. */
      root: {
        minWidth: 56,
        flexShrink: 0
      },

      /* Styles applied to the root element when the parent `ListItem` uses `alignItems="flex-start"`. */
      alignItemsFlexStart: {
        marginTop: 8
      }
    };
    /**
     * A simple wrapper to apply `List` styles to an `Avatar`.
     */

    var ListItemAvatar = React__default.forwardRef(function ListItemAvatar(props, ref) {
      var classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["classes", "className"]);

      var context = React__default.useContext(ListContext);
      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, context.alignItems === 'flex-start' && classes.alignItemsFlexStart, className),
        ref: ref
      }, other));
    });
    ListItemAvatar.propTypes = {
      /**
       * The content of the component  normally `Avatar`.
       */
      children: PropTypes__default.element.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    withStyles(styles$17, {
      name: 'MuiListItemAvatar'
    })(ListItemAvatar);

    var styles$18 = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          minWidth: 56,
          color: theme.palette.action.active,
          flexShrink: 0,
          display: 'inline-flex'
        }
      };
    };
    /**
     * A simple wrapper to apply `List` styles to an `Icon` or `SvgIcon`.
     */

    var ListItemIcon = React__default.forwardRef(function ListItemIcon(props, ref) {
      var classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other));
    });
    ListItemIcon.propTypes = {
      /**
       * The content of the component, normally `Icon`, `SvgIcon`,
       * or a `@material-ui/icons` SVG icon element.
       */
      children: PropTypes__default.element.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    withStyles(styles$18, {
      name: 'MuiListItemIcon'
    })(ListItemIcon);

    var styles$19 = {
      /* Styles applied to the root element. */
      root: {
        position: 'absolute',
        right: 16,
        top: '50%',
        transform: 'translateY(-50%)'
      }
    };
    /**
     * Must be used as the last child of ListItem to function properly.
     */

    var ListItemSecondaryAction = React__default.forwardRef(function ListItemSecondaryAction(props, ref) {
      var classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other));
    });
    ListItemSecondaryAction.propTypes = {
      /**
       * The content of the component, normally an `IconButton` or selection control.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    ListItemSecondaryAction.muiName = 'ListItemSecondaryAction';
    withStyles(styles$19, {
      name: 'MuiListItemSecondaryAction'
    })(ListItemSecondaryAction);

    var styles$1a = {
      /* Styles applied to the root element. */
      root: {
        flex: '1 1 auto',
        minWidth: 0,
        marginTop: 4,
        marginBottom: 4
      },

      /* Styles applied to the `Typography` components if primary and secondary are set. */
      multiline: {
        marginTop: 6,
        marginBottom: 6
      },

      /* Styles applied to the `Typography` components if dense. */
      dense: {},

      /* Styles applied to the root element if `inset={true}`. */
      inset: {
        paddingLeft: 56
      },

      /* Styles applied to the primary `Typography` component. */
      primary: {},

      /* Styles applied to the secondary `Typography` component. */
      secondary: {}
    };
    var ListItemText = React__default.forwardRef(function ListItemText(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          _props$disableTypogra = props.disableTypography,
          disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
          _props$inset = props.inset,
          inset = _props$inset === void 0 ? false : _props$inset,
          primaryProp = props.primary,
          primaryTypographyProps = props.primaryTypographyProps,
          secondaryProp = props.secondary,
          secondaryTypographyProps = props.secondaryTypographyProps,
          other = objectWithoutProperties(props, ["children", "classes", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"]);

      var _React$useContext = React__default.useContext(ListContext),
          dense = _React$useContext.dense;

      var primary = primaryProp != null ? primaryProp : children;

      if (primary != null && primary.type !== Typography$1 && !disableTypography) {
        primary = React__default.createElement(Typography$1, _extends_1({
          variant: dense ? 'body2' : 'body1',
          className: classes.primary,
          component: "span"
        }, primaryTypographyProps), primary);
      }

      var secondary = secondaryProp;

      if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
        secondary = React__default.createElement(Typography$1, _extends_1({
          variant: "body2",
          className: classes.secondary,
          color: "textSecondary"
        }, secondaryTypographyProps), secondary);
      }

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline, className),
        ref: ref
      }, other), primary, secondary);
    });
    ListItemText.propTypes = {
      /**
       * Alias for the `primary` property.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the children won't be wrapped by a Typography component.
       * This can be useful to render an alternative Typography variant by wrapping
       * the `children` (or `primary`) text, and optional `secondary` text
       * with the Typography component.
       */
      disableTypography: PropTypes__default.bool,

      /**
       * If `true`, the children will be indented.
       * This should be used if there is no left avatar or left icon.
       */
      inset: PropTypes__default.bool,

      /**
       * The main content element.
       */
      primary: PropTypes__default.node,

      /**
       * These props will be forwarded to the primary typography component
       * (as long as disableTypography is not `true`).
       */
      primaryTypographyProps: PropTypes__default.object,

      /**
       * The secondary content element.
       */
      secondary: PropTypes__default.node,

      /**
       * These props will be forwarded to the secondary typography component
       * (as long as disableTypography is not `true`).
       */
      secondaryTypographyProps: PropTypes__default.object
    };
    withStyles(styles$1a, {
      name: 'MuiListItemText'
    })(ListItemText);

    var styles$1b = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          boxSizing: 'border-box',
          lineHeight: '48px',
          listStyle: 'none',
          color: theme.palette.text.secondary,
          fontFamily: theme.typography.fontFamily,
          fontWeight: theme.typography.fontWeightMedium,
          fontSize: theme.typography.pxToRem(14)
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          color: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="inherit"`. */
        colorInherit: {
          color: 'inherit'
        },

        /* Styles applied to the inner `component` element if `disableGutters={false}`. */
        gutters: {
          paddingLeft: 16,
          paddingRight: 16
        },

        /* Styles applied to the root element if `inset={true}`. */
        inset: {
          paddingLeft: 72
        },

        /* Styles applied to the root element if `disableSticky={false}`. */
        sticky: {
          position: 'sticky',
          top: 0,
          zIndex: 1,
          backgroundColor: 'inherit'
        }
      };
    };
    var ListSubheader = React__default.forwardRef(function ListSubheader(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'default' : _props$color,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'li' : _props$component,
          _props$disableGutters = props.disableGutters,
          disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
          _props$disableSticky = props.disableSticky,
          disableSticky = _props$disableSticky === void 0 ? false : _props$disableSticky,
          _props$inset = props.inset,
          inset = _props$inset === void 0 ? false : _props$inset,
          other = objectWithoutProperties(props, ["classes", "className", "color", "component", "disableGutters", "disableSticky", "inset"]);

      return React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, color !== 'default' && classes["color".concat(capitalize(color))], inset && classes.inset, !disableSticky && classes.sticky, !disableGutters && classes.gutters, className),
        ref: ref
      }, other));
    });
    ListSubheader.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['default', 'primary', 'inherit']),

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the List Subheader will not have gutters.
       */
      disableGutters: PropTypes__default.bool,

      /**
       * If `true`, the List Subheader will not stick to the top during scroll.
       */
      disableSticky: PropTypes__default.bool,

      /**
       * If `true`, the List Subheader will be indented.
       */
      inset: PropTypes__default.bool
    };
    withStyles(styles$1b, {
      name: 'MuiListSubheader'
    })(ListSubheader);

    function getOffsetTop(rect, vertical) {
      var offset = 0;

      if (typeof vertical === 'number') {
        offset = vertical;
      } else if (vertical === 'center') {
        offset = rect.height / 2;
      } else if (vertical === 'bottom') {
        offset = rect.height;
      }

      return offset;
    }

    function getOffsetLeft(rect, horizontal) {
      var offset = 0;

      if (typeof horizontal === 'number') {
        offset = horizontal;
      } else if (horizontal === 'center') {
        offset = rect.width / 2;
      } else if (horizontal === 'right') {
        offset = rect.width;
      }

      return offset;
    }

    function getTransformOriginValue(transformOrigin) {
      return [transformOrigin.horizontal, transformOrigin.vertical].map(function (n) {
        return typeof n === 'number' ? "".concat(n, "px") : n;
      }).join(' ');
    } // Sum the scrollTop between two elements.


    function getScrollParent(parent, child) {
      var element = child;
      var scrollTop = 0;

      while (element && element !== parent) {
        element = element.parentNode;
        scrollTop += element.scrollTop;
      }

      return scrollTop;
    }

    function getAnchorEl(anchorEl) {
      return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
    }

    var styles$1c = {
      /* Styles applied to the `Paper` component. */
      paper: {
        position: 'absolute',
        overflowY: 'auto',
        overflowX: 'hidden',
        // So we see the popover when it's empty.
        // It's most likely on issue on userland.
        minWidth: 16,
        minHeight: 16,
        maxWidth: 'calc(100% - 32px)',
        maxHeight: 'calc(100% - 32px)',
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 'none'
      }
    };

    var Popover =
    /*#__PURE__*/
    function (_React$Component) {
      inherits(Popover, _React$Component);

      function Popover() {
        var _this;

        classCallCheck(this, Popover);

        _this = possibleConstructorReturn(this, getPrototypeOf(Popover).call(this));
        _this.handleGetOffsetTop = getOffsetTop;
        _this.handleGetOffsetLeft = getOffsetLeft;

        _this.componentWillUnmount = function () {
          _this.handleResize.clear();
        };

        _this.setPositioningStyles = function (element) {
          var positioning = _this.getPositioningStyle(element);

          if (positioning.top !== null) {
            element.style.top = positioning.top;
          }

          if (positioning.left !== null) {
            element.style.left = positioning.left;
          }

          element.style.transformOrigin = positioning.transformOrigin;
        };

        _this.getPositioningStyle = function (element) {
          var _this$props = _this.props,
              anchorEl = _this$props.anchorEl,
              anchorReference = _this$props.anchorReference,
              marginThreshold = _this$props.marginThreshold; // Check if the parent has requested anchoring on an inner content node

          var contentAnchorOffset = _this.getContentAnchorOffset(element);

          var elemRect = {
            width: element.offsetWidth,
            height: element.offsetHeight
          }; // Get the transform origin point on the element itself

          var transformOrigin = _this.getTransformOrigin(elemRect, contentAnchorOffset);

          if (anchorReference === 'none') {
            return {
              top: null,
              left: null,
              transformOrigin: getTransformOriginValue(transformOrigin)
            };
          } // Get the offset of of the anchoring element


          var anchorOffset = _this.getAnchorOffset(contentAnchorOffset); // Calculate element positioning


          var top = anchorOffset.top - transformOrigin.vertical;
          var left = anchorOffset.left - transformOrigin.horizontal;
          var bottom = top + elemRect.height;
          var right = left + elemRect.width; // Use the parent window of the anchorEl if provided

          var containerWindow = ownerWindow(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account

          var heightThreshold = containerWindow.innerHeight - marginThreshold;
          var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting

          if (top < marginThreshold) {
            var diff = top - marginThreshold;
            top -= diff;
            transformOrigin.vertical += diff;
          } else if (bottom > heightThreshold) {
            var _diff = bottom - heightThreshold;

            top -= _diff;
            transformOrigin.vertical += _diff;
          }

          warning_1(elemRect.height <= heightThreshold || !elemRect.height || !heightThreshold, ['Material-UI: the popover component is too tall.', "Some part of it can not be seen on the screen (".concat(elemRect.height - heightThreshold, "px)."), 'Please consider adding a `max-height` to improve the user-experience.'].join('\n')); // Check if the horizontal axis needs shifting

          if (left < marginThreshold) {
            var _diff2 = left - marginThreshold;

            left -= _diff2;
            transformOrigin.horizontal += _diff2;
          } else if (right > widthThreshold) {
            var _diff3 = right - widthThreshold;

            left -= _diff3;
            transformOrigin.horizontal += _diff3;
          }

          return {
            top: "".concat(top, "px"),
            left: "".concat(left, "px"),
            transformOrigin: getTransformOriginValue(transformOrigin)
          };
        };

        _this.handleEntering = function (element) {
          if (_this.props.onEntering) {
            _this.props.onEntering(element);
          }

          _this.setPositioningStyles(element);
        };

        if (typeof window !== 'undefined') {
          _this.handleResize = debounce_1(function () {
            // Because we debounce the event, the open property might no longer be true
            // when the callback resolves.
            if (!_this.props.open) {
              return;
            }

            _this.setPositioningStyles(_this.paperRef);
          }, 166); // Corresponds to 10 frames at 60 Hz.
        }

        return _this;
      }

      createClass(Popover, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this.props.action) {
            this.props.action({
              updatePosition: this.handleResize
            });
          }
        }
      }, {
        key: "getAnchorOffset",
        // Returns the top/left offset of the position
        // to attach to on the anchor element (or body if none is provided)
        value: function getAnchorOffset(contentAnchorOffset) {
          var _this$props2 = this.props,
              anchorEl = _this$props2.anchorEl,
              anchorOrigin = _this$props2.anchorOrigin,
              anchorReference = _this$props2.anchorReference,
              anchorPosition = _this$props2.anchorPosition;

          if (anchorReference === 'anchorPosition') {
            warning_1(anchorPosition, 'Material-UI: you need to provide a `anchorPosition` property when using ' + '<Popover anchorReference="anchorPosition" />.');
            return anchorPosition;
          }

          var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover

          var anchorElement = resolvedAnchorEl instanceof Element ? resolvedAnchorEl : ownerDocument(this.paperRef).body;
          var anchorRect = anchorElement.getBoundingClientRect();
          var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';
          return {
            top: anchorRect.top + this.handleGetOffsetTop(anchorRect, anchorVertical),
            left: anchorRect.left + this.handleGetOffsetLeft(anchorRect, anchorOrigin.horizontal)
          };
        } // Returns the vertical offset of inner content to anchor the transform on if provided

      }, {
        key: "getContentAnchorOffset",
        value: function getContentAnchorOffset(element) {
          var _this$props3 = this.props,
              getContentAnchorEl = _this$props3.getContentAnchorEl,
              anchorReference = _this$props3.anchorReference;
          var contentAnchorOffset = 0;

          if (getContentAnchorEl && anchorReference === 'anchorEl') {
            var contentAnchorEl = getContentAnchorEl(element);

            if (contentAnchorEl && element.contains(contentAnchorEl)) {
              var scrollTop = getScrollParent(element, contentAnchorEl);
              contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
            } // != the default value


            warning_1(this.props.anchorOrigin.vertical === 'top', ['Material-UI: you can not change the default `anchorOrigin.vertical` value ', 'when also providing the `getContentAnchorEl` property to the popover component.', 'Only use one of the two properties.', 'Set `getContentAnchorEl` to `null | undefined`' + ' or leave `anchorOrigin.vertical` unchanged.'].join('\n'));
          }

          return contentAnchorOffset;
        } // Return the base transform origin using the element
        // and taking the content anchor offset into account if in use

      }, {
        key: "getTransformOrigin",
        value: function getTransformOrigin(elemRect) {
          var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var transformOrigin = this.props.transformOrigin;
          return {
            vertical: this.handleGetOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
            horizontal: this.handleGetOffsetLeft(elemRect, transformOrigin.horizontal)
          };
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;

          var _this$props4 = this.props,
              action = _this$props4.action,
              anchorEl = _this$props4.anchorEl,
              anchorOrigin = _this$props4.anchorOrigin,
              anchorPosition = _this$props4.anchorPosition,
              anchorReference = _this$props4.anchorReference,
              children = _this$props4.children,
              classes = _this$props4.classes,
              containerProp = _this$props4.container,
              elevation = _this$props4.elevation,
              getContentAnchorEl = _this$props4.getContentAnchorEl,
              innerRef = _this$props4.innerRef,
              marginThreshold = _this$props4.marginThreshold,
              ModalClasses = _this$props4.ModalClasses,
              onEnter = _this$props4.onEnter,
              onEntered = _this$props4.onEntered,
              onEntering = _this$props4.onEntering,
              onExit = _this$props4.onExit,
              onExited = _this$props4.onExited,
              onExiting = _this$props4.onExiting,
              open = _this$props4.open,
              _this$props4$PaperPro = _this$props4.PaperProps,
              PaperProps = _this$props4$PaperPro === void 0 ? {} : _this$props4$PaperPro,
              transformOrigin = _this$props4.transformOrigin,
              TransitionComponent = _this$props4.TransitionComponent,
              transitionDurationProp = _this$props4.transitionDuration,
              _this$props4$Transiti = _this$props4.TransitionProps,
              TransitionProps = _this$props4$Transiti === void 0 ? {} : _this$props4$Transiti,
              other = objectWithoutProperties(_this$props4, ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "classes", "container", "elevation", "getContentAnchorEl", "innerRef", "marginThreshold", "ModalClasses", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"]);

          var transitionDuration = transitionDurationProp;

          if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
            transitionDuration = undefined;
          } // If the container prop is provided, use that
          // If the anchorEl prop is provided, use its parent body element as the container
          // If neither are provided let the Modal take care of choosing the container


          var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : undefined);
          return React__default.createElement(Modal$1, _extends_1({
            classes: ModalClasses,
            container: container,
            open: open,
            ref: innerRef,
            BackdropProps: {
              invisible: true
            }
          }, other), React__default.createElement(TransitionComponent, _extends_1({
            appear: true,
            in: open,
            onEnter: onEnter,
            onEntered: onEntered,
            onExit: onExit,
            onExited: onExited,
            onExiting: onExiting,
            timeout: transitionDuration
          }, TransitionProps, {
            onEntering: createChainedFunction(this.handleEntering, TransitionProps.onEntering)
          }), React__default.createElement(Paper$1, _extends_1({
            elevation: elevation,
            ref: function ref(_ref) {
              // #StrictMode ready
              _this2.paperRef = ReactDOM__default.findDOMNode(_ref);
            }
          }, PaperProps, {
            className: clsx(classes.paper, PaperProps.className)
          }), React__default.createElement(EventListener, {
            target: "window",
            onResize: this.handleResize
          }), children)));
        }
      }]);

      return Popover;
    }(React__default.Component);

    Popover.propTypes = {
      /**
       * This is callback property. It's called by the component on mount.
       * This is useful when you want to trigger an action programmatically.
       * It currently only supports updatePosition() action.
       *
       * @param {object} actions This object contains all possible actions
       * that can be triggered programmatically.
       */
      action: PropTypes__default.func,

      /**
       * This is the DOM element, or a function that returns the DOM element,
       * that may be used to set the position of the popover.
       */
      anchorEl: chainPropTypes(PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]), function (props) {
        if (props.open && props.anchorReference === 'anchorEl') {
          var resolvedAnchorEl = getAnchorEl(props.anchorEl);

          if (resolvedAnchorEl instanceof Element) {
            var box = resolvedAnchorEl.getBoundingClientRect();

            if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
              return new Error(['Material-UI: the `anchorEl` prop provided to the component is invalid.', 'The node element should be visible.'].join('\n'));
            }
          } else {
            return new Error(['Material-UI: the `anchorEl` prop provided to the component is invalid.', "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")].join('\n'));
          }
        }

        return null;
      }),

      /**
       * This is the point on the anchor where the popover's
       * `anchorEl` will attach to. This is not used when the
       * anchorReference is 'anchorPosition'.
       *
       * Options:
       * vertical: [top, center, bottom];
       * horizontal: [left, center, right].
       */
      anchorOrigin: PropTypes__default.shape({
        horizontal: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.oneOf(['left', 'center', 'right'])]).isRequired,
        vertical: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.oneOf(['top', 'center', 'bottom'])]).isRequired
      }),

      /**
       * This is the position that may be used
       * to set the position of the popover.
       * The coordinates are relative to
       * the application's client area.
       */
      anchorPosition: PropTypes__default.shape({
        left: PropTypes__default.number.isRequired,
        top: PropTypes__default.number.isRequired
      }),

      /*
       * This determines which anchor prop to refer to to set
       * the position of the popover.
       */
      anchorReference: PropTypes__default.oneOf(['anchorEl', 'anchorPosition', 'none']),

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * A node, component instance, or function that returns either.
       * The `container` will passed to the Modal component.
       * By default, it uses the body of the anchorEl's top-level document object,
       * so it's simply `document.body` most of the time.
       */
      container: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),

      /**
       * The elevation of the popover.
       */
      elevation: PropTypes__default.number,

      /**
       * This function is called in order to retrieve the content anchor element.
       * It's the opposite of the `anchorEl` property.
       * The content anchor element should be an element inside the popover.
       * It's used to correctly scroll and set the position of the popover.
       * The positioning strategy tries to make the content anchor element just above the
       * anchor element.
       */
      getContentAnchorEl: PropTypes__default.func,

      /**
       * @ignore
       * from `withForwardRef`
       */
      innerRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Specifies how close to the edge of the window the popover can appear.
       */
      marginThreshold: PropTypes__default.number,

      /**
       * `classes` property applied to the [`Modal`](/api/modal/) element.
       */
      ModalClasses: PropTypes__default.object,

      /**
       * Callback fired when the component requests to be closed.
       *
       * @param {object} event The event source of the callback.
       * @param {string} reason Can be:`"escapeKeyDown"`, `"backdropClick"`
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired before the component is entering.
       */
      onEnter: PropTypes__default.func,

      /**
       * Callback fired when the component has entered.
       */
      onEntered: PropTypes__default.func,

      /**
       * Callback fired when the component is entering.
       */
      onEntering: PropTypes__default.func,

      /**
       * Callback fired before the component is exiting.
       */
      onExit: PropTypes__default.func,

      /**
       * Callback fired when the component has exited.
       */
      onExited: PropTypes__default.func,

      /**
       * Callback fired when the component is exiting.
       */
      onExiting: PropTypes__default.func,

      /**
       * If `true`, the popover is visible.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * Properties applied to the [`Paper`](/api/paper/) element.
       */
      PaperProps: PropTypes__default.shape({
        component: elementTypeAcceptingRef$1
      }),

      /**
       * This is the point on the popover which
       * will attach to the anchor's origin.
       *
       * Options:
       * vertical: [top, center, bottom, x(px)];
       * horizontal: [left, center, right, x(px)].
       */
      transformOrigin: PropTypes__default.shape({
        horizontal: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.oneOf(['left', 'center', 'right'])]).isRequired,
        vertical: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.oneOf(['top', 'center', 'bottom'])]).isRequired
      }),

      /**
       * The component used for the transition.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * Set to 'auto' to automatically calculate transition time based on height.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      }), PropTypes__default.oneOf(['auto'])]),

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    Popover.defaultProps = {
      anchorReference: 'anchorEl',
      anchorOrigin: {
        vertical: 'top',
        horizontal: 'left'
      },
      elevation: 8,
      marginThreshold: 16,
      transformOrigin: {
        vertical: 'top',
        horizontal: 'left'
      },
      TransitionComponent: Grow$1,
      transitionDuration: 'auto'
    };
    var Popover$1 = withStyles(styles$1c, {
      name: 'MuiPopover'
    })(withForwardedRef(Popover));

    function nextItem(list, item, disableListWrap) {
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }

      return disableListWrap ? null : list.firstChild;
    }

    function previousItem(list, item, disableListWrap) {
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }

      return disableListWrap ? null : list.lastChild;
    }

    function textCriteriaMatches(nextFocus, textCriteria) {
      if (textCriteria === undefined) {
        return true;
      }

      var text = nextFocus.innerText;

      if (text === undefined) {
        // jsdom doesn't support innerText
        text = nextFocus.textContent;
      }

      if (text === undefined) {
        return false;
      }

      text = text.trim().toLowerCase();

      if (text.length === 0) {
        return false;
      }

      if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
      }

      return text.indexOf(textCriteria.keys.join('')) === 0;
    }

    function moveFocus(list, currentFocus, disableListWrap, traversalFunction, textCriteria) {
      var wrappedOnce = false;
      var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);

      while (nextFocus) {
        // Prevent infinite loop.
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return false;
          }

          wrappedOnce = true;
        } // Move to the next element.


        if (!nextFocus.hasAttribute('tabindex') || nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true' || !textCriteriaMatches(nextFocus, textCriteria)) {
          nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
          break;
        }
      }

      if (nextFocus) {
        nextFocus.focus();
        return true;
      }

      return false;
    }

    var useEnhancedEffect$5 = typeof window === 'undefined' ? React__default.useEffect : React__default.useLayoutEffect;
    var MenuList = React__default.forwardRef(function MenuList(props, ref) {
      var actions = props.actions,
          autoFocus = props.autoFocus,
          className = props.className,
          onKeyDown = props.onKeyDown,
          _props$disableListWra = props.disableListWrap,
          disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
          other = objectWithoutProperties(props, ["actions", "autoFocus", "className", "onKeyDown", "disableListWrap"]);

      var listRef = React__default.useRef(null);
      var textCriteriaRef = React__default.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
      });
      useEnhancedEffect$5(function () {
        if (autoFocus) {
          listRef.current.focus();
        }
      }, [autoFocus]);
      React__default.useImperativeHandle(actions, function () {
        return {
          adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
            // Let's ignore that piece of logic if users are already overriding the width
            // of the menu.
            var noExplicitWidth = !listRef.current.style.width;

            if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
              var scrollbarSize = "".concat(getScrollbarSize(true), "px");
              listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
              listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
            }

            return listRef.current;
          }
        };
      }, []);

      var handleKeyDown = function handleKeyDown(event) {
        var list = listRef.current;
        var key = event.key;
        var currentFocus = ownerDocument(list).activeElement;

        if ((key === 'ArrowUp' || key === 'ArrowDown') && (!currentFocus || currentFocus && !list.contains(currentFocus))) {
          moveFocus(list, null, disableListWrap, nextItem);
        } else if (key === 'ArrowDown') {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, nextItem);
        } else if (key === 'ArrowUp') {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, previousItem);
        } else if (key === 'Home') {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, nextItem);
        } else if (key === 'End') {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, previousItem);
        } else if (key.length === 1) {
          var criteria = textCriteriaRef.current;
          var lowerKey = key.toLowerCase();
          var currTime = performance.now();

          if (criteria.keys.length > 0) {
            // Reset
            if (currTime - criteria.lastTime > 500) {
              criteria.keys = [];
              criteria.repeating = true;
              criteria.previousKeyMatched = true;
            } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
              criteria.repeating = false;
            }
          }

          criteria.lastTime = currTime;
          criteria.keys.push(lowerKey);
          var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);

          if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, nextItem, criteria))) {
            event.preventDefault();
          } else {
            criteria.previousKeyMatched = false;
          }
        }

        if (onKeyDown) {
          onKeyDown(event);
        }
      };

      var handleOwnRef = React__default.useCallback(function (instance) {
        // #StrictMode ready
        listRef.current = ReactDOM__default.findDOMNode(instance);
      }, []);
      var handleRef = useForkRef(handleOwnRef, ref);
      return React__default.createElement(List$1, _extends_1({
        role: "menu",
        ref: handleRef,
        className: className,
        onKeyDown: handleKeyDown,
        tabIndex: autoFocus ? 0 : -1
      }, other));
    });
    MenuList.propTypes = {
      /**
       * @ignore
       */
      actions: PropTypes__default.shape({
        current: PropTypes__default.object
      }),

      /**
       * If `true`, the list will be focused during the first mount.
       * Focus will also be triggered if the value changes from false to true.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * MenuList contents, normally `MenuItem`s.
       */
      children: PropTypes__default.node,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the menu items will not wrap focus.
       */
      disableListWrap: PropTypes__default.bool,

      /**
       * @ignore
       */
      onKeyDown: PropTypes__default.func
    };

    var RTL_ORIGIN = {
      vertical: 'top',
      horizontal: 'right'
    };
    var LTR_ORIGIN = {
      vertical: 'top',
      horizontal: 'left'
    };
    var styles$1d = {
      /* Styles applied to the `Paper` component. */
      paper: {
        // specZ: The maximum height of a simple menu should be one or more rows less than the view
        // height. This ensures a tapable area outside of the simple menu with which to dismiss
        // the menu.
        maxHeight: 'calc(100% - 96px)',
        // Add iOS momentum scrolling.
        WebkitOverflowScrolling: 'touch'
      },

      /* Styles applied to the `List` component via `MenuList`. */
      list: {
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 'none'
      }
    };
    var Menu = React__default.forwardRef(function Menu(props, ref) {
      var autoFocusProp = props.autoFocus,
          children = props.children,
          classes = props.classes,
          _props$disableAutoFoc = props.disableAutoFocusItem,
          disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
          _props$MenuListProps = props.MenuListProps,
          MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps,
          onClose = props.onClose,
          onEntering = props.onEntering,
          open = props.open,
          _props$PaperProps = props.PaperProps,
          PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
          PopoverClasses = props.PopoverClasses,
          theme = props.theme,
          _props$transitionDura = props.transitionDuration,
          transitionDuration = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
          other = objectWithoutProperties(props, ["autoFocus", "children", "classes", "disableAutoFocusItem", "MenuListProps", "onClose", "onEntering", "open", "PaperProps", "PopoverClasses", "theme", "transitionDuration", "variant"]);

      var autoFocus = autoFocusProp !== undefined ? autoFocusProp : !disableAutoFocusItem;
      var menuListActionsRef = React__default.useRef(null);
      var firstValidItemRef = React__default.useRef(null);
      var firstSelectedItemRef = React__default.useRef(null);

      var getContentAnchorEl = function getContentAnchorEl() {
        return firstSelectedItemRef.current || firstValidItemRef.current;
      };

      var handleEntering = function handleEntering(element) {
        if (menuListActionsRef.current) {
          menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }

        if (onEntering) {
          onEntering(element);
        }
      };

      var handleListKeyDown = function handleListKeyDown(event) {
        if (event.key === 'Tab') {
          event.preventDefault();

          if (onClose) {
            onClose(event, 'tabKeyDown');
          }
        }
      };

      var firstValidElementIndex = null;
      var firstSelectedIndex = null;
      var items = React__default.Children.map(children, function (child, index) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        warning_1(child.type !== React__default.Fragment, ["Material-UI: the Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));

        if (firstValidElementIndex === null) {
          firstValidElementIndex = index;
        }

        var newChildProps = null;

        if (variant === 'selectedMenu' && firstSelectedIndex === null && child.props.selected && !child.props.disabled) {
          firstSelectedIndex = index;
          newChildProps = {};

          if (autoFocus) {
            newChildProps.autoFocus = true;
          }

          if (child.props.tabIndex === undefined) {
            newChildProps.tabIndex = 0;
          }

          newChildProps.ref = function (instance) {
            // #StrictMode ready
            firstSelectedItemRef.current = ReactDOM__default.findDOMNode(instance);
            setRef(child.ref, instance);
          };
        } else if (index === firstValidElementIndex) {
          newChildProps = {
            ref: function ref(instance) {
              // #StrictMode ready
              firstValidItemRef.current = ReactDOM__default.findDOMNode(instance);
              setRef(child.ref, instance);
            }
          };
        }

        if (newChildProps !== null) {
          return React__default.cloneElement(child, newChildProps);
        }

        return child;
      });
      return React__default.createElement(Popover$1, _extends_1({
        getContentAnchorEl: getContentAnchorEl,
        classes: PopoverClasses,
        onClose: onClose,
        onEntering: handleEntering,
        anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
        transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
        PaperProps: _extends_1({}, PaperProps, {
          classes: _extends_1({}, PaperProps.classes, {
            root: classes.paper
          })
        }),
        open: open,
        ref: ref,
        transitionDuration: transitionDuration
      }, other), React__default.createElement(MenuList, _extends_1({
        onKeyDown: handleListKeyDown,
        actions: menuListActionsRef,
        autoFocus: autoFocus && firstSelectedIndex === null
      }, MenuListProps, {
        className: clsx(classes.list, MenuListProps.className)
      }), items));
    });
    Menu.propTypes = {
      /**
       * The DOM element used to set the position of the menu.
       */
      anchorEl: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),

      /**
       * If `true` (default), the menu list (possibly a particular item depending on the menu variant) will receive focus on open.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * Menu contents, normally `MenuItem`s.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * Same as `autoFocus=false`.
       * @deprecated Use `autoFocus` instead
       */
      disableAutoFocusItem: PropTypes__default.bool,

      /**
       * Properties applied to the [`MenuList`](/api/menu-list/) element.
       */
      MenuListProps: PropTypes__default.object,

      /**
       * Callback fired when the component requests to be closed.
       *
       * @param {object} event The event source of the callback
       * @param {string} reason Can be:`"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired before the Menu enters.
       */
      onEnter: PropTypes__default.func,

      /**
       * Callback fired when the Menu has entered.
       */
      onEntered: PropTypes__default.func,

      /**
       * Callback fired when the Menu is entering.
       */
      onEntering: PropTypes__default.func,

      /**
       * Callback fired before the Menu exits.
       */
      onExit: PropTypes__default.func,

      /**
       * Callback fired when the Menu has exited.
       */
      onExited: PropTypes__default.func,

      /**
       * Callback fired when the Menu is exiting.
       */
      onExiting: PropTypes__default.func,

      /**
       * If `true`, the menu is visible.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * @ignore
       */
      PaperProps: PropTypes__default.object,

      /**
       * `classes` property applied to the [`Popover`](/api/popover/) element.
       */
      PopoverClasses: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The length of the transition in `ms`, or 'auto'
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      }), PropTypes__default.oneOf(['auto'])]),

      /**
       * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
       * and the vertical alignment relative to the anchor element.
       */
      variant: PropTypes__default.oneOf(['menu', 'selectedMenu'])
    };
    var Menu$1 = withStyles(styles$1d, {
      name: 'MuiMenu',
      withTheme: true
    })(Menu);

    var styles$1e = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({}, theme.typography.subtitle1, {
          minHeight: 48,
          paddingTop: 4,
          paddingBottom: 4,
          boxSizing: 'border-box',
          width: 'auto',
          overflow: 'hidden',
          whiteSpace: 'nowrap'
        }),

        /* Styles applied to the root element if `disableGutters={false}`. */
        gutters: {
          paddingLeft: 16,
          paddingRight: 16
        },

        /* Styles applied to the root element if `selected={true}`. */
        selected: {}
      };
    };
    var MenuItem = React__default.forwardRef(function MenuItem(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          component = _props$component === void 0 ? 'li' : _props$component,
          _props$disableGutters = props.disableGutters,
          disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
          _props$role = props.role,
          role = _props$role === void 0 ? 'menuitem' : _props$role,
          selected = props.selected,
          tabIndexProp = props.tabIndex,
          other = objectWithoutProperties(props, ["classes", "className", "component", "disableGutters", "role", "selected", "tabIndex"]);

      var tabIndex;

      if (!props.disabled) {
        tabIndex = tabIndexProp !== undefined ? tabIndexProp : -1;
      }

      return React__default.createElement(ListItem$1, _extends_1({
        button: true,
        role: role,
        tabIndex: tabIndex,
        component: component,
        selected: selected,
        disableGutters: disableGutters,
        className: clsx(classes.root, selected && classes.selected, !disableGutters && classes.gutters, className),
        ref: ref
      }, other));
    });
    MenuItem.propTypes = {
      /**
       * Menu item contents.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * @ignore
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the left and right padding is removed.
       */
      disableGutters: PropTypes__default.bool,

      /**
       * @ignore
       */
      role: PropTypes__default.string,

      /**
       * @ignore
       */
      selected: PropTypes__default.bool,

      /**
       * @ignore
       */
      tabIndex: PropTypes__default.number
    };
    var MenuItem$1 = withStyles(styles$1e, {
      name: 'MuiMenuItem'
    })(MenuItem);

    var styles$1f = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'flex',
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'center',
          background: theme.palette.background.default,
          padding: 8
        },

        /* Styles applied to the root element if `position="bottom"`. */
        positionBottom: {
          position: 'fixed',
          bottom: 0,
          left: 0,
          right: 0,
          zIndex: theme.zIndex.mobileStepper
        },

        /* Styles applied to the root element if `position="top"`. */
        positionTop: {
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          zIndex: theme.zIndex.mobileStepper
        },

        /* Styles applied to the root element if `position="static"`. */
        positionStatic: {},

        /* Styles applied to the dots container if `variant="dots"`. */
        dots: {
          display: 'flex',
          flexDirection: 'row'
        },

        /* Styles applied to each dot if `variant="dots"`. */
        dot: {
          backgroundColor: theme.palette.action.disabled,
          borderRadius: '50%',
          width: 8,
          height: 8,
          margin: '0 2px'
        },

        /* Styles applied to a dot if `variant="dots"` and this is the active step. */
        dotActive: {
          backgroundColor: theme.palette.primary.main
        },

        /* Styles applied to the Linear Progress component if `variant="progress"`. */
        progress: {
          width: '50%'
        }
      };
    };
    var MobileStepper = React__default.forwardRef(function MobileStepper(props, ref) {
      var _props$activeStep = props.activeStep,
          activeStep = _props$activeStep === void 0 ? 0 : _props$activeStep,
          backButton = props.backButton,
          classes = props.classes,
          className = props.className,
          LinearProgressProps = props.LinearProgressProps,
          nextButton = props.nextButton,
          _props$position = props.position,
          position = _props$position === void 0 ? 'bottom' : _props$position,
          steps = props.steps,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'dots' : _props$variant,
          other = objectWithoutProperties(props, ["activeStep", "backButton", "classes", "className", "LinearProgressProps", "nextButton", "position", "steps", "variant"]);

      return React__default.createElement(Paper$1, _extends_1({
        square: true,
        elevation: 0,
        className: clsx(classes.root, classes["position".concat(capitalize(position))], className),
        ref: ref
      }, other), backButton, variant === 'text' && React__default.createElement(React__default.Fragment, null, activeStep + 1, " / ", steps), variant === 'dots' && React__default.createElement("div", {
        className: classes.dots
      }, toConsumableArray(new Array(steps)).map(function (_, index) {
        return React__default.createElement("div", {
          // eslint-disable-next-line react/no-array-index-key
          key: index,
          className: clsx(classes.dot, index === activeStep && classes.dotActive)
        });
      })), variant === 'progress' && React__default.createElement(LinearProgress$1, _extends_1({
        className: classes.progress,
        variant: "determinate",
        value: Math.ceil(activeStep / (steps - 1) * 100)
      }, LinearProgressProps)), nextButton);
    });
    MobileStepper.propTypes = {
      /**
       * Set the active step (zero based index).
       * Defines which dot is highlighted when the variant is 'dots'.
       */
      activeStep: PropTypes__default.number,

      /**
       * A back button element. For instance, it can be a `Button` or an `IconButton`.
       */
      backButton: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Properties applied to the `LinearProgress` element.
       */
      LinearProgressProps: PropTypes__default.object,

      /**
       * A next button element. For instance, it can be a `Button` or an `IconButton`.
       */
      nextButton: PropTypes__default.node,

      /**
       * Set the positioning type.
       */
      position: PropTypes__default.oneOf(['bottom', 'top', 'static']),

      /**
       * The total steps.
       */
      steps: PropTypes__default.number.isRequired,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['text', 'dots', 'progress'])
    };
    withStyles(styles$1f, {
      name: 'MuiMobileStepper'
    })(MobileStepper);

    /**
     * @ignore - internal component.
     */

    var NativeSelectInput = React__default.forwardRef(function NativeSelectInput(props, ref) {
      var classes = props.classes,
          className = props.className,
          disabled = props.disabled,
          IconComponent = props.IconComponent,
          inputRef = props.inputRef,
          name = props.name,
          onChange = props.onChange,
          value = props.value,
          variant = props.variant,
          other = objectWithoutProperties(props, ["classes", "className", "disabled", "IconComponent", "inputRef", "name", "onChange", "value", "variant"]);

      return React__default.createElement("div", {
        className: classes.root
      }, React__default.createElement("select", _extends_1({
        className: clsx(classes.select, variant === 'filled' && classes.filled, variant === 'outlined' && classes.outlined, disabled && classes.disabled, className),
        name: name,
        disabled: disabled,
        onChange: onChange,
        value: value,
        ref: inputRef || ref
      }, other)), React__default.createElement(IconComponent, {
        className: classes.icon
      }));
    });
    NativeSelectInput.propTypes = {
      /**
       * The option elements to populate the select with.
       * Can be some `<option>` elements.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the select element.
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the select will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * The icon that displays the arrow.
       */
      IconComponent: PropTypes__default.elementType,

      /**
       * Use that property to pass a ref callback to the native select element.
       * @deprecated
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Name attribute of the `select` or hidden `input` element.
       */
      name: PropTypes__default.string,

      /**
       * Callback function fired when a menu item is selected.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * The input value.
       */
      value: PropTypes__default.any,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };

    /**
     * @ignore - internal component.
     */

    var ArrowDropDownIcon = createSvgIcon(React__default.createElement("path", {
      d: "M7 10l5 5 5-5z"
    }), 'ArrowDropDown');

    var styles$1g = function styles(theme) {
      return {
        /* Styles applied to the `Input` component `root` class. */
        root: {
          position: 'relative',
          width: '100%'
        },

        /* Styles applied to the `Input` component `select` class. */
        select: {
          '-moz-appearance': 'none',
          // Reset
          '-webkit-appearance': 'none',
          // Reset
          // When interacting quickly, the text can end up selected.
          // Native select can't be selected either.
          userSelect: 'none',
          paddingRight: 32,
          borderRadius: 0,
          // Reset
          width: 'calc(100% - 32px)',
          minWidth: 16,
          // So it doesn't collapse.
          cursor: 'pointer',
          '&:focus': {
            // Show that it's not an text input
            backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
            borderRadius: 0 // Reset Chrome style

          },
          // Remove IE 11 arrow
          '&::-ms-expand': {
            display: 'none'
          },
          '&$disabled': {
            cursor: 'default'
          },
          '&[multiple]': {
            height: 'auto'
          },
          '&:not([multiple]) option, &:not([multiple]) optgroup': {
            backgroundColor: theme.palette.background.paper
          }
        },

        /* Styles applied to the `Input` component if `variant="filled"`. */
        filled: {
          width: 'calc(100% - 44px)'
        },

        /* Styles applied to the `Input` component if `variant="outlined"`. */
        outlined: {
          width: 'calc(100% - 46px)',
          borderRadius: theme.shape.borderRadius
        },

        /* Styles applied to the `Input` component `selectMenu` class. */
        selectMenu: {
          width: 'auto',
          // Fix Safari textOverflow
          height: 'auto',
          // Reset
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap',
          overflow: 'hidden'
        },

        /* Styles applied to the `Input` component `disabled` class. */
        disabled: {},

        /* Styles applied to the `Input` component `icon` class. */
        icon: {
          // We use a position absolute over a flexbox in order to forward the pointer events
          // to the input.
          position: 'absolute',
          right: 0,
          top: 'calc(50% - 12px)',
          // Center vertically
          color: theme.palette.action.active,
          'pointer-events': 'none' // Don't block pointer events on the select under the icon.

        }
      };
    };
    var defaultInput = React__default.createElement(Input$1, null);
    /**
     * An alternative to `<Select native />` with a much smaller bundle size footprint.
     */

    var NativeSelect = React__default.forwardRef(function NativeSelect(props, ref) {
      var children = props.children,
          classes = props.classes,
          _props$IconComponent = props.IconComponent,
          IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
          _props$input = props.input,
          input = _props$input === void 0 ? defaultInput : _props$input,
          inputProps = props.inputProps,
          muiFormControl = props.muiFormControl,
          variant = props.variant,
          other = objectWithoutProperties(props, ["children", "classes", "IconComponent", "input", "inputProps", "muiFormControl", "variant"]);

      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['variant']
      });
      return React__default.cloneElement(input, _extends_1({
        // Most of the logic is implemented in `NativeSelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: NativeSelectInput,
        inputProps: _extends_1({
          children: children,
          classes: classes,
          IconComponent: IconComponent,
          variant: fcs.variant,
          type: undefined
        }, inputProps, input ? input.props.inputProps : {}),
        ref: ref
      }, other));
    });
    NativeSelect.propTypes = {
      /**
       * The option elements to populate the select with.
       * Can be some `<option>` elements.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The icon that displays the arrow.
       */
      IconComponent: PropTypes__default.elementType,

      /**
       * An `Input` element; does not have to be a material-ui specific `Input`.
       */
      input: PropTypes__default.element,

      /**
       * Attributes applied to the `select` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * @ignore
       */
      muiFormControl: PropTypes__default.object,

      /**
       * Callback function fired when a menu item is selected.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * The input value.
       */
      value: PropTypes__default.any,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    NativeSelect.muiName = 'Select';
    withStyles(styles$1g, {
      name: 'MuiNativeSelect'
    })(withFormControlContext(NativeSelect));

    var styles$1h = function styles(theme) {
      var align = theme.direction === 'rtl' ? 'right' : 'left';
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'absolute',
          bottom: 0,
          right: 0,
          top: -5,
          left: 0,
          margin: 0,
          padding: 0,
          pointerEvents: 'none',
          borderRadius: theme.shape.borderRadius,
          borderStyle: 'solid',
          borderWidth: 1,
          // Match the Input Label
          transition: theme.transitions.create(["padding-".concat(align), 'border-color', 'border-width'], {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          })
        },

        /* Styles applied to the legend element. */
        legend: {
          textAlign: 'left',
          padding: 0,
          lineHeight: '11px',
          transition: theme.transitions.create('width', {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          })
        }
      };
    };
    /**
     * @ignore - internal component.
     */

    var NotchedOutline = React__default.forwardRef(function NotchedOutline(props, ref) {
      var children = props.children,
          classes = props.classes,
          className = props.className,
          labelWidthProp = props.labelWidth,
          notched = props.notched,
          style = props.style,
          theme = props.theme,
          other = objectWithoutProperties(props, ["children", "classes", "className", "labelWidth", "notched", "style", "theme"]);

      var align = theme.direction === 'rtl' ? 'right' : 'left';
      var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0;
      return React__default.createElement("fieldset", _extends_1({
        "aria-hidden": true,
        style: _extends_1(defineProperty({}, "padding".concat(capitalize(align)), 8 + (notched ? 0 : labelWidth / 2)), style),
        className: clsx(classes.root, className),
        ref: ref
      }, other), React__default.createElement("legend", {
        className: classes.legend,
        style: {
          // IE 11: fieldset with legend does not render
          // a border radius. This maintains consistency
          // by always having a legend rendered
          width: notched ? labelWidth : 0.01
        }
      }, React__default.createElement("span", {
        dangerouslySetInnerHTML: {
          __html: '&#8203;'
        }
      })));
    });
    NotchedOutline.propTypes = {
      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The width of the label.
       */
      labelWidth: PropTypes__default.number.isRequired,

      /**
       * If `true`, the outline is notched to accommodate the label.
       */
      notched: PropTypes__default.bool.isRequired,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object
    };
    var NotchedOutline$1 = withStyles(styles$1h, {
      name: 'PrivateNotchedOutline',
      withTheme: true
    })(NotchedOutline);

    var styles$1i = function styles(theme) {
      var borderColor = theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          '& $notchedOutline': {
            borderColor: borderColor
          },
          '&:hover $notchedOutline': {
            borderColor: theme.palette.text.primary,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              borderColor: borderColor
            }
          },
          '&$focused $notchedOutline': {
            borderColor: theme.palette.primary.main,
            borderWidth: 2
          },
          '&$error $notchedOutline': {
            borderColor: theme.palette.error.main
          },
          '&$disabled $notchedOutline': {
            borderColor: theme.palette.action.disabled
          }
        },

        /* Styles applied to the root element if the component is focused. */
        focused: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `startAdornment` is provided. */
        adornedStart: {
          paddingLeft: 14
        },

        /* Styles applied to the root element if `endAdornment` is provided. */
        adornedEnd: {
          paddingRight: 14
        },

        /* Styles applied to the root element if `error={true}`. */
        error: {},

        /* Styles applied to the root element if `multiline={true}`. */
        multiline: {
          padding: '18.5px 14px'
        },

        /* Styles applied to the `NotchedOutline` element. */
        notchedOutline: {},

        /* Styles applied to the `input` element. */
        input: {
          padding: '18.5px 14px'
        },

        /* Styles applied to the `input` element if `margin="dense"`. */
        inputMarginDense: {
          paddingTop: 15,
          paddingBottom: 15
        },

        /* Styles applied to the `input` element if `multiline={true}`. */
        inputMultiline: {
          padding: 0
        },

        /* Styles applied to the `input` element if `startAdornment` is provided. */
        inputAdornedStart: {
          paddingLeft: 0
        },

        /* Styles applied to the `input` element if `endAdornment` is provided. */
        inputAdornedEnd: {
          paddingRight: 0
        }
      };
    };
    var OutlinedInput = React__default.forwardRef(function OutlinedInput(props, ref) {
      var classes = props.classes,
          _props$fullWidth = props.fullWidth,
          fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
          _props$inputComponent = props.inputComponent,
          inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
          _props$labelWidth = props.labelWidth,
          labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,
          _props$multiline = props.multiline,
          multiline = _props$multiline === void 0 ? false : _props$multiline,
          notched = props.notched,
          _props$type = props.type,
          type = _props$type === void 0 ? 'text' : _props$type,
          other = objectWithoutProperties(props, ["classes", "fullWidth", "inputComponent", "labelWidth", "multiline", "notched", "type"]);

      return React__default.createElement(InputBase$1, _extends_1({
        renderPrefix: function renderPrefix(state) {
          return React__default.createElement(NotchedOutline$1, {
            className: classes.notchedOutline,
            labelWidth: labelWidth,
            notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
          });
        },
        classes: _extends_1({}, classes, {
          root: clsx(classes.root, classes.underline),
          notchedOutline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
      }, other));
    });
    OutlinedInput.propTypes = {
      /**
       * This property helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: PropTypes__default.string,

      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the wrapper element.
       */
      className: PropTypes__default.string,

      /**
       * The default `input` element value, useful when not controlling the component.
       */
      defaultValue: PropTypes__default.any,

      /**
       * If `true`, the `input` element will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * End `InputAdornment` for this component.
       */
      endAdornment: PropTypes__default.node,

      /**
       * If `true`, the input will indicate an error. This is normally obtained via context from
       * FormControl.
       */
      error: PropTypes__default.bool,

      /**
       * If `true`, the input will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * The component used for the native input.
       * Either a string to use a DOM element or a component.
       */
      inputComponent: PropTypes__default.elementType,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * The width of the label.
       */
      labelWidth: PropTypes__default.number,

      /**
       * If `dense`, will adjust vertical spacing. This is normally obtained via context from
       * FormControl.
       */
      margin: PropTypes__default.oneOf(['dense', 'none']),

      /**
       * If `true`, a textarea element will be rendered.
       */
      multiline: PropTypes__default.bool,

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * If `true`, the outline is notched to accommodate the label.
       */
      notched: PropTypes__default.bool,

      /**
       * Callback fired when the value is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * The short hint displayed in the input before the user enters a value.
       */
      placeholder: PropTypes__default.string,

      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: PropTypes__default.bool,

      /**
       * If `true`, the `input` element will be required.
       */
      required: PropTypes__default.bool,

      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Start `InputAdornment` for this component.
       */
      startAdornment: PropTypes__default.node,

      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       */
      type: PropTypes__default.string,

      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: PropTypes__default.any
    };
    OutlinedInput.muiName = 'Input';
    var OutlinedInput$1 = withStyles(styles$1i, {
      name: 'MuiOutlinedInput'
    })(OutlinedInput);

    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.15.0
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    var timeoutDuration = 0;
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        timeoutDuration = 1;
        break;
      }
    }

    function microtaskDebounce(fn) {
      var called = false;
      return function () {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(function () {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      var scheduled = false;
      return function () {
        if (!scheduled) {
          scheduled = true;
          setTimeout(function () {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      var window = element.ownerDocument.defaultView;
      var css = window.getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent$1(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well

      var _getStyleComputedProp = getStyleComputedProperty(element),
          overflow = _getStyleComputedProp.overflow,
          overflowX = _getStyleComputedProp.overflowX,
          overflowY = _getStyleComputedProp.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent$1(getParentNode(element));
    }

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      var noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      var offsetParent = element.offsetParent || null;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      var nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TH, TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      var nodeName = element.nodeName;

      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      var start = order ? element1 : element2;
      var end = order ? element2 : element1;

      // Get common ancestor container
      var range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      var commonAncestorContainer = range.commonAncestorContainer;

      // Both nodes are inside #document

      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      var element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

      var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      var nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element) {
      var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      var modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      var sideA = axis === 'x' ? 'Left' : 'Top';
      var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
    }

    function getWindowSizes(document) {
      var body = document.body;
      var html = document.documentElement;
      var computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var classCallCheck$1 = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass$1 = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();





    var defineProperty$2 = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends$1({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      var rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          var scrollTop = getScroll(element, 'top');
          var scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
      var width = sizes.width || element.clientWidth || result.right - result.left;
      var height = sizes.height || element.clientHeight || result.bottom - result.top;

      var horizScrollbar = element.offsetWidth - width;
      var vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
      var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isIE10 = isIE(10);
      var isHTML = parent.nodeName === 'HTML';
      var childrenRect = getBoundingClientRect(children);
      var parentRect = getBoundingClientRect(parent);
      var scrollParent = getScrollParent$1(children);

      var styles = getStyleComputedProperty(parent);
      var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
      var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop, 10);
        var marginLeft = parseFloat(styles.marginLeft, 10);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
      var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var html = element.ownerDocument.documentElement;
      var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      var width = Math.max(html.clientWidth, window.innerWidth || 0);
      var height = Math.max(html.clientHeight, window.innerHeight || 0);

      var scrollTop = !excludeScroll ? getScroll(html) : 0;
      var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      var nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      var parentNode = getParentNode(element);
      if (!parentNode) {
        return false;
      }
      return isFixed(parentNode);
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      var el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
      var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      // NOTE: 1 DOM access here

      var boundaries = { top: 0, left: 0 };
      var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent$1(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          var _getWindowSizes = getWindowSizes(popper.ownerDocument),
              height = _getWindowSizes.height,
              width = _getWindowSizes.width;

          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      padding = padding || 0;
      var isPaddingNumber = typeof padding === 'number';
      boundaries.left += isPaddingNumber ? padding : padding.left || 0;
      boundaries.top += isPaddingNumber ? padding : padding.top || 0;
      boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
      boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

      return boundaries;
    }

    function getArea(_ref) {
      var width = _ref.width,
          height = _ref.height;

      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
      var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      var rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends$1({
          key: key
        }, rects[key], {
          area: getArea(rects[key])
        });
      }).sort(function (a, b) {
        return b.area - a.area;
      });

      var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
      });

      var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      var variation = placement.split('-')[1];

      return computedPlacement + (variation ? '-' + variation : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
      var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      var window = element.ownerDocument.defaultView;
      var styles = window.getComputedStyle(element);
      var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
      var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
      var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
      });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      var popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      var mainSide = isHoriz ? 'top' : 'left';
      var secondarySide = isHoriz ? 'left' : 'top';
      var measurement = isHoriz ? 'height' : 'width';
      var secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
          return cur[prop] === value;
        });
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      var match = find(arr, function (obj) {
        return obj[prop] === value;
      });
      return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
      // if popper is destroyed, don't perform any further update
      if (this.state.isDestroyed) {
        return;
      }

      var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
      };

      // compute reference element offsets
      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

      // store the computed placement inside `originalPlacement`
      data.originalPlacement = data.placement;

      data.positionFixed = this.options.positionFixed;

      // compute the popper offsets
      data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

      data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

      // run the modifiers
      data = runModifiers(this.modifiers, data);

      // the first `update` will call `onCreate` callback
      // the other ones will call `onUpdate` callback
      if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
      } else {
        this.options.onUpdate(data);
      }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
      });
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Destroys the popper.
     * @method
     * @memberof Popper
     */
    function destroy() {
      this.state.isDestroyed = true;

      // touch DOM only if `applyStyle` modifier is enabled
      if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
      }

      this.disableEventListeners();

      // remove the popper if user explicity asked for the deletion on destroy
      // do not use `remove` because IE11 doesn't support it
      if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
      }
      return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      var ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      var isBody = scrollParent.nodeName === 'BODY';
      var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      var scrollElement = getScrollParent$1(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
      if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
      }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger `onUpdate` callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
      if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
      }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
      // any property present in `data.styles` will be applied to the popper,
      // in this way we can make the 3rd party modifiers add custom styles to it
      // Be aware, modifiers could override the properties defined in the previous
      // lines of this modifier!
      setStyles(data.instance.popper, data.styles);

      // any property present in `data.attributes` will be applied to the popper,
      // they will be set as HTML attributes of the element
      setAttributes(data.instance.popper, data.attributes);

      // if arrowElement is defined and arrowStyles has some properties
      if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
      }

      return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
      // compute reference element offsets
      var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

      popper.setAttribute('x-placement', placement);

      // Apply `position` to popper before anything else because
      // without the position applied we can't guarantee correct computations
      setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

      return options;
    }

    /**
     * @function
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Boolean} shouldRound - If the offsets should be rounded at all
     * @returns {Object} The popper's position offsets rounded
     *
     * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
     * good as it can be within reason.
     * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
     *
     * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
     * as well on High DPI screens).
     *
     * Firefox prefers no rounding for positioning and does not have blurriness on
     * high DPI screens.
     *
     * Only horizontal placement and left/right values need to be considered.
     */
    function getRoundedOffsets(data, shouldRound) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;
      var round = Math.round,
          floor = Math.floor;

      var noRound = function noRound(v) {
        return v;
      };

      var referenceWidth = round(reference.width);
      var popperWidth = round(popper.width);

      var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
      var isVariation = data.placement.indexOf('-') !== -1;
      var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
      var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

      var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
      var verticalToInteger = !shouldRound ? noRound : round;

      return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
      };
    }

    var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
      var x = options.x,
          y = options.y;
      var popper = data.offsets.popper;

      // Remove this legacy support in Popper.js v2

      var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'applyStyle';
      }).gpuAcceleration;
      if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
      }
      var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

      var offsetParent = getOffsetParent(data.instance.popper);
      var offsetParentRect = getBoundingClientRect(offsetParent);

      // Styles
      var styles = {
        position: popper.position
      };

      var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

      var sideA = x === 'bottom' ? 'top' : 'bottom';
      var sideB = y === 'right' ? 'left' : 'right';

      // if gpuAcceleration is set to `true` and transform is supported,
      //  we use `translate3d` to apply the position to the popper we
      // automatically use the supported prefixed version if needed
      var prefixedProperty = getSupportedPropertyName('transform');

      // now, let's make a step back and look at this code closely (wtf?)
      // If the content of the popper grows once it's been positioned, it
      // may happen that the popper gets misplaced because of the new content
      // overflowing its reference element
      // To avoid this problem, we provide two options (x and y), which allow
      // the consumer to define the offset origin.
      // If we position a popper on top of a reference element, we can set
      // `x` to `top` to make the popper grow towards its top instead of
      // its bottom.
      var left = void 0,
          top = void 0;
      if (sideA === 'bottom') {
        // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
        // and not the bottom of the html element
        if (offsetParent.nodeName === 'HTML') {
          top = -offsetParent.clientHeight + offsets.bottom;
        } else {
          top = -offsetParentRect.height + offsets.bottom;
        }
      } else {
        top = offsets.top;
      }
      if (sideB === 'right') {
        if (offsetParent.nodeName === 'HTML') {
          left = -offsetParent.clientWidth + offsets.right;
        } else {
          left = -offsetParentRect.width + offsets.right;
        }
      } else {
        left = offsets.left;
      }
      if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
      } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
      }

      // Attributes
      var attributes = {
        'x-placement': data.placement
      };

      // Update `data` attributes, styles and arrowStyles
      data.attributes = _extends$1({}, attributes, data.attributes);
      data.styles = _extends$1({}, styles, data.styles);
      data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);

      return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
      });

      var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
      }
      return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
      var _data$offsets$arrow;

      // arrow depends on keepTogether in order to work
      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
      }

      var arrowElement = options.element;

      // if arrowElement is a string, suppose it's a CSS selector
      if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
          return data;
        }
      } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
          console.warn('WARNING: `arrow.element` must be child of its popper element!');
          return data;
        }
      }

      var placement = data.placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isVertical = ['left', 'right'].indexOf(placement) !== -1;

      var len = isVertical ? 'height' : 'width';
      var sideCapitalized = isVertical ? 'Top' : 'Left';
      var side = sideCapitalized.toLowerCase();
      var altSide = isVertical ? 'left' : 'top';
      var opSide = isVertical ? 'bottom' : 'right';
      var arrowElementSize = getOuterSizes(arrowElement)[len];

      //
      // extends keepTogether behavior making sure the popper and its
      // reference have enough pixels in conjunction
      //

      // top/left side
      if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
      }
      // bottom/right side
      if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
      }
      data.offsets.popper = getClientRect(data.offsets.popper);

      // compute center of the popper
      var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

      // Compute the sideValue using the updated popper offsets
      // take popper margin in account because we don't have this info available
      var css = getStyleComputedProperty(data.instance.popper);
      var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
      var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
      var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

      // prevent arrowElement from being placed not contiguously to its popper
      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

      data.arrowElement = arrowElement;
      data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

      return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
      if (variation === 'end') {
        return 'start';
      } else if (variation === 'start') {
        return 'end';
      }
      return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-end` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

    // Get rid of `auto` `auto-start` and `auto-end`
    var validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement) {
      var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var index = validPlacements.indexOf(placement);
      var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
      return counter ? arr.reverse() : arr;
    }

    var BEHAVIORS = {
      FLIP: 'flip',
      CLOCKWISE: 'clockwise',
      COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
      // if `inner` modifier is enabled, we can't use the `flip` modifier
      if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
      }

      if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
      }

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

      var placement = data.placement.split('-')[0];
      var placementOpposite = getOppositePlacement(placement);
      var variation = data.placement.split('-')[1] || '';

      var flipOrder = [];

      switch (options.behavior) {
        case BEHAVIORS.FLIP:
          flipOrder = [placement, placementOpposite];
          break;
        case BEHAVIORS.CLOCKWISE:
          flipOrder = clockwise(placement);
          break;
        case BEHAVIORS.COUNTERCLOCKWISE:
          flipOrder = clockwise(placement, true);
          break;
        default:
          flipOrder = options.behavior;
      }

      flipOrder.forEach(function (step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
          return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

        // flips variation if reference element overflows boundaries
        var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        // flips variation if popper content overflows boundaries
        var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

        var flippedVariation = flippedVariationByRef || flippedVariationByContent;

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
          // this boolean to detect any flip loop
          data.flipped = true;

          if (overlapsRef || overflowsBoundaries) {
            placement = flipOrder[index + 1];
          }

          if (flippedVariation) {
            variation = getOppositeVariation(variation);
          }

          data.placement = placement + (variation ? '-' + variation : '');

          // this object contains `position`, we want to preserve it along with
          // any additional property we may add in the future
          data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

          data = runModifiers(data.instance.modifiers, data, 'flip');
        }
      });
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var placement = data.placement.split('-')[0];
      var floor = Math.floor;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var side = isVertical ? 'right' : 'bottom';
      var opSide = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
      }
      if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
      }

      return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
      // separate value from unit
      var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
      var value = +split[1];
      var unit = split[2];

      // If it's not a number it's an operator, I guess
      if (!value) {
        return str;
      }

      if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
          case '%p':
            element = popperOffsets;
            break;
          case '%':
          case '%r':
          default:
            element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
      } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
          size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
          size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
      } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
      }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
      var offsets = [0, 0];

      // Use height if placement is left or right and index is 0 otherwise use width
      // in this way the first offset will use an axis and the second one
      // will use the other one
      var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

      // Split the offset string to obtain a list of values and operands
      // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
      var fragments = offset.split(/(\+|\-)/).map(function (frag) {
        return frag.trim();
      });

      // Detect if the offset string contains a pair of values or a single one
      // they could be separated by comma or space
      var divider = fragments.indexOf(find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
      }));

      if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
      }

      // If divider is found, we divide the list of values and operands to divide
      // them by ofset X and Y.
      var splitRegex = /\s*,\s*|\s+/;
      var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

      // Convert the values with units to absolute pixels to allow our computations
      ops = ops.map(function (op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
        // This aggregates any `+` or `-` sign that aren't considered operators
        // e.g.: 10 + +5 => [10, +, +5]
        .reduce(function (a, b) {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b;
            mergeWithPrevious = true;
            return a;
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b;
            mergeWithPrevious = false;
            return a;
          } else {
            return a.concat(b);
          }
        }, [])
        // Here we convert the string values into number values (in px)
        .map(function (str) {
          return toValue(str, measurement, popperOffsets, referenceOffsets);
        });
      });

      // Loop trough the offsets arrays and execute the operations
      ops.forEach(function (op, index) {
        op.forEach(function (frag, index2) {
          if (isNumeric(frag)) {
            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
          }
        });
      });
      return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, _ref) {
      var offset = _ref.offset;
      var placement = data.placement,
          _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var basePlacement = placement.split('-')[0];

      var offsets = void 0;
      if (isNumeric(+offset)) {
        offsets = [+offset, 0];
      } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
      }

      if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
      } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
      } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
      } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
      }

      data.popper = popper;
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
      var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

      // If offsetParent is the reference element, we really want to
      // go one step up and use the next offsetParent as reference to
      // avoid to make this modifier completely useless and look like broken
      if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
      }

      // NOTE: DOM access here
      // resets the popper's position so that the document size can be calculated excluding
      // the size of the popper element itself
      var transformProp = getSupportedPropertyName('transform');
      var popperStyles = data.instance.popper.style; // assignment to help minification
      var top = popperStyles.top,
          left = popperStyles.left,
          transform = popperStyles[transformProp];

      popperStyles.top = '';
      popperStyles.left = '';
      popperStyles[transformProp] = '';

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

      // NOTE: DOM access here
      // restores the original style properties after the offsets have been computed
      popperStyles.top = top;
      popperStyles.left = left;
      popperStyles[transformProp] = transform;

      options.boundaries = boundaries;

      var order = options.priority;
      var popper = data.offsets.popper;

      var check = {
        primary: function primary(placement) {
          var value = popper[placement];
          if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
            value = Math.max(popper[placement], boundaries[placement]);
          }
          return defineProperty$2({}, placement, value);
        },
        secondary: function secondary(placement) {
          var mainSide = placement === 'right' ? 'left' : 'top';
          var value = popper[mainSide];
          if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
          }
          return defineProperty$2({}, mainSide, value);
        }
      };

      order.forEach(function (placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends$1({}, popper, check[side](placement));
      });

      data.offsets.popper = popper;

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var shiftvariation = placement.split('-')[1];

      // if shift shiftvariation is specified, run the modifier
      if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
          start: defineProperty$2({}, side, reference[side]),
          end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
      }

      var refRect = data.offsets.reference;
      var bound = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'preventOverflow';
      }).boundaries;

      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
          return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
      } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
          return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

      var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

      popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

      data.placement = getOppositePlacement(placement);
      data.offsets.popper = getClientRect(popper);

      return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },

      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unit-less, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the `height`.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },

      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * A scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries"  or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
      },

      /**
       * Modifier used to make sure the reference and its popper stay near each other
       * without leaving any gap between the two. Especially useful when the arrow is
       * enabled and you want to ensure that it points to its reference element.
       * It cares only about the first axis. You can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },

      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjunction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
      },

      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: 'viewport',
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
      },

      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },

      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },

      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
      },

      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define your own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: undefined
      }
    };

    /**
     * The `dataObject` is an object containing all the information used by Popper.js.
     * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overridden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass an object with the same
     * structure of the `options` object, as the 3rd argument. For example:
     * ```
     * new Popper(ref, pop, {
     *   modifiers: {
     *     preventOverflow: { enabled: false }
     *   }
     * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
      /**
       * Popper's placement.
       * @prop {Popper.placements} placement='bottom'
       */
      placement: 'bottom',

      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,

      /**
       * Whether events (resize, scroll) are initially enabled.
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,

      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,

      /**
       * Callback called when the popper is created.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {},

      /**
       * Callback called when the popper is updated. This callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {},

      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js.
       * @prop {modifiers}
       */
      modifiers: modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

    // Utils
    // Methods
    var Popper = function () {
      /**
       * Creates a new Popper.js instance.
       * @class Popper
       * @param {Element|referenceObject} reference - The reference element used to position the popper
       * @param {Element} popper - The HTML / XML element used as the popper
       * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
       * @return {Object} instance - The generated Popper.js instance
       */
      function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck$1(this, Popper);

        this.scheduleUpdate = function () {
          return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce$1(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends$1({}, Popper.Defaults, options);

        // init state
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
          _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
          return _extends$1({
            name: name
          }, _this.options.modifiers[name]);
        })
        // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order;
        });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function (modifierOptions) {
          if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          // setup event listeners, they will take care of update the position in specific situations
          this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
      }

      // We can't use class properties because they don't get listed in the
      // class prototype and break stuff like Sinon stubs


      createClass$1(Popper, [{
        key: 'update',
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: 'destroy',
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }

        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

      }]);
      return Popper;
    }();

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10.
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */


    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;

    function flipPlacement(placement) {
      var direction = typeof window !== 'undefined' && document.body.getAttribute('dir') || 'ltr';

      if (direction !== 'rtl') {
        return placement;
      }

      switch (placement) {
        case 'bottom-end':
          return 'bottom-start';

        case 'bottom-start':
          return 'bottom-end';

        case 'top-end':
          return 'top-start';

        case 'top-start':
          return 'top-end';

        default:
          return placement;
      }
    }

    function getAnchorEl$1(anchorEl) {
      return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
    }
    /**
     * Poppers rely on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.
     */


    var Popper$1 = React__default.forwardRef(function Popper$1(props, ref) {
      var anchorEl = props.anchorEl,
          children = props.children,
          container = props.container,
          _props$disablePortal = props.disablePortal,
          disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
          _props$keepMounted = props.keepMounted,
          keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
          modifiers = props.modifiers,
          open = props.open,
          _props$placement = props.placement,
          placementProps = _props$placement === void 0 ? 'bottom' : _props$placement,
          _props$popperOptions = props.popperOptions,
          popperOptions = _props$popperOptions === void 0 ? {} : _props$popperOptions,
          _props$transition = props.transition,
          transition = _props$transition === void 0 ? false : _props$transition,
          other = objectWithoutProperties(props, ["anchorEl", "children", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "transition"]);

      var tooltipRef = React__default.useRef(null);
      var popperRef = React__default.useRef();

      var _React$useState = React__default.useState(!props.open),
          _React$useState2 = slicedToArray(_React$useState, 2),
          exited = _React$useState2[0],
          setExited = _React$useState2[1];

      var _React$useState3 = React__default.useState(),
          _React$useState4 = slicedToArray(_React$useState3, 2),
          placement = _React$useState4[0],
          setPlacement = _React$useState4[1];

      var handleRef = useForkRef(tooltipRef, ref);
      var handleOpen = React__default.useCallback(function () {
        var handlePopperUpdate = function handlePopperUpdate(data) {
          if (data.placement !== placement) {
            setPlacement(data.placement);
          }
        };

        var popperNode = tooltipRef.current;

        if (!popperNode || !anchorEl || !open) {
          return;
        }

        if (popperRef.current) {
          popperRef.current.destroy();
          popperRef.current = null;
        }

        popperRef.current = new Popper(getAnchorEl$1(anchorEl), popperNode, _extends_1({
          placement: flipPlacement(placementProps)
        }, popperOptions, {
          modifiers: _extends_1({}, disablePortal ? {} : {
            // It's using scrollParent by default, we can use the viewport when using a portal.
            preventOverflow: {
              boundariesElement: 'window'
            }
          }, modifiers, popperOptions.modifiers),
          // We could have been using a custom modifier like react-popper is doing.
          // But it seems this is the best public API for this use case.
          onCreate: createChainedFunction(handlePopperUpdate, popperOptions.onCreate),
          onUpdate: createChainedFunction(handlePopperUpdate, popperOptions.onUpdate)
        }));
      }, [anchorEl, disablePortal, modifiers, open, placement, placementProps, popperOptions]);

      var handleEnter = function handleEnter() {
        setExited(false);
      };

      var handleClose = function handleClose() {
        if (!popperRef.current) {
          return;
        }

        popperRef.current.destroy();
        popperRef.current = null;
      };

      var handleExited = function handleExited() {
        setExited(true);
        handleClose();
      };

      React__default.useEffect(function () {
        return function () {
          handleClose();
        };
      }, []);
      React__default.useEffect(function () {
        // Let's update the popper position.
        handleOpen();
      }, [handleOpen]);
      React__default.useEffect(function () {
        if (!open && !transition) {
          // Otherwise handleExited will call this.
          handleClose();
        }
      }, [open, transition]);

      if (!keepMounted && !open && (!transition || exited)) {
        return null;
      }

      var childProps = {
        placement: placement || flipPlacement(placementProps)
      };

      if (transition) {
        childProps.TransitionProps = {
          in: open,
          onEnter: handleEnter,
          onExited: handleExited
        };
      }

      return React__default.createElement(Portal, {
        onRendered: handleOpen,
        disablePortal: disablePortal,
        container: container
      }, React__default.createElement("div", _extends_1({
        ref: handleRef,
        role: "tooltip",
        style: {
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: 'absolute'
        }
      }, other), typeof children === 'function' ? children(childProps) : children));
    });
    Popper$1.propTypes = {
      /**
       * This is the DOM element, or a function that returns the DOM element,
       * that may be used to set the position of the popover.
       * The return value will passed as the reference object of the Popper
       * instance.
       */
      anchorEl: chainPropTypes(PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]), function (props) {
        if (props.open) {
          var resolvedAnchorEl = getAnchorEl$1(props.anchorEl);

          if (resolvedAnchorEl instanceof Element) {
            var box = resolvedAnchorEl.getBoundingClientRect();

            if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
              return new Error(['Material-UI: the `anchorEl` prop provided to the component is invalid.', 'The node element should be visible.'].join('\n'));
            }
          } else {
            return new Error(['Material-UI: the `anchorEl` prop provided to the component is invalid.', "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")].join('\n'));
          }
        }

        return null;
      }),

      /**
       * Popper render function or node.
       */
      children: PropTypes__default.oneOfType([PropTypes__default.node, PropTypes__default.func]).isRequired,

      /**
       * A node, component instance, or function that returns either.
       * The `container` will passed to the Modal component.
       * By default, it uses the body of the anchorEl's top-level document object,
       * so it's simply `document.body` most of the time.
       */
      container: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),

      /**
       * Disable the portal behavior.
       * The children stay within it's parent DOM hierarchy.
       */
      disablePortal: PropTypes__default.bool,

      /**
       * Always keep the children in the DOM.
       * This property can be useful in SEO situation or
       * when you want to maximize the responsiveness of the Popper.
       */
      keepMounted: PropTypes__default.bool,

      /**
       * Popper.js is based on a "plugin-like" architecture,
       * most of its features are fully encapsulated "modifiers".
       *
       * A modifier is a function that is called each time Popper.js needs to
       * compute the position of the popper.
       * For this reason, modifiers should be very performant to avoid bottlenecks.
       * To learn how to create a modifier, [read the modifiers documentation](https://github.com/FezVrasta/popper.js/blob/master/docs/_includes/popper-documentation.md#modifiers--object).
       */
      modifiers: PropTypes__default.object,

      /**
       * If `true`, the popper is visible.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * Popper placement.
       */
      placement: PropTypes__default.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

      /**
       * Options provided to the [`popper.js`](https://github.com/FezVrasta/popper.js) instance.
       */
      popperOptions: PropTypes__default.object,

      /**
       * Help supporting a react-transition-group/Transition component.
       */
      transition: PropTypes__default.bool
    };

    /**
     * @ignore - internal component.
     */

    var RadioButtonUncheckedIcon = createSvgIcon(React__default.createElement("path", {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), 'RadioButtonUnchecked');

    /**
     * @ignore - internal component.
     */

    var RadioButtonCheckedIcon = createSvgIcon(React__default.createElement("path", {
      d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
    }), 'RadioButtonChecked');

    var styles$1j = function styles(theme) {
      return {
        root: {
          position: 'relative',
          display: 'flex',
          '&$checked $layer': {
            transform: 'scale(1)',
            transition: theme.transitions.create('transform', {
              easing: theme.transitions.easing.easeOut,
              duration: theme.transitions.duration.shortest
            })
          }
        },
        layer: {
          position: 'absolute',
          transform: 'scale(0)',
          transition: theme.transitions.create('transform', {
            easing: theme.transitions.easing.easeIn,
            duration: theme.transitions.duration.shortest
          })
        },
        checked: {}
      };
    };
    /**
     * @ignore - internal component.
     */

    var _ref = React__default.createElement(RadioButtonUncheckedIcon, null);

    function RadioButtonIcon(props) {
      var checked = props.checked,
          classes = props.classes,
          className = props.className,
          other = objectWithoutProperties(props, ["checked", "classes", "className"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, checked && classes.checked, className)
      }, other), _ref, React__default.createElement(RadioButtonCheckedIcon, {
        className: classes.layer
      }));
    }

    RadioButtonIcon.propTypes = {
      /**
       * If `true`, the component is checked.
       */
      checked: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string
    };
    var RadioButtonIcon$1 = withStyles(styles$1j, {
      name: 'PrivateRadioButtonIcon'
    })(RadioButtonIcon);

    /**
     * @ignore - internal component.
     */

    var RadioGroupContext = React__default.createContext();

    var styles$1k = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          color: theme.palette.text.secondary
        },

        /* Styles applied to the root element if `checked={true}`. */
        checked: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          '&$checked': {
            color: theme.palette.primary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent'
              }
            }
          },
          '&$disabled': {
            color: theme.palette.action.disabled
          }
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          '&$checked': {
            color: theme.palette.secondary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent'
              }
            }
          },
          '&$disabled': {
            color: theme.palette.action.disabled
          }
        }
      };
    };
    var defaultCheckedIcon$1 = React__default.createElement(RadioButtonIcon$1, {
      checked: true
    });
    var defaultIcon$1 = React__default.createElement(RadioButtonIcon$1, null);
    var Radio = React__default.forwardRef(function Radio(props, ref) {
      var checkedProp = props.checked,
          classes = props.classes,
          _props$color = props.color,
          color = _props$color === void 0 ? 'secondary' : _props$color,
          nameProp = props.name,
          onChangeProp = props.onChange,
          other = objectWithoutProperties(props, ["checked", "classes", "color", "name", "onChange"]);

      var radioGroup = React__default.useContext(RadioGroupContext);
      var checked = checkedProp;
      var onChange = createChainedFunction(onChangeProp, radioGroup && radioGroup.onChange);
      var name = nameProp;

      if (radioGroup) {
        if (typeof checked === 'undefined') {
          checked = radioGroup.value === props.value;
        }

        if (typeof name === 'undefined') {
          name = radioGroup.name;
        }
      }

      return React__default.createElement(SwitchBase$1, _extends_1({
        color: color,
        type: "radio",
        icon: defaultIcon$1,
        checkedIcon: defaultCheckedIcon$1,
        classes: {
          root: clsx(classes.root, classes["color".concat(capitalize(color))]),
          checked: classes.checked,
          disabled: classes.disabled
        },
        name: name,
        checked: checked,
        onChange: onChange,
        ref: ref
      }, other));
    });
    Radio.propTypes = {
      /**
       * If `true`, the component is checked.
       */
      checked: PropTypes__default.bool,

      /**
       * The icon to display when the component is checked.
       */
      checkedIcon: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary', 'default']),

      /**
       * If `true`, the switch will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * The icon to display when the component is unchecked.
       */
      icon: PropTypes__default.node,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * Callback fired when the state is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       * @param {boolean} checked The `checked` value of the switch
       */
      onChange: PropTypes__default.func,

      /**
       * The input component property `type`.
       */
      type: PropTypes__default.string,

      /**
       * The value of the component.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$1k, {
      name: 'MuiRadio'
    })(Radio);

    var RadioGroup = React__default.forwardRef(function RadioGroup(props, ref) {
      var actions = props.actions,
          children = props.children,
          name = props.name,
          valueProp = props.value,
          onChange = props.onChange,
          other = objectWithoutProperties(props, ["actions", "children", "name", "value", "onChange"]);

      var rootRef = React__default.useRef(null);

      var _React$useRef = React__default.useRef(props.value != null),
          isControlled = _React$useRef.current;

      var _React$useState = React__default.useState(function () {
        if (!isControlled) {
          return props.defaultValue;
        }

        return null;
      }),
          _React$useState2 = slicedToArray(_React$useState, 2),
          valueState = _React$useState2[0],
          setValue = _React$useState2[1];

      React__default.useImperativeHandle(actions, function () {
        return {
          focus: function focus() {
            var input = rootRef.current.querySelector('input:not(:disabled):checked');

            if (!input) {
              input = rootRef.current.querySelector('input:not(:disabled)');
            }

            if (input) {
              input.focus();
            }
          }
        };
      }, []);
      React__default.useEffect(function () {
        warning_1(isControlled === (valueProp != null), ["Material-UI: A component is changing ".concat(isControlled ? 'a ' : 'an un', "controlled RadioGroup to be ").concat(isControlled ? 'un' : '', "controlled."), 'Input elements should not switch from uncontrolled to controlled (or vice versa).', 'Decide between using a controlled or uncontrolled RadioGroup ' + 'element for the lifetime of the component.', 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }, [valueProp, isControlled]);
      var value = isControlled ? valueProp : valueState;

      var handleChange = function handleChange(event) {
        if (!isControlled) {
          setValue(event.target.value);
        }

        if (onChange) {
          onChange(event, event.target.value);
        }
      };

      var context = {
        name: name,
        onChange: handleChange,
        value: value
      };
      var handleRef = useForkRef(ref, rootRef);
      return React__default.createElement(FormGroup$1, _extends_1({
        role: "radiogroup",
        ref: handleRef
      }, other), React__default.createElement(RadioGroupContext.Provider, {
        value: context
      }, children));
    });
    RadioGroup.propTypes = {
      /**
       * @ignore
       */
      actions: PropTypes__default.shape({
        current: PropTypes__default.object
      }),

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * The default `input` element value, useful when not controlling the component.
       */
      defaultValue: PropTypes__default.any,

      /**
       * The name used to reference the value of the control.
       */
      name: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * Callback fired when a radio button is selected.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       * @param {string} value The `value` of the selected radio button
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onKeyDown: PropTypes__default.func,

      /**
       * Value of the selected radio button.
       */
      value: PropTypes__default.string
    };

    /**
     * 
     * If you want the DOM element of a Material-UI component check out
     * [/getting-started/faq/#how-can-i-access-the-dom-element](FAQ: How can I access the DOM element?)
     * first.
     *
     * This component uses `findDOMNode` which is deprecated in React.StrictMode.
     *
     * Helper component to allow attaching a ref to a
     * wrapped element to access the underlying DOM element.
     *
     * It's highly inspired by https://github.com/facebook/react/issues/11401#issuecomment-340543801.
     * For example:
     * ```jsx
     * import React from 'react';
     * import RootRef from '@material-ui/core/RootRef';
     *
     * class MyComponent extends React.Component {
     *   constructor() {
     *     super();
     *     this.domRef = React.createRef();
     *   }
     *
     *   componentDidMount() {
     *     console.log(this.domRef.current); // DOM node
     *   }
     *
     *   render() {
     *     return (
     *       <RootRef rootRef={this.domRef}>
     *         <SomeChildComponent />
     *       </RootRef>
     *     );
     *   }
     * }
     * ```
     */

    var RootRef =
    /*#__PURE__*/
    function (_React$Component) {
      inherits(RootRef, _React$Component);

      function RootRef() {
        classCallCheck(this, RootRef);

        return possibleConstructorReturn(this, getPrototypeOf(RootRef).apply(this, arguments));
      }

      createClass(RootRef, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.ref = ReactDOM__default.findDOMNode(this);
          setRef(this.props.rootRef, this.ref);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var ref = ReactDOM__default.findDOMNode(this);

          if (prevProps.rootRef !== this.props.rootRef || this.ref !== ref) {
            if (prevProps.rootRef !== this.props.rootRef) {
              setRef(prevProps.rootRef, null);
            }

            this.ref = ref;
            setRef(this.props.rootRef, this.ref);
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.ref = null;
          setRef(this.props.rootRef, null);
        }
      }, {
        key: "render",
        value: function render() {
          return this.props.children;
        }
      }]);

      return RootRef;
    }(React__default.Component);

    RootRef.propTypes = {
      /**
       * The wrapped element.
       */
      children: PropTypes__default.element.isRequired,

      /**
       * Provide a way to access the DOM node of the wrapped element.
       * You can provide a callback ref or a `React.createRef()` ref.
       */
      rootRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]).isRequired
    };

    {
      RootRef.propTypes = exactProp(RootRef.propTypes);
    }

    function areEqualValues(a, b) {
      if (_typeof_1(b) === 'object' && b !== null) {
        return a === b;
      }

      return String(a) === String(b);
    }
    /**
     * @ignore - internal component.
     */


    var SelectInput = React__default.forwardRef(function SelectInput(props, ref) {
      var autoFocus = props.autoFocus,
          autoWidth = props.autoWidth,
          children = props.children,
          classes = props.classes,
          className = props.className,
          disabled = props.disabled,
          displayEmpty = props.displayEmpty,
          IconComponent = props.IconComponent,
          inputRef = props.inputRef,
          _props$MenuProps = props.MenuProps,
          MenuProps = _props$MenuProps === void 0 ? {} : _props$MenuProps,
          multiple = props.multiple,
          name = props.name,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onClose = props.onClose,
          onFocus = props.onFocus,
          onOpen = props.onOpen,
          openProp = props.open,
          readOnly = props.readOnly,
          renderValue = props.renderValue,
          required = props.required,
          SelectDisplayProps = props.SelectDisplayProps,
          tabIndexProp = props.tabIndex,
          _props$type = props.type,
          type = _props$type === void 0 ? 'hidden' : _props$type,
          value = props.value,
          variant = props.variant,
          other = objectWithoutProperties(props, ["autoFocus", "autoWidth", "children", "classes", "className", "disabled", "displayEmpty", "IconComponent", "inputRef", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "required", "SelectDisplayProps", "tabIndex", "type", "value", "variant"]);

      var displayRef = React__default.useRef(null);
      var ignoreNextBlur = React__default.useRef(false);

      var _React$useRef = React__default.useRef(props.open != null),
          isOpenControlled = _React$useRef.current;

      var _React$useState = React__default.useState(),
          _React$useState2 = slicedToArray(_React$useState, 2),
          menuMinWidthState = _React$useState2[0],
          setMenuMinWidthState = _React$useState2[1];

      var _React$useState3 = React__default.useState(false),
          _React$useState4 = slicedToArray(_React$useState3, 2),
          openState = _React$useState4[0],
          setOpenState = _React$useState4[1];

      var _React$useState5 = React__default.useState(0),
          _React$useState6 = slicedToArray(_React$useState5, 2),
          forceUpdate = _React$useState6[1];

      var handleRef = useForkRef(ref, inputRef);
      React__default.useImperativeHandle(handleRef, function () {
        return {
          focus: function focus() {
            displayRef.current.focus();
          },
          node: inputRef ? inputRef.current : null,
          value: value
        };
      }, [inputRef, value]);
      React__default.useEffect(function () {
        if (isOpenControlled && openProp) {
          // Focus the display node so the focus is restored on this element once
          // the menu is closed.
          displayRef.current.focus(); // Rerender with the resolve `displayRef` reference.

          forceUpdate(function (n) {
            return !n;
          });
        }

        if (autoFocus) {
          displayRef.current.focus();
        }
      }, [autoFocus, isOpenControlled, openProp]);

      var update = function update(open, event) {
        if (open) {
          if (onOpen) {
            onOpen(event);
          }
        } else if (onClose) {
          onClose(event);
        }

        if (!isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : displayRef.current.clientWidth);
          setOpenState(open);
        }
      };

      var handleClick = function handleClick(event) {
        // Opening the menu is going to blur the. It will be focused back when closed.
        ignoreNextBlur.current = true;
        update(true, event);
      };

      var handleClose = function handleClose(event) {
        update(false, event);
      };

      var handleItemClick = function handleItemClick(child) {
        return function (event) {
          if (!multiple) {
            update(false, event);
          }

          if (onChange) {
            var newValue;

            if (multiple) {
              newValue = Array.isArray(value) ? toConsumableArray(value) : [];
              var itemIndex = value.indexOf(child.props.value);

              if (itemIndex === -1) {
                newValue.push(child.props.value);
              } else {
                newValue.splice(itemIndex, 1);
              }
            } else {
              newValue = child.props.value;
            }

            event.persist();
            event.target = {
              value: newValue,
              name: name
            };
            onChange(event, child);
          }
        };
      };

      var handleBlur = function handleBlur(event) {
        if (ignoreNextBlur.current === true) {
          // The parent components are relying on the bubbling of the event.
          event.stopPropagation();
          ignoreNextBlur.current = false;
          return;
        }

        if (onBlur) {
          event.persist();
          event.target = {
            value: value,
            name: name
          };
          onBlur(event);
        }
      };

      var handleKeyDown = function handleKeyDown(event) {
        if (!readOnly) {
          var validKeys = [' ', 'ArrowUp', 'ArrowDown', // The native select doesn't respond to enter on MacOS, but it's recommended by
          // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
          'Enter'];

          if (validKeys.indexOf(event.key) !== -1) {
            event.preventDefault(); // Opening the menu is going to blur the. It will be focused back when closed.

            ignoreNextBlur.current = true;
            update(true, event);
          }
        }
      };

      var open = isOpenControlled && displayRef.current ? openProp : openState;
      delete other['aria-invalid'];
      var display;
      var displaySingle = '';
      var displayMultiple = [];
      var computeDisplay = false; // No need to display any value if the field is empty.

      if (isFilled(props) || displayEmpty) {
        if (renderValue) {
          display = renderValue(value);
        } else {
          computeDisplay = true;
        }
      }

      var items = React__default.Children.map(children, function (child) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        warning_1(child.type !== React__default.Fragment, ["Material-UI: the Select component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        var selected;

        if (multiple) {
          if (!Array.isArray(value)) {
            throw new Error('Material-UI: the `value` property must be an array ' + 'when using the `Select` component with `multiple`.');
          }

          selected = value.some(function (v) {
            return areEqualValues(v, child.props.value);
          });

          if (selected && computeDisplay) {
            displayMultiple.push(child.props.children);
          }
        } else {
          selected = areEqualValues(value, child.props.value);

          if (selected && computeDisplay) {
            displaySingle = child.props.children;
          }
        }

        return React__default.cloneElement(child, {
          onClick: handleItemClick(child),
          role: 'option',
          selected: selected,
          value: undefined,
          // The value is most likely not a valid HTML attribute.
          'data-value': child.props.value // Instead, we provide it as a data attribute.

        });
      });

      if (computeDisplay) {
        display = multiple ? displayMultiple.join(', ') : displaySingle;
      } // Avoid performing a layout computation in the render method.


      var menuMinWidth = menuMinWidthState;

      if (!autoWidth && isOpenControlled.current && displayRef.current) {
        menuMinWidth = displayRef.current.clientWidth;
      }

      var tabIndex;

      if (typeof tabIndexProp !== 'undefined') {
        tabIndex = tabIndexProp;
      } else {
        tabIndex = disabled ? null : 0;
      }

      return React__default.createElement("div", {
        className: classes.root
      }, React__default.createElement("div", _extends_1({
        className: clsx(classes.select, classes.selectMenu, disabled && classes.disabled, variant === 'filled' && classes.filled, variant === 'outlined' && classes.outlined, className),
        ref: displayRef,
        "aria-pressed": open ? 'true' : 'false',
        tabIndex: tabIndex,
        role: "button",
        "aria-owns": open ? "menu-".concat(name || '') : undefined,
        "aria-haspopup": "true",
        onKeyDown: handleKeyDown,
        onBlur: handleBlur,
        onClick: disabled || readOnly ? null : handleClick,
        onFocus: onFocus // The id can help with end-to-end testing automation.
        ,
        id: name ? "select-".concat(name) : undefined
      }, SelectDisplayProps), display != null ? display : React__default.createElement("span", {
        dangerouslySetInnerHTML: {
          __html: '&#8203;'
        }
      })), React__default.createElement("input", _extends_1({
        value: Array.isArray(value) ? value.join(',') : value,
        name: name,
        ref: handleRef,
        type: type,
        autoFocus: autoFocus
      }, other)), React__default.createElement(IconComponent, {
        className: classes.icon
      }), React__default.createElement(Menu$1, _extends_1({
        id: "menu-".concat(name || ''),
        anchorEl: displayRef.current,
        open: open,
        onClose: handleClose
      }, MenuProps, {
        MenuListProps: _extends_1({
          role: 'listbox',
          disableListWrap: true
        }, MenuProps.MenuListProps),
        PaperProps: _extends_1({}, MenuProps.PaperProps, {
          style: _extends_1({
            minWidth: menuMinWidth
          }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
        })
      }), items));
    });
    SelectInput.propTypes = {
      /**
       * @ignore
       */
      autoFocus: PropTypes__default.bool,

      /**
       * If true, the width of the popover will automatically be set according to the items inside the
       * menu, otherwise it will be at least the width of the select input.
       */
      autoWidth: PropTypes__default.bool,

      /**
       * The option elements to populate the select with.
       * Can be some `<MenuItem>` elements.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * The CSS class name of the select element.
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the select will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the selected item is displayed even if its value is empty.
       */
      displayEmpty: PropTypes__default.bool,

      /**
       * The icon that displays the arrow.
       */
      IconComponent: PropTypes__default.elementType,

      /**
       * Use that property to pass a ref callback to the native select element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Properties applied to the [`Menu`](/api/menu/) element.
       */
      MenuProps: PropTypes__default.object,

      /**
       * If true, `value` must be an array and the menu will support multiple selections.
       */
      multiple: PropTypes__default.bool,

      /**
       * Name attribute of the `select` or hidden `input` element.
       */
      name: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * Callback function fired when a menu item is selected.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       * @param {object} [child] The react element that was selected.
       */
      onChange: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be closed.
       * Use in controlled mode (see open).
       *
       * @param {object} event The event source of the callback
       */
      onClose: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocus: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be opened.
       * Use in controlled mode (see open).
       *
       * @param {object} event The event source of the callback
       */
      onOpen: PropTypes__default.func,

      /**
       * Control `select` open state.
       */
      open: PropTypes__default.bool,

      /**
       * @ignore
       */
      readOnly: PropTypes__default.bool,

      /**
       * Render the selected value.
       *
       * @param {*} value The `value` provided to the component.
       * @returns {ReactElement}
       */
      renderValue: PropTypes__default.func,

      /**
       * @ignore
       */
      required: PropTypes__default.bool,

      /**
       * Properties applied to the clickable div element.
       */
      SelectDisplayProps: PropTypes__default.object,

      /**
       * @ignore
       */
      tabIndex: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),

      /**
       * @ignore
       */
      type: PropTypes__default.string,

      /**
       * The input value.
       */
      value: PropTypes__default.any.isRequired,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };

    var styles$1l = styles$1g;
    var defaultInput$1 = React__default.createElement(Input$1, null);
    var Select = React__default.forwardRef(function Select(props, ref) {
      var _props$autoWidth = props.autoWidth,
          autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth,
          children = props.children,
          classes = props.classes,
          _props$displayEmpty = props.displayEmpty,
          displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty,
          _props$IconComponent = props.IconComponent,
          IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
          _props$input = props.input,
          input = _props$input === void 0 ? defaultInput$1 : _props$input,
          inputProps = props.inputProps,
          MenuProps = props.MenuProps,
          muiFormControl = props.muiFormControl,
          _props$multiple = props.multiple,
          multiple = _props$multiple === void 0 ? false : _props$multiple,
          _props$native = props.native,
          native = _props$native === void 0 ? false : _props$native,
          onClose = props.onClose,
          onOpen = props.onOpen,
          open = props.open,
          renderValue = props.renderValue,
          SelectDisplayProps = props.SelectDisplayProps,
          variant = props.variant,
          other = objectWithoutProperties(props, ["autoWidth", "children", "classes", "displayEmpty", "IconComponent", "input", "inputProps", "MenuProps", "muiFormControl", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"]);

      var inputComponent = native ? NativeSelectInput : SelectInput;
      var fcs = formControlState({
        props: props,
        muiFormControl: muiFormControl,
        states: ['variant']
      });
      return React__default.cloneElement(input, _extends_1({
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: inputComponent,
        inputProps: _extends_1({
          children: children,
          IconComponent: IconComponent,
          variant: fcs.variant,
          type: undefined,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple: multiple
        }, native ? {} : {
          autoWidth: autoWidth,
          displayEmpty: displayEmpty,
          MenuProps: MenuProps,
          onClose: onClose,
          onOpen: onOpen,
          open: open,
          renderValue: renderValue,
          SelectDisplayProps: SelectDisplayProps
        }, inputProps, {
          classes: inputProps ? styles$1O.mergeClasses({
            baseClasses: classes,
            newClasses: inputProps.classes,
            Component: Select
          }) : classes
        }, input ? input.props.inputProps : {}),
        ref: ref
      }, other));
    });
    Select.propTypes = {
      /**
       * If true, the width of the popover will automatically be set according to the items inside the
       * menu, otherwise it will be at least the width of the select input.
       */
      autoWidth: PropTypes__default.bool,

      /**
       * The option elements to populate the select with.
       * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
       *
       * The `MenuItem` elements **must** be direct descendants when `native` is false.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * If `true`, the selected item is displayed even if its value is empty.
       * You can only use it when the `native` property is `false` (default).
       */
      displayEmpty: PropTypes__default.bool,

      /**
       * The icon that displays the arrow.
       */
      IconComponent: PropTypes__default.elementType,

      /**
       * An `Input` element; does not have to be a material-ui specific `Input`.
       */
      input: PropTypes__default.element,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       * When `native` is `true`, the attributes are applied on the `select` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * Properties applied to the [`Menu`](/api/menu/) element.
       */
      MenuProps: PropTypes__default.object,

      /**
       * @ignore
       * from `withFormControlContext`
       */
      muiFormControl: PropTypes__default.object,

      /**
       * If true, `value` must be an array and the menu will support multiple selections.
       */
      multiple: PropTypes__default.bool,

      /**
       * If `true`, the component will be using a native `select` element.
       */
      native: PropTypes__default.bool,

      /**
       * Callback function fired when a menu item is selected.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       * @param {object} [child] The react element that was selected when `native` is `false` (default).
       */
      onChange: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be closed.
       * Use in controlled mode (see open).
       *
       * @param {object} event The event source of the callback
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired when the component requests to be opened.
       * Use in controlled mode (see open).
       *
       * @param {object} event The event source of the callback
       */
      onOpen: PropTypes__default.func,

      /**
       * Control `select` open state.
       * You can only use it when the `native` property is `false` (default).
       */
      open: PropTypes__default.bool,

      /**
       * Render the selected value.
       * You can only use it when the `native` property is `false` (default).
       *
       * @param {*} value The `value` provided to the component.
       * @returns {ReactElement}
       */
      renderValue: PropTypes__default.func,

      /**
       * Properties applied to the clickable div element.
       */
      SelectDisplayProps: PropTypes__default.object,

      /**
       * The input value.
       * This property is required when the `native` property is `false` (default).
       */
      value: PropTypes__default.any,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    Select.muiName = 'Select';
    var Select$1 = withStyles(styles$1l, {
      name: 'MuiSelect'
    })(withFormControlContext(Select));

    var styles$1m = function styles(theme) {
      var emphasis = theme.palette.type === 'light' ? 0.8 : 0.98;
      var backgroundColor = emphasize(theme.palette.background.default, emphasis);
      return {
        /* Styles applied to the root element. */
        root: defineProperty({
          color: theme.palette.getContrastText(backgroundColor),
          backgroundColor: backgroundColor,
          display: 'flex',
          alignItems: 'center',
          flexWrap: 'wrap',
          padding: '6px 16px',
          borderRadius: theme.shape.borderRadius,
          flexGrow: 1
        }, theme.breakpoints.up('sm'), {
          flexGrow: 'initial',
          minWidth: 288
        }),

        /* Styles applied to the message wrapper element. */
        message: {
          padding: '8px 0'
        },

        /* Styles applied to the action wrapper element if `action` is provided. */
        action: {
          display: 'flex',
          alignItems: 'center',
          marginLeft: 'auto',
          paddingLeft: 16,
          marginRight: -8
        }
      };
    };
    var SnackbarContent = React__default.forwardRef(function SnackbarContent(props, ref) {
      var action = props.action,
          classes = props.classes,
          className = props.className,
          message = props.message,
          other = objectWithoutProperties(props, ["action", "classes", "className", "message"]);

      return React__default.createElement(Paper$1, _extends_1({
        component: Typography$1,
        variant: "body2",
        variantMapping: {
          body1: 'div',
          body2: 'div'
        },
        role: "alertdialog",
        square: true,
        elevation: 6,
        className: clsx(classes.root, className),
        ref: ref
      }, other), React__default.createElement("div", {
        className: classes.message
      }, message), action ? React__default.createElement("div", {
        className: classes.action
      }, action) : null);
    });
    SnackbarContent.propTypes = {
      /**
       * The action to display.
       */
      action: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The message to display.
       */
      message: PropTypes__default.node
    };
    var SnackbarContent$1 = withStyles(styles$1m, {
      name: 'MuiSnackbarContent'
    })(SnackbarContent);

    var styles$1n = function styles(theme) {
      var top1 = {
        top: 8
      };
      var bottom1 = {
        bottom: 8
      };
      var right = {
        justifyContent: 'flex-end'
      };
      var left = {
        justifyContent: 'flex-start'
      };
      var top3 = {
        top: 24
      };
      var bottom3 = {
        bottom: 24
      };
      var right3 = {
        right: 24
      };
      var left3 = {
        left: 24
      };
      var center = {
        left: '50%',
        right: 'auto',
        transform: 'translateX(-50%)'
      };
      return {
        /* Styles applied to the root element. */
        root: {
          zIndex: theme.zIndex.snackbar,
          position: 'fixed',
          display: 'flex',
          left: 8,
          right: 8,
          justifyContent: 'center',
          alignItems: 'center'
        },

        /* Styles applied to the root element if `anchorOrigin={{ 'top', 'center' }}`. */
        anchorOriginTopCenter: _extends_1({}, top1, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({}, top3, center))),

        /* Styles applied to the root element if `anchorOrigin={{ 'bottom', 'center' }}`. */
        anchorOriginBottomCenter: _extends_1({}, bottom1, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({}, bottom3, center))),

        /* Styles applied to the root element if `anchorOrigin={{ 'top', 'right' }}`. */
        anchorOriginTopRight: _extends_1({}, top1, right, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({
          left: 'auto'
        }, top3, right3))),

        /* Styles applied to the root element if `anchorOrigin={{ 'bottom', 'right' }}`. */
        anchorOriginBottomRight: _extends_1({}, bottom1, right, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({
          left: 'auto'
        }, bottom3, right3))),

        /* Styles applied to the root element if `anchorOrigin={{ 'top', 'left' }}`. */
        anchorOriginTopLeft: _extends_1({}, top1, left, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({
          right: 'auto'
        }, top3, left3))),

        /* Styles applied to the root element if `anchorOrigin={{ 'bottom', 'left' }}`. */
        anchorOriginBottomLeft: _extends_1({}, bottom1, left, defineProperty({}, theme.breakpoints.up('sm'), _extends_1({
          right: 'auto'
        }, bottom3, left3)))
      };
    };
    var Snackbar = React__default.forwardRef(function Snackbar(props, ref) {
      var action = props.action,
          _props$anchorOrigin = props.anchorOrigin,
          vertical = _props$anchorOrigin.vertical,
          horizontal = _props$anchorOrigin.horizontal,
          autoHideDuration = props.autoHideDuration,
          children = props.children,
          classes = props.classes,
          className = props.className,
          ClickAwayListenerProps = props.ClickAwayListenerProps,
          ContentProps = props.ContentProps,
          disableWindowBlurListener = props.disableWindowBlurListener,
          message = props.message,
          onClose = props.onClose,
          onEnter = props.onEnter,
          onEntered = props.onEntered,
          onEntering = props.onEntering,
          onExit = props.onExit,
          onExited = props.onExited,
          onExiting = props.onExiting,
          onMouseEnter = props.onMouseEnter,
          onMouseLeave = props.onMouseLeave,
          open = props.open,
          resumeHideDuration = props.resumeHideDuration,
          TransitionComponent = props.TransitionComponent,
          transitionDuration = props.transitionDuration,
          TransitionProps = props.TransitionProps,
          other = objectWithoutProperties(props, ["action", "anchorOrigin", "autoHideDuration", "children", "classes", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onClose", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"]);

      var timerAutoHide = React__default.useRef();

      var _React$useState = React__default.useState(!open),
          _React$useState2 = slicedToArray(_React$useState, 2),
          exited = _React$useState2[0],
          setExited = _React$useState2[1]; // Timer that controls delay before snackbar auto hides


      var setAutoHideTimer = React__default.useCallback(function (autoHideDurationParam) {
        var autoHideDurationBefore = autoHideDurationParam != null ? autoHideDurationParam : autoHideDuration;

        if (!onClose || autoHideDurationBefore == null) {
          return;
        }

        clearTimeout(timerAutoHide.current);
        timerAutoHide.current = setTimeout(function () {
          var autoHideDurationAfter = autoHideDurationParam != null ? autoHideDurationParam : autoHideDuration;

          if (!onClose || autoHideDurationAfter == null) {
            return;
          }

          onClose(null, 'timeout');
        }, autoHideDurationBefore);
      }, [autoHideDuration, onClose]);
      React__default.useEffect(function () {
        if (open) setAutoHideTimer();
        return function () {
          clearTimeout(timerAutoHide.current);
        };
      }, [open, setAutoHideTimer]); // Pause the timer when the user is interacting with the Snackbar
      // or when the user hide the window.

      var handlePause = function handlePause() {
        clearTimeout(timerAutoHide.current);
      }; // Restart the timer when the user is no longer interacting with the Snackbar
      // or when the window is shown back.


      var handleResume = React__default.useCallback(function () {
        if (autoHideDuration != null) {
          if (resumeHideDuration != null) {
            setAutoHideTimer(resumeHideDuration);
            return;
          }

          setAutoHideTimer(autoHideDuration * 0.5);
        }
      }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);

      var handleMouseEnter = function handleMouseEnter(event) {
        if (onMouseEnter) {
          onMouseEnter(event);
        }

        handlePause();
      };

      var handleMouseLeave = function handleMouseLeave(event) {
        if (onMouseLeave) {
          onMouseLeave(event);
        }

        handleResume();
      };

      var handleClickAway = function handleClickAway(event) {
        if (onClose) {
          onClose(event, 'clickaway');
        }
      };

      var handleExited = function handleExited() {
        setExited(true);
      };

      var handleEnter = function handleEnter() {
        setExited(false);
      };

      React__default.useEffect(function () {
        if (!disableWindowBlurListener) {
          window.addEventListener('focus', handleResume);
          window.addEventListener('blur', handlePause);
          return function () {
            window.removeEventListener('focus', handleResume);
            window.removeEventListener('blur', handlePause);
          };
        }

        return undefined;
      }, [disableWindowBlurListener, handleResume]); // So we only render active snackbars.

      if (!open && exited) {
        return null;
      }

      return React__default.createElement(ClickAwayListener, _extends_1({
        onClickAway: handleClickAway
      }, ClickAwayListenerProps), React__default.createElement("div", _extends_1({
        className: clsx(classes.root, classes["anchorOrigin".concat(capitalize(vertical)).concat(capitalize(horizontal))], className),
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        ref: ref
      }, other), React__default.createElement(TransitionComponent, _extends_1({
        appear: true,
        in: open,
        onEnter: createChainedFunction(handleEnter, onEnter),
        onEntered: onEntered,
        onEntering: onEntering,
        onExit: onExit,
        onExited: createChainedFunction(handleExited, onExited),
        onExiting: onExiting,
        timeout: transitionDuration,
        direction: vertical === 'top' ? 'down' : 'up'
      }, TransitionProps), children || React__default.createElement(SnackbarContent$1, _extends_1({
        message: message,
        action: action
      }, ContentProps)))));
    });
    Snackbar.propTypes = {
      /**
       * The action to display.
       */
      action: PropTypes__default.node,

      /**
       * The anchor of the `Snackbar`.
       */
      anchorOrigin: PropTypes__default.shape({
        horizontal: PropTypes__default.oneOf(['left', 'center', 'right']).isRequired,
        vertical: PropTypes__default.oneOf(['top', 'bottom']).isRequired
      }),

      /**
       * The number of milliseconds to wait before automatically calling the
       * `onClose` function. `onClose` should then set the state of the `open`
       * prop to hide the Snackbar. This behavior is disabled by default with
       * the `null` value.
       */
      autoHideDuration: PropTypes__default.number,

      /**
       * Replace the `SnackbarContent` component.
       */
      children: PropTypes__default.element,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Properties applied to the `ClickAwayListener` element.
       */
      ClickAwayListenerProps: PropTypes__default.object,

      /**
       * Properties applied to the [`SnackbarContent`](/api/snackbar-content/) element.
       */
      ContentProps: PropTypes__default.object,

      /**
       * If `true`, the `autoHideDuration` timer will expire even if the window is not focused.
       */
      disableWindowBlurListener: PropTypes__default.bool,

      /**
       * When displaying multiple consecutive Snackbars from a parent rendering a single
       * <Snackbar/>, add the key property to ensure independent treatment of each message.
       * e.g. <Snackbar key={message} />, otherwise, the message may update-in-place and
       * features such as autoHideDuration may be canceled.
       */
      key: PropTypes__default.any,

      /**
       * The message to display.
       */
      message: PropTypes__default.node,

      /**
       * Callback fired when the component requests to be closed.
       * Typically `onClose` is used to set state in the parent component,
       * which is used to control the `Snackbar` `open` prop.
       * The `reason` parameter can optionally be used to control the response to `onClose`,
       * for example ignoring `clickaway`.
       *
       * @param {object} event The event source of the callback
       * @param {string} reason Can be:`"timeout"` (`autoHideDuration` expired) or: `"clickaway"`
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired before the transition is entering.
       */
      onEnter: PropTypes__default.func,

      /**
       * Callback fired when the transition has entered.
       */
      onEntered: PropTypes__default.func,

      /**
       * Callback fired when the transition is entering.
       */
      onEntering: PropTypes__default.func,

      /**
       * Callback fired before the transition is exiting.
       */
      onExit: PropTypes__default.func,

      /**
       * Callback fired when the transition has exited.
       */
      onExited: PropTypes__default.func,

      /**
       * Callback fired when the transition is exiting.
       */
      onExiting: PropTypes__default.func,

      /**
       * @ignore
       */
      onMouseEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onMouseLeave: PropTypes__default.func,

      /**
       * If true, `Snackbar` is open.
       */
      open: PropTypes__default.bool,

      /**
       * The number of milliseconds to wait before dismissing after user interaction.
       * If `autoHideDuration` property isn't specified, it does nothing.
       * If `autoHideDuration` property is specified but `resumeHideDuration` isn't,
       * we default to `autoHideDuration / 2` ms.
       */
      resumeHideDuration: PropTypes__default.number,

      /**
       * The component used for the transition.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })]),

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    Snackbar.defaultProps = {
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: 'center'
      },
      disableWindowBlurListener: false,
      TransitionComponent: Grow$1,
      transitionDuration: {
        enter: duration.enteringScreen,
        exit: duration.leavingScreen
      }
    };
    withStyles(styles$1n, {
      flip: false,
      name: 'MuiSnackbar'
    })(Snackbar);

    var styles$1o = {
      /* Styles applied to the root element. */
      root: {},

      /* Styles applied to the root element if `orientation="horizontal"`. */
      horizontal: {
        paddingLeft: 8,
        paddingRight: 8,
        '&:first-child': {
          paddingLeft: 0
        },
        '&:last-child': {
          paddingRight: 0
        }
      },

      /* Styles applied to the root element if `orientation="vertical"`. */
      vertical: {},

      /* Styles applied to the root element if `alternativeLabel={true}`. */
      alternativeLabel: {
        flex: 1,
        position: 'relative'
      },

      /* Styles applied to the root element if `completed={true}`. */
      completed: {}
    };
    var Step = React__default.forwardRef(function Step(props, ref) {
      var _props$active = props.active,
          active = _props$active === void 0 ? false : _props$active,
          alternativeLabel = props.alternativeLabel,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$completed = props.completed,
          completed = _props$completed === void 0 ? false : _props$completed,
          connector = props.connector,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          index = props.index,
          last = props.last,
          orientation = props.orientation,
          other = objectWithoutProperties(props, ["active", "alternativeLabel", "children", "classes", "className", "completed", "connector", "disabled", "index", "last", "orientation"]);

      var className = clsx(classes.root, classes[orientation], alternativeLabel && classes.alternativeLabel, completed && classes.completed, classNameProp);
      return React__default.createElement("div", _extends_1({
        className: className,
        ref: ref
      }, other), connector && alternativeLabel && index !== 0 && React__default.cloneElement(connector, {
        orientation: orientation,
        alternativeLabel: alternativeLabel,
        index: index,
        active: active,
        completed: completed,
        disabled: disabled
      }), React__default.Children.map(children, function (child) {
        if (!React__default.isValidElement(child)) {
          return null;
        }

        warning_1(child.type !== React__default.Fragment, ["Material-UI: the Step component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        return React__default.cloneElement(child, _extends_1({
          active: active,
          alternativeLabel: alternativeLabel,
          completed: completed,
          disabled: disabled,
          last: last,
          icon: index + 1,
          orientation: orientation
        }, child.props));
      }));
    });
    Step.propTypes = {
      /**
       * Sets the step as active. Is passed to child components.
       */
      active: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Stepper when it's supplied with the alternativeLabel property.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * Should be `Step` sub-components such as `StepLabel`, `StepContent`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Mark the step as completed. Is passed to child components.
       */
      completed: PropTypes__default.bool,

      /**
       * @ignore
       * Passed down from Stepper if alternativeLabel is also set.
       */
      connector: PropTypes__default.element,

      /**
       * Mark the step as disabled, will also disable the button if
       * `StepButton` is a child of `Step`. Is passed to child components.
       */
      disabled: PropTypes__default.bool,

      /**
       * @ignore
       * Used internally for numbering.
       */
      index: PropTypes__default.number,

      /**
       * @ignore
       */
      last: PropTypes__default.bool,

      /**
       * @ignore
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical'])
    };
    withStyles(styles$1o, {
      name: 'MuiStep'
    })(Step);

    /**
     * @ignore - internal component.
     */

    var CheckCircle = createSvgIcon(React__default.createElement("path", {
      d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
    }), 'CheckCircle');

    /**
     * @ignore - internal component.
     */

    var Warning = createSvgIcon(React__default.createElement("path", {
      d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
    }), 'Warning');

    var styles$1p = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'block',
          color: theme.palette.text.disabled,
          '&$active': {
            color: theme.palette.primary.main
          },
          '&$completed': {
            color: theme.palette.primary.main
          },
          '&$error': {
            color: theme.palette.error.main
          }
        },

        /* Styles applied to the SVG text element. */
        text: {
          fill: theme.palette.primary.contrastText,
          fontSize: theme.typography.caption.fontSize,
          fontFamily: theme.typography.fontFamily
        },

        /* Styles applied to the root element if `active={true}`. */
        active: {},

        /* Styles applied to the root element if `completed={true}`. */
        completed: {},

        /* Styles applied to the root element if `error={true}`. */
        error: {}
      };
    };

    var _ref$1 = React__default.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "12"
    });

    var StepIcon = React__default.forwardRef(function StepIcon(props, ref) {
      var _props$completed = props.completed,
          completed = _props$completed === void 0 ? false : _props$completed,
          icon = props.icon,
          _props$active = props.active,
          active = _props$active === void 0 ? false : _props$active,
          _props$error = props.error,
          error = _props$error === void 0 ? false : _props$error,
          classes = props.classes;

      if (typeof icon === 'number' || typeof icon === 'string') {
        if (error) {
          return React__default.createElement(Warning, {
            className: clsx(classes.root, classes.error),
            ref: ref
          });
        }

        if (completed) {
          return React__default.createElement(CheckCircle, {
            className: clsx(classes.root, classes.completed),
            ref: ref
          });
        }

        return React__default.createElement(SvgIcon$1, {
          className: clsx(classes.root, active && classes.active),
          ref: ref
        }, _ref$1, React__default.createElement("text", {
          className: classes.text,
          x: "12",
          y: "16",
          textAnchor: "middle"
        }, icon));
      }

      return icon;
    });
    StepIcon.propTypes = {
      /**
       * Whether this step is active.
       */
      active: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * Mark the step as completed. Is passed to child components.
       */
      completed: PropTypes__default.bool,

      /**
       * Mark the step as failed.
       */
      error: PropTypes__default.bool,

      /**
       * The icon displayed by the step label.
       */
      icon: PropTypes__default.node.isRequired
    };
    var StepIcon$1 = withStyles(styles$1p, {
      name: 'MuiStepIcon'
    })(StepIcon);

    var styles$1q = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'flex',
          alignItems: 'center',
          '&$alternativeLabel': {
            flexDirection: 'column'
          },
          '&$disabled': {
            cursor: 'default'
          }
        },

        /* Styles applied to the root element if `orientation="horizontal". */
        horizontal: {},

        /* Styles applied to the root element if `orientation="vertical". */
        vertical: {},

        /* Styles applied to the `Typography` component which wraps `children`. */
        label: {
          color: theme.palette.text.secondary,
          '&$active': {
            color: theme.palette.text.primary,
            fontWeight: 500
          },
          '&$completed': {
            color: theme.palette.text.primary,
            fontWeight: 500
          },
          '&$alternativeLabel': {
            textAlign: 'center',
            marginTop: 16
          },
          '&$error': {
            color: theme.palette.error.main
          }
        },

        /* Styles applied to the `Typography` component if `active={true}`. */
        active: {},

        /* Styles applied to the `Typography` component if `completed={true}`. */
        completed: {},

        /* Styles applied to the root element and `Typography` component if `error={true}`. */
        error: {},

        /* Styles applied to the root element and `Typography` component if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the `icon` container element. */
        iconContainer: {
          flexShrink: 0,
          // Fix IE 11 issue
          display: 'flex',
          paddingRight: 8,
          '&$alternativeLabel': {
            paddingRight: 0
          }
        },

        /* Styles applied to the root & icon container and `Typography` if `alternativeLabel={true}`. */
        alternativeLabel: {},

        /* Styles applied to the container element which wraps `Typography` and `optional`. */
        labelContainer: {
          width: '100%'
        }
      };
    };
    var StepLabel = React__default.forwardRef(function StepLabel(props, ref) {
      var _props$active = props.active,
          active = _props$active === void 0 ? false : _props$active,
          _props$alternativeLab = props.alternativeLabel,
          alternativeLabel = _props$alternativeLab === void 0 ? false : _props$alternativeLab,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$completed = props.completed,
          completed = _props$completed === void 0 ? false : _props$completed,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$error = props.error,
          error = _props$error === void 0 ? false : _props$error,
          icon = props.icon,
          last = props.last,
          optional = props.optional,
          _props$orientation = props.orientation,
          orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
          StepIconComponentProp = props.StepIconComponent,
          StepIconProps = props.StepIconProps,
          other = objectWithoutProperties(props, ["active", "alternativeLabel", "children", "classes", "className", "completed", "disabled", "error", "icon", "last", "optional", "orientation", "StepIconComponent", "StepIconProps"]);

      var StepIconComponent = StepIconComponentProp;

      if (icon && !StepIconComponent) {
        StepIconComponent = StepIcon$1;
      }

      return React__default.createElement("span", _extends_1({
        className: clsx(classes.root, classes[orientation], disabled && classes.disabled, alternativeLabel && classes.alternativeLabel, error && classes.error, classNameProp),
        ref: ref
      }, other), icon || StepIconComponent ? React__default.createElement("span", {
        className: clsx(classes.iconContainer, alternativeLabel && classes.alternativeLabel)
      }, React__default.createElement(StepIconComponent, _extends_1({
        completed: completed,
        active: active,
        error: error,
        icon: icon
      }, StepIconProps))) : null, React__default.createElement("span", {
        className: classes.labelContainer
      }, React__default.createElement(Typography$1, {
        variant: "body2",
        component: "span",
        className: clsx(classes.label, alternativeLabel && classes.alternativeLabel, completed && classes.completed, active && classes.active, error && classes.error),
        display: "block"
      }, children), optional));
    });
    StepLabel.propTypes = {
      /**
       * @ignore
       * Sets the step as active. Is passed to child components.
       */
      active: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Stepper when it's supplied with the alternativeLabel property.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * In most cases will simply be a string containing a title for the label.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       * Mark the step as completed. Is passed to child components.
       */
      completed: PropTypes__default.bool,

      /**
       * Mark the step as disabled, will also disable the button if
       * `StepLabelButton` is a child of `StepLabel`. Is passed to child components.
       */
      disabled: PropTypes__default.bool,

      /**
       * Mark the step as failed.
       */
      error: PropTypes__default.bool,

      /**
       * Override the default icon.
       */
      icon: PropTypes__default.node,

      /**
       * @ignore
       */
      last: PropTypes__default.bool,

      /**
       * The optional node to display.
       */
      optional: PropTypes__default.node,

      /**
       * @ignore
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical']),

      /**
       * The component to render in place of the [`StepIcon`](/api/step-icon/).
       */
      StepIconComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the [`StepIcon`](/api/step-icon/) element.
       */
      StepIconProps: PropTypes__default.object
    };
    StepLabel.muiName = 'StepLabel';
    var StepLabel$1 = withStyles(styles$1q, {
      name: 'MuiStepLabel'
    })(StepLabel);

    var styles$1r = {
      /* Styles applied to the root element. */
      root: {
        width: '100%',
        padding: '24px 16px',
        margin: '-24px -16px',
        boxSizing: 'content-box'
      },

      /* Styles applied to the root element if `orientation="horizontal"`. */
      horizontal: {},

      /* Styles applied to the root element if `orientation="vertical"`. */
      vertical: {
        justifyContent: 'flex-start'
      },

      /* Styles applied to the `ButtonBase` touch-ripple. */
      touchRipple: {
        color: 'rgba(0, 0, 0, 0.3)'
      }
    };
    var StepButton = React__default.forwardRef(function StepButton(props, ref) {
      var active = props.active,
          alternativeLabel = props.alternativeLabel,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          completed = props.completed,
          disabled = props.disabled,
          icon = props.icon,
          last = props.last,
          optional = props.optional,
          orientation = props.orientation,
          other = objectWithoutProperties(props, ["active", "alternativeLabel", "children", "classes", "className", "completed", "disabled", "icon", "last", "optional", "orientation"]);

      var childProps = {
        active: active,
        alternativeLabel: alternativeLabel,
        completed: completed,
        disabled: disabled,
        icon: icon,
        optional: optional,
        orientation: orientation
      };
      var child = isMuiElement(children, ['StepLabel']) ? React__default.cloneElement(children, childProps) : React__default.createElement(StepLabel$1, childProps, children);
      return React__default.createElement(ButtonBase$1, _extends_1({
        disabled: disabled,
        TouchRippleProps: {
          className: classes.touchRipple
        },
        className: clsx(classes.root, classes[orientation], classNameProp),
        ref: ref
      }, other), child);
    });
    StepButton.propTypes = {
      /**
       * @ignore
       * Passed in via `Step` - passed through to `StepLabel`.
       */
      active: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Stepper when it's supplied with the alternativeLabel property.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * Can be a `StepLabel` or a node to place inside `StepLabel` as children.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       * Sets completed styling. Is passed to StepLabel.
       */
      completed: PropTypes__default.bool,

      /**
       * @ignore
       * Disables the button and sets disabled styling. Is passed to StepLabel.
       */
      disabled: PropTypes__default.bool,

      /**
       * The icon displayed by the step label.
       */
      icon: PropTypes__default.node,

      /**
       * @ignore
       */
      last: PropTypes__default.bool,

      /**
       * The optional node to display.
       */
      optional: PropTypes__default.node,

      /**
       * @ignore
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical'])
    };
    withStyles(styles$1r, {
      name: 'MuiStepButton'
    })(StepButton);

    var styles$1s = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          flex: '1 1 auto'
        },

        /* Styles applied to the root element if `orientation="horizontal"`. */
        horizontal: {},

        /* Styles applied to the root element if `orientation="vertical"`. */
        vertical: {
          marginLeft: 12,
          // half icon
          padding: '0 0 8px'
        },

        /* Styles applied to the root element if `alternativeLabel={true}`. */
        alternativeLabel: {
          position: 'absolute',
          top: 8 + 4,
          left: 'calc(-50% + 20px)',
          right: 'calc(50% + 20px)'
        },

        /* Styles applied to the root element if `active={true}`. */
        active: {},

        /* Styles applied to the root element if `completed={true}`. */
        completed: {},

        /* Styles applied to the root element if `disabled={true}`. */
        disabled: {},

        /* Styles applied to the line element. */
        line: {
          display: 'block',
          borderColor: theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[600]
        },

        /* Styles applied to the root element if `orientation="horizontal"`. */
        lineHorizontal: {
          borderTopStyle: 'solid',
          borderTopWidth: 1
        },

        /* Styles applied to the root element if `orientation="vertical"`. */
        lineVertical: {
          borderLeftStyle: 'solid',
          borderLeftWidth: 1,
          minHeight: 24
        }
      };
    };
    var StepConnector = React__default.forwardRef(function StepConnector(props, ref) {
      var active = props.active,
          _props$alternativeLab = props.alternativeLabel,
          alternativeLabel = _props$alternativeLab === void 0 ? false : _props$alternativeLab,
          classes = props.classes,
          classNameProp = props.className,
          completed = props.completed,
          disabled = props.disabled,
          index = props.index,
          _props$orientation = props.orientation,
          orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
          other = objectWithoutProperties(props, ["active", "alternativeLabel", "classes", "className", "completed", "disabled", "index", "orientation"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, classes[orientation], alternativeLabel && classes.alternativeLabel, active && classes.active, completed && classes.completed, disabled && classes.disabled, classNameProp),
        ref: ref
      }, other), React__default.createElement("span", {
        className: clsx(classes.line, orientation === 'horizontal' && classes.lineHorizontal, orientation === 'vertical' && classes.lineVertical)
      }));
    });
    StepConnector.propTypes = {
      /**
       * @ignore
       */
      active: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Step when it's supplied with the alternativeLabel property.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       */
      completed: PropTypes__default.bool,

      /**
       * @ignore
       */
      disabled: PropTypes__default.bool,

      /**
       * @ignore
       */
      index: PropTypes__default.number,

      /**
       * @ignore
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical'])
    };
    var StepConnector$1 = withStyles(styles$1s, {
      name: 'MuiStepConnector'
    })(StepConnector);

    var styles$1t = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          marginTop: 8,
          marginLeft: 12,
          // half icon
          paddingLeft: 8 + 12,
          // margin + half icon
          paddingRight: 8,
          borderLeft: "1px solid ".concat(theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[600])
        },

        /* Styles applied to the root element if `last={true}` (controlled by `Step`). */
        last: {
          borderLeft: 'none'
        },

        /* Styles applied to the Transition component. */
        transition: {}
      };
    };
    var StepContent = React__default.forwardRef(function StepContent(props, ref) {
      var active = props.active,
          alternativeLabel = props.alternativeLabel,
          children = props.children,
          classes = props.classes,
          className = props.className,
          completed = props.completed,
          last = props.last,
          optional = props.optional,
          orientation = props.orientation,
          _props$TransitionComp = props.TransitionComponent,
          TransitionComponent = _props$TransitionComp === void 0 ? Collapse$1 : _props$TransitionComp,
          _props$transitionDura = props.transitionDuration,
          transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
          TransitionProps = props.TransitionProps,
          other = objectWithoutProperties(props, ["active", "alternativeLabel", "children", "classes", "className", "completed", "last", "optional", "orientation", "TransitionComponent", "transitionDuration", "TransitionProps"]);

      warning_1(orientation === 'vertical', 'Material-UI: <StepContent /> is only designed for use with the vertical stepper.');
      var transitionDuration = transitionDurationProp;

      if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
        transitionDuration = undefined;
      }

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, last && classes.last, className),
        ref: ref
      }, other), React__default.createElement(TransitionComponent, _extends_1({
        in: active,
        className: classes.transition,
        timeout: transitionDuration,
        unmountOnExit: true
      }, TransitionProps), children));
    });
    StepContent.propTypes = {
      /**
       * @ignore
       * Expands the content.
       */
      active: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Step when it's supplied with the alternativeLabel property.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * Step content.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       */
      completed: PropTypes__default.bool,

      /**
       * @ignore
       */
      last: PropTypes__default.bool,

      /**
       * @ignore
       * Set internally by Step when it's supplied with the optional property.
       */
      optional: PropTypes__default.bool,

      /**
       * @ignore
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical']),

      /**
       * The component used for the transition.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * Adjust the duration of the content expand transition.
       * Passed as a property to the transition component.
       *
       * Set to 'auto' to automatically calculate transition time based on height.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      }), PropTypes__default.oneOf(['auto'])]),

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    withStyles(styles$1t, {
      name: 'MuiStepContent'
    })(StepContent);

    var styles$1u = {
      /* Styles applied to the root element. */
      root: {
        display: 'flex',
        padding: 24
      },

      /* Styles applied to the root element if `orientation="horizontal"`. */
      horizontal: {
        flexDirection: 'row',
        alignItems: 'center'
      },

      /* Styles applied to the root element if `orientation="vertical"`. */
      vertical: {
        flexDirection: 'column'
      },

      /* Styles applied to the root element if `alternativeLabel={true}`. */
      alternativeLabel: {
        alignItems: 'flex-start'
      }
    };
    var defaultConnector = React__default.createElement(StepConnector$1, null);
    var Stepper = React__default.forwardRef(function Stepper(props, ref) {
      var _props$activeStep = props.activeStep,
          activeStep = _props$activeStep === void 0 ? 0 : _props$activeStep,
          _props$alternativeLab = props.alternativeLabel,
          alternativeLabel = _props$alternativeLab === void 0 ? false : _props$alternativeLab,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          _props$connector = props.connector,
          connectorProp = _props$connector === void 0 ? defaultConnector : _props$connector,
          _props$nonLinear = props.nonLinear,
          nonLinear = _props$nonLinear === void 0 ? false : _props$nonLinear,
          _props$orientation = props.orientation,
          orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
          other = objectWithoutProperties(props, ["activeStep", "alternativeLabel", "children", "classes", "className", "connector", "nonLinear", "orientation"]);

      var className = clsx(classes.root, classes[orientation], alternativeLabel && classes.alternativeLabel, classNameProp);
      var connector = React__default.isValidElement(connectorProp) ? React__default.cloneElement(connectorProp, {
        orientation: orientation
      }) : null;
      var childrenArray = React__default.Children.toArray(children);
      var steps = childrenArray.map(function (step, index) {
        var controlProps = {
          alternativeLabel: alternativeLabel,
          connector: connectorProp,
          last: index + 1 === childrenArray.length,
          orientation: orientation
        };
        var state = {
          index: index,
          active: false,
          completed: false,
          disabled: false
        };

        if (activeStep === index) {
          state.active = true;
        } else if (!nonLinear && activeStep > index) {
          state.completed = true;
        } else if (!nonLinear && activeStep < index) {
          state.disabled = true;
        }

        return [!alternativeLabel && connector && index !== 0 && React__default.cloneElement(connector, _extends_1({
          key: index
        }, state)), React__default.cloneElement(step, _extends_1({}, controlProps, state, step.props))];
      });
      return React__default.createElement(Paper$1, _extends_1({
        square: true,
        elevation: 0,
        className: className,
        ref: ref
      }, other), steps);
    });
    Stepper.propTypes = {
      /**
       * Set the active step (zero based index).
       */
      activeStep: PropTypes__default.number,

      /**
       * If set to 'true' and orientation is horizontal,
       * then the step label will be positioned under the icon.
       */
      alternativeLabel: PropTypes__default.bool,

      /**
       * Two or more `<Step />` components.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * A component to be placed between each step.
       */
      connector: PropTypes__default.element,

      /**
       * If set the `Stepper` will not assist in controlling steps for linear flow.
       */
      nonLinear: PropTypes__default.bool,

      /**
       * The stepper orientation (layout flow direction).
       */
      orientation: PropTypes__default.oneOf(['horizontal', 'vertical'])
    };
    withStyles(styles$1u, {
      name: 'MuiStepper'
    })(Stepper);

    var styles$1v = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'fixed',
          top: 0,
          left: 0,
          bottom: 0,
          zIndex: theme.zIndex.drawer - 1
        },
        anchorLeft: {
          right: 'auto'
        },
        anchorRight: {
          left: 'auto',
          right: 0
        },
        anchorTop: {
          bottom: 'auto',
          right: 0
        },
        anchorBottom: {
          top: 'auto',
          bottom: 0,
          right: 0
        }
      };
    };
    /**
     * @ignore - internal component.
     */

    var SwipeArea = React__default.forwardRef(function SwipeArea(props, ref) {
      var anchor = props.anchor,
          classes = props.classes,
          className = props.className,
          width = props.width,
          other = objectWithoutProperties(props, ["anchor", "classes", "className", "width"]);

      return React__default.createElement("div", _extends_1({
        className: clsx(classes.root, classes["anchor".concat(capitalize(anchor))], className),
        ref: ref,
        style: defineProperty({}, isHorizontal(anchor) ? 'width' : 'height', width)
      }, other));
    });
    SwipeArea.propTypes = {
      /**
       * Side on which to attach the discovery area.
       */
      anchor: PropTypes__default.oneOf(['left', 'top', 'right', 'bottom']).isRequired,

      /**
       * @ignore
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The width of the left most (or right most) area in pixels where the
       * drawer can be swiped open from.
       */
      width: PropTypes__default.number.isRequired
    };
    var SwipeArea$1 = withStyles(styles$1v, {
      name: 'PrivateSwipeArea'
    })(SwipeArea);

    // trigger a native scroll.

    var UNCERTAINTY_THRESHOLD = 3; // px
    // We can only have one node at the time claiming ownership for handling the swipe.
    // Otherwise, the UX would be confusing.
    // That's why we use a singleton here.

    var nodeThatClaimedTheSwipe = null; // Exported for test purposes.

    var SwipeableDrawer =
    /*#__PURE__*/
    function (_React$Component) {
      inherits(SwipeableDrawer, _React$Component);

      function SwipeableDrawer() {
        var _getPrototypeOf2;

        var _this;

        classCallCheck(this, SwipeableDrawer);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf(SwipeableDrawer)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _this.state = {};
        _this.isSwiping = null;
        _this.swipeAreaRef = React__default.createRef();
        _this.paperRef = null;

        _this.handleBodyTouchStart = function (event) {
          // We are not supposed to handle this touch move.
          if (nodeThatClaimedTheSwipe !== null && nodeThatClaimedTheSwipe !== assertThisInitialized(_this)) {
            return;
          }

          var _this$props = _this.props,
              disableDiscovery = _this$props.disableDiscovery,
              disableSwipeToOpen = _this$props.disableSwipeToOpen,
              open = _this$props.open,
              swipeAreaWidth = _this$props.swipeAreaWidth;
          var anchor = getAnchor(_this.props.theme, _this.props.anchor);
          var currentX = anchor === 'right' ? document.body.offsetWidth - event.touches[0].pageX : event.touches[0].pageX;
          var currentY = anchor === 'bottom' ? window.innerHeight - event.touches[0].clientY : event.touches[0].clientY;

          if (!open) {
            if (disableSwipeToOpen || event.target !== _this.swipeAreaRef.current) {
              return;
            }

            if (isHorizontal(_this.props.anchor)) {
              if (currentX > swipeAreaWidth) {
                return;
              }
            } else if (currentY > swipeAreaWidth) {
              return;
            }
          }

          nodeThatClaimedTheSwipe = assertThisInitialized(_this);
          _this.startX = currentX;
          _this.startY = currentY;

          _this.setState({
            maybeSwiping: true
          });

          if (!open && _this.paperRef) {
            // The ref may be null when a parent component updates while swiping.
            _this.setPosition(_this.getMaxTranslate() + (disableDiscovery ? 20 : -swipeAreaWidth), {
              changeTransition: false
            });
          }

          _this.velocity = 0;
          _this.lastTime = null;
          _this.lastTranslate = null;
          document.body.addEventListener('touchmove', _this.handleBodyTouchMove, {
            passive: false
          });
          document.body.addEventListener('touchend', _this.handleBodyTouchEnd); // https://plus.google.com/+PaulIrish/posts/KTwfn1Y2238

          document.body.addEventListener('touchcancel', _this.handleBodyTouchEnd);
        };

        _this.handleBodyTouchMove = function (event) {
          // the ref may be null when a parent component updates while swiping
          if (!_this.paperRef) return;
          var anchor = getAnchor(_this.props.theme, _this.props.anchor);
          var horizontalSwipe = isHorizontal(_this.props.anchor);
          var currentX = anchor === 'right' ? document.body.offsetWidth - event.touches[0].pageX : event.touches[0].pageX;
          var currentY = anchor === 'bottom' ? window.innerHeight - event.touches[0].clientY : event.touches[0].clientY; // We don't know yet.

          if (_this.isSwiping == null) {
            var dx = Math.abs(currentX - _this.startX);
            var dy = Math.abs(currentY - _this.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.

            if (dx > dy) {
              event.preventDefault();
            }

            var isSwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;

            if (isSwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {
              _this.isSwiping = isSwiping;

              if (!isSwiping) {
                _this.handleBodyTouchEnd(event);

                return;
              } // Shift the starting point.


              _this.startX = currentX;
              _this.startY = currentY; // Compensate for the part of the drawer displayed on touch start.

              if (!_this.props.disableDiscovery && !_this.props.open) {
                if (horizontalSwipe) {
                  _this.startX -= _this.props.swipeAreaWidth;
                } else {
                  _this.startY -= _this.props.swipeAreaWidth;
                }
              }
            }
          }

          if (!_this.isSwiping) {
            return;
          }

          var translate = _this.getTranslate(horizontalSwipe ? currentX : currentY);

          if (_this.lastTranslate === null) {
            _this.lastTranslate = translate;
            _this.lastTime = performance.now() + 1;
          }

          var velocity = (translate - _this.lastTranslate) / (performance.now() - _this.lastTime) * 1e3; // Low Pass filter.

          _this.velocity = _this.velocity * 0.4 + velocity * 0.6;
          _this.lastTranslate = translate;
          _this.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.

          event.preventDefault();

          _this.setPosition(translate);
        };

        _this.handleBodyTouchEnd = function (event) {
          nodeThatClaimedTheSwipe = null;

          _this.removeBodyTouchListeners();

          _this.setState({
            maybeSwiping: false
          }); // The swipe wasn't started.


          if (!_this.isSwiping) {
            _this.isSwiping = null;
            return;
          }

          _this.isSwiping = null;
          var anchor = getAnchor(_this.props.theme, _this.props.anchor);
          var current;

          if (isHorizontal(_this.props.anchor)) {
            current = anchor === 'right' ? document.body.offsetWidth - event.changedTouches[0].pageX : event.changedTouches[0].pageX;
          } else {
            current = anchor === 'bottom' ? window.innerHeight - event.changedTouches[0].clientY : event.changedTouches[0].clientY;
          }

          var translateRatio = _this.getTranslate(current) / _this.getMaxTranslate();

          if (_this.props.open) {
            if (_this.velocity > _this.props.minFlingVelocity || translateRatio > _this.props.hysteresis) {
              _this.props.onClose();
            } else {
              // Reset the position, the swipe was aborted.
              _this.setPosition(0, {
                mode: 'exit'
              });
            }

            return;
          }

          if (_this.velocity < -_this.props.minFlingVelocity || 1 - translateRatio > _this.props.hysteresis) {
            _this.props.onOpen();
          } else {
            // Reset the position, the swipe was aborted.
            _this.setPosition(_this.getMaxTranslate(), {
              mode: 'enter'
            });
          }
        };

        _this.handleBackdropRef = function (ref) {
          // #StrictMode ready
          _this.backdropRef = ReactDOM__default.findDOMNode(ref);
        };

        _this.handlePaperRef = function (ref) {
          // #StrictMode ready
          _this.paperRef = ReactDOM__default.findDOMNode(ref);
        };

        return _this;
      }

      createClass(SwipeableDrawer, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this.props.variant === 'temporary') {
            this.listenTouchStart();
          }
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var variant = this.props.variant;
          var prevVariant = prevProps.variant;

          if (variant !== prevVariant) {
            if (variant === 'temporary') {
              this.listenTouchStart();
            } else if (prevVariant === 'temporary') {
              this.removeTouchStart();
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.removeTouchStart();
          this.removeBodyTouchListeners(); // We need to release the lock.

          if (nodeThatClaimedTheSwipe === this) {
            nodeThatClaimedTheSwipe = null;
          }
        }
      }, {
        key: "getMaxTranslate",
        value: function getMaxTranslate() {
          return isHorizontal(this.props.anchor) ? this.paperRef.clientWidth : this.paperRef.clientHeight;
        }
      }, {
        key: "getTranslate",
        value: function getTranslate(current) {
          var start = isHorizontal(this.props.anchor) ? this.startX : this.startY;
          return Math.min(Math.max(this.props.open ? start - current : this.getMaxTranslate() + start - current, 0), this.getMaxTranslate());
        }
      }, {
        key: "setPosition",
        value: function setPosition(translate) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var _options$mode = options.mode,
              mode = _options$mode === void 0 ? null : _options$mode,
              _options$changeTransi = options.changeTransition,
              changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;
          var anchor = getAnchor(this.props.theme, this.props.anchor);
          var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchor) !== -1 ? 1 : -1;
          var transform = isHorizontal(this.props.anchor) ? "translate(".concat(rtlTranslateMultiplier * translate, "px, 0)") : "translate(0, ".concat(rtlTranslateMultiplier * translate, "px)");
          var drawerStyle = this.paperRef.style;
          drawerStyle.webkitTransform = transform;
          drawerStyle.transform = transform;
          var transition = '';

          if (mode) {
            transition = this.props.theme.transitions.create('all', getTransitionProps({
              timeout: this.props.transitionDuration
            }, {
              mode: mode
            }));
          }

          if (changeTransition) {
            drawerStyle.webkitTransition = transition;
            drawerStyle.transition = transition;
          }

          if (!this.props.disableBackdropTransition && !this.props.hideBackdrop) {
            var backdropStyle = this.backdropRef.style;
            backdropStyle.opacity = 1 - translate / this.getMaxTranslate();

            if (changeTransition) {
              backdropStyle.webkitTransition = transition;
              backdropStyle.transition = transition;
            }
          }
        }
      }, {
        key: "listenTouchStart",
        value: function listenTouchStart() {
          document.body.addEventListener('touchstart', this.handleBodyTouchStart);
        }
      }, {
        key: "removeTouchStart",
        value: function removeTouchStart() {
          document.body.removeEventListener('touchstart', this.handleBodyTouchStart);
        }
      }, {
        key: "removeBodyTouchListeners",
        value: function removeBodyTouchListeners() {
          document.body.removeEventListener('touchmove', this.handleBodyTouchMove, {
            passive: false
          });
          document.body.removeEventListener('touchend', this.handleBodyTouchEnd);
          document.body.removeEventListener('touchcancel', this.handleBodyTouchEnd);
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props2 = this.props,
              anchor = _this$props2.anchor,
              disableBackdropTransition = _this$props2.disableBackdropTransition,
              disableDiscovery = _this$props2.disableDiscovery,
              disableSwipeToOpen = _this$props2.disableSwipeToOpen,
              hysteresis = _this$props2.hysteresis,
              innerRef = _this$props2.innerRef,
              minFlingVelocity = _this$props2.minFlingVelocity,
              _this$props2$ModalPro = _this$props2.ModalProps;
          _this$props2$ModalPro = _this$props2$ModalPro === void 0 ? {} : _this$props2$ModalPro;

          var BackdropProps = _this$props2$ModalPro.BackdropProps,
              ModalPropsProp = objectWithoutProperties(_this$props2$ModalPro, ["BackdropProps"]),
              onOpen = _this$props2.onOpen,
              open = _this$props2.open,
              _this$props2$PaperPro = _this$props2.PaperProps,
              PaperProps = _this$props2$PaperPro === void 0 ? {} : _this$props2$PaperPro,
              SwipeAreaProps = _this$props2.SwipeAreaProps,
              swipeAreaWidth = _this$props2.swipeAreaWidth,
              variant = _this$props2.variant,
              other = objectWithoutProperties(_this$props2, ["anchor", "disableBackdropTransition", "disableDiscovery", "disableSwipeToOpen", "hysteresis", "innerRef", "minFlingVelocity", "ModalProps", "onOpen", "open", "PaperProps", "SwipeAreaProps", "swipeAreaWidth", "variant"]);

          var maybeSwiping = this.state.maybeSwiping;
          return React__default.createElement(React__default.Fragment, null, React__default.createElement(Drawer$1, _extends_1({
            open: variant === 'temporary' && maybeSwiping ? true : open,
            variant: variant,
            ModalProps: _extends_1({
              BackdropProps: _extends_1({}, BackdropProps, {
                ref: this.handleBackdropRef
              })
            }, ModalPropsProp),
            PaperProps: _extends_1({}, PaperProps, {
              style: _extends_1({
                pointerEvents: variant === 'temporary' && !open ? 'none' : ''
              }, PaperProps.style),
              ref: this.handlePaperRef
            }),
            anchor: anchor,
            ref: innerRef
          }, other)), !disableSwipeToOpen && variant === 'temporary' && React__default.createElement(NoSsr, null, React__default.createElement(SwipeArea$1, _extends_1({
            anchor: anchor,
            innerRef: this.swipeAreaRef,
            width: swipeAreaWidth
          }, SwipeAreaProps))));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, prevState) {
          if (typeof prevState.maybeSwiping === 'undefined') {
            return {
              maybeSwiping: false,
              open: nextProps.open
            };
          }

          if (!nextProps.open && prevState.open) {
            return {
              maybeSwiping: false,
              open: nextProps.open
            };
          }

          return {
            open: nextProps.open
          };
        }
      }]);

      return SwipeableDrawer;
    }(React__default.Component);

    SwipeableDrawer.propTypes = {
      /**
       * @ignore
       */
      anchor: PropTypes__default.oneOf(['left', 'top', 'right', 'bottom']),

      /**
       * Disable the backdrop transition.
       * This can improve the FPS on low-end devices.
       */
      disableBackdropTransition: PropTypes__default.bool,

      /**
       * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit
       * to promote accidental discovery of the swipe gesture.
       */
      disableDiscovery: PropTypes__default.bool,

      /**
       * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers
       * navigation actions. Swipe to open is disabled on iOS browsers by default.
       */
      disableSwipeToOpen: PropTypes__default.bool,

      /**
       * @ignore
       */
      hideBackdrop: PropTypes__default.bool,

      /**
       * Affects how far the drawer must be opened/closed to change his state.
       * Specified as percent (0-1) of the width of the drawer
       */
      hysteresis: PropTypes__default.number,

      /**
       * @ignore
       * from `withForwardedRef`
       */
      innerRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Defines, from which (average) velocity on, the swipe is
       * defined as complete although hysteresis isn't reached.
       * Good threshold is between 250 - 1000 px/s
       */
      minFlingVelocity: PropTypes__default.number,

      /**
       * @ignore
       */
      ModalProps: PropTypes__default.shape({
        BackdropProps: PropTypes__default.shape({
          component: elementTypeAcceptingRef$1
        })
      }),

      /**
       * Callback fired when the component requests to be closed.
       *
       * @param {object} event The event source of the callback
       */
      onClose: PropTypes__default.func.isRequired,

      /**
       * Callback fired when the component requests to be opened.
       *
       * @param {object} event The event source of the callback
       */
      onOpen: PropTypes__default.func.isRequired,

      /**
       * If `true`, the drawer is open.
       */
      open: PropTypes__default.bool.isRequired,

      /**
       * @ignore
       */
      PaperProps: PropTypes__default.shape({
        component: elementTypeAcceptingRef$1
      }),

      /**
       * Properties applied to the swipe area element.
       */
      SwipeAreaProps: PropTypes__default.object,

      /**
       * The width of the left most (or right most) area in pixels where the
       * drawer can be swiped open from.
       */
      swipeAreaWidth: PropTypes__default.number,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      transitionDuration: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })]),

      /**
       * @ignore
       */
      variant: PropTypes__default.oneOf(['permanent', 'persistent', 'temporary'])
    };
    SwipeableDrawer.defaultProps = {
      anchor: 'left',
      disableBackdropTransition: false,
      disableDiscovery: false,
      disableSwipeToOpen: typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent),
      hysteresis: 0.55,
      minFlingVelocity: 400,
      swipeAreaWidth: 20,
      transitionDuration: {
        enter: duration.enteringScreen,
        exit: duration.leavingScreen
      },
      variant: 'temporary' // Mobile first.

    };
    withTheme(withForwardedRef(SwipeableDrawer));

    var styles$1w = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          display: 'inline-flex',
          width: 34 + 12 * 2,
          height: 14 + 12 * 2,
          overflow: 'hidden',
          padding: 12,
          boxSizing: 'border-box',
          position: 'relative',
          flexShrink: 0,
          zIndex: 0,
          // Reset the stacking context.
          verticalAlign: 'middle' // For correct alignment with the text.

        },

        /* Styles applied to the root element if `edge="start"`. */
        edgeStart: {
          marginLeft: -8
        },

        /* Styles applied to the root element if `edge="end"`. */
        edgeEnd: {
          marginRight: -8
        },

        /* Styles applied to the internal `SwitchBase` component's `root` class. */
        switchBase: {
          position: 'absolute',
          top: 0,
          left: 0,
          zIndex: 1,
          // Render above the focus ripple.
          color: theme.palette.type === 'light' ? theme.palette.grey[50] : theme.palette.grey[400],
          transition: theme.transitions.create('transform', {
            duration: theme.transitions.duration.shortest
          }),
          '&$checked': {
            transform: 'translateX(50%)'
          },
          '&$disabled': {
            color: theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[800]
          },
          '&$checked + $track': {
            opacity: 0.5
          },
          '&$disabled + $track': {
            opacity: theme.palette.type === 'light' ? 0.12 : 0.1
          }
        },

        /* Styles applied to the internal SwitchBase component's root element if `color="primary"`. */
        colorPrimary: {
          '&$checked': {
            color: theme.palette.primary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity)
            }
          },
          '&$disabled': {
            color: theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[800]
          },
          '&$checked + $track': {
            backgroundColor: theme.palette.primary.main
          },
          '&$disabled + $track': {
            backgroundColor: theme.palette.type === 'light' ? theme.palette.common.black : theme.palette.common.white
          }
        },

        /* Styles applied to the internal SwitchBase component's root element if `color="secondary"`. */
        colorSecondary: {
          '&$checked': {
            color: theme.palette.secondary.main,
            '&:hover': {
              backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity)
            }
          },
          '&$disabled': {
            color: theme.palette.type === 'light' ? theme.palette.grey[400] : theme.palette.grey[800]
          },
          '&$checked + $track': {
            backgroundColor: theme.palette.secondary.main
          },
          '&$disabled + $track': {
            backgroundColor: theme.palette.type === 'light' ? theme.palette.common.black : theme.palette.common.white
          }
        },

        /* Styles applied to the internal `SwitchBase` component's `checked` class. */
        checked: {},

        /* Styles applied to the internal SwitchBase component's disabled class. */
        disabled: {},

        /* Styles applied to the internal SwitchBase component's input element. */
        input: {
          left: '-100%',
          width: '300%'
        },

        /* Styles used to create the thumb passed to the internal `SwitchBase` component `icon` prop. */
        thumb: {
          boxShadow: theme.shadows[1],
          backgroundColor: 'currentColor',
          width: 20,
          height: 20,
          borderRadius: '50%'
        },

        /* Styles applied to the track element. */
        track: {
          height: '100%',
          width: '100%',
          borderRadius: 14 / 2,
          zIndex: -1,
          transition: theme.transitions.create(['opacity', 'background-color'], {
            duration: theme.transitions.duration.shortest
          }),
          backgroundColor: theme.palette.type === 'light' ? theme.palette.common.black : theme.palette.common.white,
          opacity: theme.palette.type === 'light' ? 0.38 : 0.3
        }
      };
    };
    var Switch = React__default.forwardRef(function Switch(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$color = props.color,
          color = _props$color === void 0 ? 'secondary' : _props$color,
          _props$edge = props.edge,
          edge = _props$edge === void 0 ? false : _props$edge,
          other = objectWithoutProperties(props, ["classes", "className", "color", "edge"]);

      var icon = React__default.createElement("span", {
        className: classes.thumb
      });
      return React__default.createElement("span", {
        className: clsx(classes.root, edge === 'start' && classes.edgeStart, edge === 'end' && classes.edgeEnd, className)
      }, React__default.createElement(SwitchBase$1, _extends_1({
        type: "checkbox",
        icon: icon,
        checkedIcon: icon,
        classes: {
          root: clsx(classes.switchBase, classes["color".concat(capitalize(color))]),
          input: classes.input,
          checked: classes.checked,
          disabled: classes.disabled
        },
        ref: ref
      }, other)), React__default.createElement("span", {
        className: classes.track
      }));
    });
    Switch.propTypes = {
      /**
       * If `true`, the component is checked.
       */
      checked: PropTypes__default.bool,

      /**
       * The icon to display when the component is checked.
       */
      checkedIcon: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The color of the component. It supports those theme colors that make sense for this component.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary', 'default']),

      /**
       * @ignore
       */
      defaultChecked: PropTypes__default.bool,

      /**
       * If `true`, the switch will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * If given, uses a negative margin to counteract the padding on one
       * side (this is often helpful for aligning the left or right
       * side of the icon with content above or below, without ruining the border
       * size and shape).
       */
      edge: PropTypes__default.oneOf(['start', 'end', false]),

      /**
       * The icon to display when the component is unchecked.
       */
      icon: PropTypes__default.node,

      /**
       * The id of the `input` element.
       */
      id: PropTypes__default.string,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Callback fired when the state is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.checked`.
       * @param {boolean} checked The `checked` value of the switch
       */
      onChange: PropTypes__default.func,

      /**
       * The input component property `type`.
       */
      type: PropTypes__default.string,

      /**
       * The value of the component.
       */
      value: PropTypes__default.any
    };
    withStyles(styles$1w, {
      name: 'MuiSwitch'
    })(Switch);

    var styles$1x = function styles(theme) {
      var _extends2;

      return {
        /* Styles applied to the root element. */
        root: _extends_1({}, theme.typography.button, (_extends2 = {
          maxWidth: 264,
          minWidth: 72,
          position: 'relative',
          boxSizing: 'border-box',
          minHeight: 48,
          flexShrink: 0,
          padding: '6px 12px'
        }, defineProperty(_extends2, theme.breakpoints.up('md'), {
          padding: '6px 24px'
        }), defineProperty(_extends2, "overflow", 'hidden'), defineProperty(_extends2, "whiteSpace", 'normal'), defineProperty(_extends2, "textAlign", 'center'), defineProperty(_extends2, theme.breakpoints.up('md'), {
          fontSize: theme.typography.pxToRem(13),
          minWidth: 160
        }), _extends2)),

        /* Styles applied to the root element if both `icon` and `label` are provided. */
        labelIcon: {
          minHeight: 72,
          paddingTop: 9,
          '& $wrapper > *:first-child': {
            marginBottom: 6
          }
        },

        /* Styles applied to the root element if `textColor="inherit"`. */
        textColorInherit: {
          color: 'inherit',
          opacity: 0.7,
          '&$selected': {
            opacity: 1
          },
          '&$disabled': {
            opacity: 0.4
          }
        },

        /* Styles applied to the root element if `textColor="primary"`. */
        textColorPrimary: {
          color: theme.palette.text.secondary,
          '&$selected': {
            color: theme.palette.primary.main
          },
          '&$disabled': {
            color: theme.palette.text.disabled
          }
        },

        /* Styles applied to the root element if `textColor="secondary"`. */
        textColorSecondary: {
          color: theme.palette.text.secondary,
          '&$selected': {
            color: theme.palette.secondary.main
          },
          '&$disabled': {
            color: theme.palette.text.disabled
          }
        },

        /* Styles applied to the root element if `selected={true}` (controlled by the Tabs component). */
        selected: {},

        /* Styles applied to the root element if `disabled={true}` (controlled by the Tabs component). */
        disabled: {},

        /* Styles applied to the root element if `fullWidth={true}` (controlled by the Tabs component). */
        fullWidth: {
          flexShrink: 1,
          flexGrow: 1,
          flexBasis: 0,
          maxWidth: 'none'
        },

        /* Styles applied to the root element if `wrapped={true}`. */
        wrapped: {
          fontSize: theme.typography.pxToRem(12),
          lineHeight: 1.5
        },

        /* Styles applied to the `icon` and `label`'s wrapper element. */
        wrapper: {
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100%',
          flexDirection: 'column'
        }
      };
    };
    var Tab = React__default.forwardRef(function Tab(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$disabled = props.disabled,
          disabled = _props$disabled === void 0 ? false : _props$disabled,
          _props$disableFocusRi = props.disableFocusRipple,
          disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
          fullWidth = props.fullWidth,
          icon = props.icon,
          indicator = props.indicator,
          label = props.label,
          onChange = props.onChange,
          onClick = props.onClick,
          selected = props.selected,
          _props$textColor = props.textColor,
          textColor = _props$textColor === void 0 ? 'inherit' : _props$textColor,
          value = props.value,
          _props$wrapped = props.wrapped,
          wrapped = _props$wrapped === void 0 ? false : _props$wrapped,
          other = objectWithoutProperties(props, ["classes", "className", "disabled", "disableFocusRipple", "fullWidth", "icon", "indicator", "label", "onChange", "onClick", "selected", "textColor", "value", "wrapped"]);

      var handleChange = function handleChange(event) {
        if (onChange) {
          onChange(event, value);
        }

        if (onClick) {
          onClick(event);
        }
      };

      return React__default.createElement(ButtonBase$1, _extends_1({
        focusRipple: !disableFocusRipple,
        className: clsx(classes.root, classes["textColor".concat(capitalize(textColor))], disabled && classes.disabled, selected && classes.selected, label && icon && classes.labelIcon, fullWidth && classes.fullWidth, wrapped && classes.wrapped, className),
        ref: ref,
        role: "tab",
        "aria-selected": selected,
        disabled: disabled,
        onClick: handleChange
      }, other), React__default.createElement("span", {
        className: classes.wrapper
      }, icon, label), indicator);
    });
    Tab.propTypes = {
      /**
       * This property isn't supported.
       * Use the `component` property if you need to change the children structure.
       */
      children: unsupportedProp,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * If `true`, the tab will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the  keyboard focus ripple will be disabled.
       * `disableRipple` must also be true.
       */
      disableFocusRipple: PropTypes__default.bool,

      /**
       * If `true`, the ripple effect will be disabled.
       */
      disableRipple: PropTypes__default.bool,

      /**
       * @ignore
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The icon element.
       */
      icon: PropTypes__default.node,

      /**
       * @ignore
       * For server-side rendering consideration, we let the selected tab
       * render the indicator.
       */
      indicator: PropTypes__default.node,

      /**
       * The label element.
       */
      label: PropTypes__default.node,

      /**
       * @ignore
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onClick: PropTypes__default.func,

      /**
       * @ignore
       */
      selected: PropTypes__default.bool,

      /**
       * @ignore
       */
      textColor: PropTypes__default.oneOf(['secondary', 'primary', 'inherit']),

      /**
       * You can provide your own value. Otherwise, we fallback to the child position index.
       */
      value: PropTypes__default.any,

      /**
       * Tab labels appear in a single row.
       * They can use a second line if needed.
       */
      wrapped: PropTypes__default.bool
    };
    withStyles(styles$1x, {
      name: 'MuiTab'
    })(Tab);

    /**
     * @ignore - internal component.
     */

    var TableContext = React__default.createContext();

    var styles$1y = {
      /* Styles applied to the root element. */
      root: {
        display: 'table',
        width: '100%',
        borderCollapse: 'collapse',
        borderSpacing: 0
      }
    };
    var Table = React__default.forwardRef(function Table(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'table' : _props$component,
          _props$padding = props.padding,
          padding = _props$padding === void 0 ? 'default' : _props$padding,
          _props$size = props.size,
          size = _props$size === void 0 ? 'medium' : _props$size,
          other = objectWithoutProperties(props, ["classes", "className", "component", "padding", "size"]);

      var table = React__default.useMemo(function () {
        return {
          padding: padding,
          size: size
        };
      }, [padding, size]);
      return React__default.createElement(TableContext.Provider, {
        value: table
      }, React__default.createElement(Component, _extends_1({
        ref: ref,
        className: clsx(classes.root, className)
      }, other)));
    });
    Table.propTypes = {
      /**
       * The content of the table, normally `TableHead` and `TableBody`.
       */
      children: PropTypes__default.node.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Allows TableCells to inherit padding of the Table.
       */
      padding: PropTypes__default.oneOf(['default', 'checkbox', 'none']),

      /**
       * Allows TableCells to inherit size of the Table.
       */
      size: PropTypes__default.oneOf(['small', 'medium'])
    };
    withStyles(styles$1y, {
      name: 'MuiTable'
    })(Table);

    /**
     * @ignore - internal component.
     */

    var Tablelvl2Context = React__default.createContext();

    var styles$1z = {
      /* Styles applied to the root element. */
      root: {
        display: 'table-row-group'
      }
    };
    var tablelvl2 = {
      variant: 'body'
    };
    var TableBody = React__default.forwardRef(function TableBody(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'tbody' : _props$component,
          other = objectWithoutProperties(props, ["classes", "className", "component"]);

      return React__default.createElement(Tablelvl2Context.Provider, {
        value: tablelvl2
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other)));
    });
    TableBody.propTypes = {
      /**
       * The content of the component, normally `TableRow`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType
    };
    withStyles(styles$1z, {
      name: 'MuiTableBody'
    })(TableBody);

    var styles$1A = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: _extends_1({}, theme.typography.body2, {
          display: 'table-cell',
          verticalAlign: 'inherit',
          // Workaround for a rendering bug with spanned columns in Chrome 62.0.
          // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
          borderBottom: "1px solid\n    ".concat(theme.palette.type === 'light' ? lighten(fade(theme.palette.divider, 1), 0.88) : darken(fade(theme.palette.divider, 1), 0.68)),
          textAlign: 'left',
          padding: '14px 40px 14px 16px',
          '&:last-child': {
            paddingRight: 16
          }
        }),

        /* Styles applied to the root element if `variant="head"` or `context.table.head`. */
        head: {
          color: theme.palette.text.secondary,
          fontSize: theme.typography.pxToRem(12),
          lineHeight: theme.typography.pxToRem(21),
          fontWeight: theme.typography.fontWeightMedium
        },

        /* Styles applied to the root element if `variant="body"` or `context.table.body`. */
        body: {
          color: theme.palette.text.primary,
          fontWeight: theme.typography.fontWeightRegular
        },

        /* Styles applied to the root element if `variant="footer"` or `context.table.footer`. */
        footer: {
          color: theme.palette.text.secondary,
          lineHeight: theme.typography.pxToRem(21),
          fontSize: theme.typography.pxToRem(12)
        },

        /* Styles applied to the root element if `padding="dense"`. */
        sizeSmall: {
          padding: '6px 24px 6px 16px',
          '&:last-child': {
            paddingRight: 16
          },
          '&$paddingCheckbox': {
            width: 24,
            // prevent the checkbox column from growing
            padding: '0px 12px 0 16px',
            '&:last-child': {
              paddingLeft: 12,
              paddingRight: 16
            },
            '& > *': {
              padding: 0
            }
          }
        },

        /* Styles applied to the root element if `padding="checkbox"`. */
        paddingCheckbox: {
          width: 48,
          // prevent the checkbox column from growing
          padding: '0 0 0 4px',
          '&:last-child': {
            paddingLeft: 0,
            paddingRight: 4
          }
        },

        /* Styles applied to the root element if `padding="none"`. */
        paddingNone: {
          padding: 0,
          '&:last-child': {
            padding: 0
          }
        },

        /* Styles applied to the root element if `align="left"`. */
        alignLeft: {
          textAlign: 'left'
        },

        /* Styles applied to the root element if `align="center"`. */
        alignCenter: {
          textAlign: 'center'
        },

        /* Styles applied to the root element if `align="right"`. */
        alignRight: {
          textAlign: 'right',
          flexDirection: 'row-reverse'
        },

        /* Styles applied to the root element if `align="justify"`. */
        alignJustify: {
          textAlign: 'justify'
        }
      };
    };
    var TableCell = React__default.forwardRef(function TableCell(props, ref) {
      var _props$align = props.align,
          align = _props$align === void 0 ? 'inherit' : _props$align,
          classes = props.classes,
          className = props.className,
          component = props.component,
          paddingProp = props.padding,
          scopeProp = props.scope,
          sizeProp = props.size,
          sortDirection = props.sortDirection,
          variant = props.variant,
          other = objectWithoutProperties(props, ["align", "classes", "className", "component", "padding", "scope", "size", "sortDirection", "variant"]);

      var table = React__default.useContext(TableContext);
      var tablelvl2 = React__default.useContext(Tablelvl2Context);
      var Component;

      if (component) {
        Component = component;
      } else {
        Component = tablelvl2 && tablelvl2.variant === 'head' ? 'th' : 'td';
      }

      var scope = scopeProp;

      if (!scope && tablelvl2 && tablelvl2.variant === 'head') {
        scope = 'col';
      }

      var padding = paddingProp || (table && table.padding ? table.padding : 'default');
      var size = sizeProp || (table && table.size ? table.size : 'medium');
      var ariaSort = null;

      if (sortDirection) {
        ariaSort = sortDirection === 'asc' ? 'ascending' : 'descending';
      }

      return React__default.createElement(Component, _extends_1({
        ref: ref,
        className: clsx(classes.root, (variant ? variant === 'head' : tablelvl2 && tablelvl2.variant === 'head') && classes.head, (variant ? variant === 'body' : tablelvl2 && tablelvl2.variant === 'body') && classes.body, (variant ? variant === 'footer' : tablelvl2 && tablelvl2.variant === 'footer') && classes.footer, align !== 'inherit' && classes["align".concat(capitalize(align))], padding !== 'default' && classes["padding".concat(capitalize(padding))], size !== 'medium' && classes["size".concat(capitalize(size))], className),
        "aria-sort": ariaSort,
        scope: scope
      }, other));
    });
    TableCell.propTypes = {
      /**
       * Set the text-align on the table cell content.
       *
       * Monetary or generally number fields **should be right aligned** as that allows
       * you to add them up quickly in your head without having to worry about decimals.
       */
      align: PropTypes__default.oneOf(['inherit', 'left', 'center', 'right', 'justify']),

      /**
       * The table cell contents.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Sets the padding applied to the cell.
       * By default, the Table parent component set the value.
       */
      padding: PropTypes__default.oneOf(['default', 'checkbox', 'none']),

      /**
       * Set scope attribute.
       */
      scope: PropTypes__default.string,

      /**
       * Specify the size of the cell.
       * By default, the Table parent component set the value (`normal`).
       */
      size: PropTypes__default.oneOf(['small', 'medium']),

      /**
       * Set aria-sort direction.
       */
      sortDirection: PropTypes__default.oneOf(['asc', 'desc', false]),

      /**
       * Specify the cell type.
       * By default, the TableHead, TableBody or TableFooter parent component set the value.
       */
      variant: PropTypes__default.oneOf(['head', 'body', 'footer'])
    };
    var TableCell$1 = withStyles(styles$1A, {
      name: 'MuiTableCell'
    })(TableCell);

    var styles$1B = {
      /* Styles applied to the root element. */
      root: {
        display: 'table-footer-group'
      }
    };
    var tablelvl2$1 = {
      variant: 'footer'
    };
    var TableFooter = React__default.forwardRef(function TableFooter(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'tfoot' : _props$component,
          other = objectWithoutProperties(props, ["classes", "className", "component"]);

      return React__default.createElement(Tablelvl2Context.Provider, {
        value: tablelvl2$1
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other)));
    });
    TableFooter.propTypes = {
      /**
       * The content of the component, normally `TableRow`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType
    };
    withStyles(styles$1B, {
      name: 'MuiTableFooter'
    })(TableFooter);

    var styles$1C = {
      /* Styles applied to the root element. */
      root: {
        display: 'table-header-group'
      }
    };
    var tablelvl2$2 = {
      variant: 'head'
    };
    var TableHead = React__default.forwardRef(function TableHead(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'thead' : _props$component,
          other = objectWithoutProperties(props, ["classes", "className", "component"]);

      return React__default.createElement(Tablelvl2Context.Provider, {
        value: tablelvl2$2
      }, React__default.createElement(Component, _extends_1({
        className: clsx(classes.root, className),
        ref: ref
      }, other)));
    });
    TableHead.propTypes = {
      /**
       * The content of the component, normally `TableRow`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType
    };
    withStyles(styles$1C, {
      name: 'MuiTableHead'
    })(TableHead);

    var styles$1D = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'relative',
          display: 'flex',
          alignItems: 'center'
        },

        /* Styles applied to the root element if `disableGutters={false}`. */
        gutters: defineProperty({
          paddingLeft: theme.spacing(2),
          paddingRight: theme.spacing(2)
        }, theme.breakpoints.up('sm'), {
          paddingLeft: theme.spacing(3),
          paddingRight: theme.spacing(3)
        }),

        /* Styles applied to the root element if `variant="regular"`. */
        regular: theme.mixins.toolbar,

        /* Styles applied to the root element if `variant="dense"`. */
        dense: {
          minHeight: 48
        }
      };
    };
    var Toolbar = React__default.forwardRef(function Toolbar(props, ref) {
      var classes = props.classes,
          classNameProp = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'div' : _props$component,
          _props$disableGutters = props.disableGutters,
          disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'regular' : _props$variant,
          other = objectWithoutProperties(props, ["classes", "className", "component", "disableGutters", "variant"]);

      var className = clsx(classes.root, classes[variant], !disableGutters && classes.gutters, classNameProp);
      return React__default.createElement(Component, _extends_1({
        className: className,
        ref: ref
      }, other));
    });
    Toolbar.propTypes = {
      /**
       * Toolbar children, usually a mixture of `IconButton`, `Button` and `Typography`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, disables gutter padding.
       */
      disableGutters: PropTypes__default.bool,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['regular', 'dense'])
    };
    var Toolbar$1 = withStyles(styles$1D, {
      name: 'MuiToolbar'
    })(Toolbar);

    /**
     * @ignore - internal component.
     */

    var KeyboardArrowLeft = createSvgIcon(React__default.createElement("path", {
      d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
    }), 'KeyboardArrowLeft');

    /**
     * @ignore - internal component.
     */

    var KeyboardArrowRight = createSvgIcon(React__default.createElement("path", {
      d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
    }), 'KeyboardArrowRight');

    /**
     * @ignore - internal component.
     */

    var _ref$2 = React__default.createElement(KeyboardArrowRight, null);

    var _ref2 = React__default.createElement(KeyboardArrowLeft, null);

    var _ref3 = React__default.createElement(KeyboardArrowLeft, null);

    var _ref4 = React__default.createElement(KeyboardArrowRight, null);

    var TablePaginationActions = React__default.forwardRef(function TablePaginationActions(props, ref) {
      var backIconButtonProps = props.backIconButtonProps,
          count = props.count,
          nextIconButtonProps = props.nextIconButtonProps,
          onChangePage = props.onChangePage,
          page = props.page,
          rowsPerPage = props.rowsPerPage,
          theme = props.theme,
          other = objectWithoutProperties(props, ["backIconButtonProps", "count", "nextIconButtonProps", "onChangePage", "page", "rowsPerPage", "theme"]);

      var handleBackButtonClick = function handleBackButtonClick(event) {
        onChangePage(event, page - 1);
      };

      var handleNextButtonClick = function handleNextButtonClick(event) {
        onChangePage(event, page + 1);
      };

      return React__default.createElement("div", _extends_1({
        ref: ref
      }, other), React__default.createElement(IconButton$1, _extends_1({
        onClick: handleBackButtonClick,
        disabled: page === 0,
        color: "inherit"
      }, backIconButtonProps), theme.direction === 'rtl' ? _ref$2 : _ref2), React__default.createElement(IconButton$1, _extends_1({
        onClick: handleNextButtonClick,
        disabled: page >= Math.ceil(count / rowsPerPage) - 1,
        color: "inherit"
      }, nextIconButtonProps), theme.direction === 'rtl' ? _ref3 : _ref4));
    });
    TablePaginationActions.propTypes = {
      /**
       * Properties applied to the back arrow [`IconButton`](/api/icon-button/) element.
       */
      backIconButtonProps: PropTypes__default.object,

      /**
       * The total number of rows.
       */
      count: PropTypes__default.number.isRequired,

      /**
       * Properties applied to the next arrow [`IconButton`](/api/icon-button/) element.
       */
      nextIconButtonProps: PropTypes__default.object,

      /**
       * Callback fired when the page is changed.
       *
       * @param {object} event The event source of the callback
       * @param {number} page The page selected
       */
      onChangePage: PropTypes__default.func.isRequired,

      /**
       * The zero-based index of the current page.
       */
      page: PropTypes__default.number.isRequired,

      /**
       * The number of rows per page.
       */
      rowsPerPage: PropTypes__default.number.isRequired,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired
    };
    var TablePaginationActions$1 = withTheme(TablePaginationActions);

    var styles$1E = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          color: theme.palette.text.secondary,
          fontSize: theme.typography.pxToRem(12),
          // Increase the specificity to override TableCell.
          '&:last-child': {
            padding: 0
          }
        },

        /* Styles applied to the Toolbar component. */
        toolbar: {
          height: 56,
          minHeight: 56,
          paddingRight: 2
        },

        /* Styles applied to the spacer element. */
        spacer: {
          flex: '1 1 100%'
        },

        /* Styles applied to the caption Typography components if `variant="caption"`. */
        caption: {
          flexShrink: 0
        },

        /* Styles applied to the Select component `root` class. */
        selectRoot: {
          marginRight: 32,
          marginLeft: 8
        },

        /* Styles applied to the Select component `select` class. */
        select: {
          paddingLeft: 8,
          paddingRight: 24,
          textAlign: 'right',
          textAlignLast: 'right' // Align <select> on Chrome.

        },

        /* Styles applied to the Select component `icon` class. */
        selectIcon: {
          top: 1
        },

        /* Styles applied to the `InputBase` component. */
        input: {
          color: 'inherit',
          fontSize: 'inherit',
          flexShrink: 0
        },

        /* Styles applied to the MenuItem component. */
        menuItem: {},

        /* Styles applied to the internal `TablePaginationActions` component. */
        actions: {
          flexShrink: 0,
          marginLeft: 20
        }
      };
    };

    var defaultLabelDisplayedRows = function defaultLabelDisplayedRows(_ref) {
      var from = _ref.from,
          to = _ref.to,
          count = _ref.count;
      return "".concat(from, "-").concat(to, " of ").concat(count);
    };

    var defaultRowsPerPageOptions = [10, 25, 50, 100];
    /**
     * A `TableCell` based component for placing inside `TableFooter` for pagination.
     */

    var TablePagination = React__default.forwardRef(function TablePagination(props, ref) {
      var _props$ActionsCompone = props.ActionsComponent,
          ActionsComponent = _props$ActionsCompone === void 0 ? TablePaginationActions$1 : _props$ActionsCompone,
          backIconButtonProps = props.backIconButtonProps,
          classes = props.classes,
          colSpanProp = props.colSpan,
          _props$component = props.component,
          Component = _props$component === void 0 ? TableCell$1 : _props$component,
          count = props.count,
          _props$labelDisplayed = props.labelDisplayedRows,
          labelDisplayedRows = _props$labelDisplayed === void 0 ? defaultLabelDisplayedRows : _props$labelDisplayed,
          _props$labelRowsPerPa = props.labelRowsPerPage,
          labelRowsPerPage = _props$labelRowsPerPa === void 0 ? 'Rows per page:' : _props$labelRowsPerPa,
          nextIconButtonProps = props.nextIconButtonProps,
          onChangePage = props.onChangePage,
          onChangeRowsPerPage = props.onChangeRowsPerPage,
          page = props.page,
          rowsPerPage = props.rowsPerPage,
          _props$rowsPerPageOpt = props.rowsPerPageOptions,
          rowsPerPageOptions = _props$rowsPerPageOpt === void 0 ? defaultRowsPerPageOptions : _props$rowsPerPageOpt,
          _props$SelectProps = props.SelectProps,
          SelectProps = _props$SelectProps === void 0 ? {} : _props$SelectProps,
          other = objectWithoutProperties(props, ["ActionsComponent", "backIconButtonProps", "classes", "colSpan", "component", "count", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onChangePage", "onChangeRowsPerPage", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps"]);

      var colSpan;

      if (Component === TableCell$1 || Component === 'td') {
        colSpan = colSpanProp || 1000; // col-span over everything
      }

      var MenuItemComponent = SelectProps.native ? 'option' : MenuItem$1;
      return React__default.createElement(Component, _extends_1({
        className: classes.root,
        colSpan: colSpan,
        ref: ref
      }, other), React__default.createElement(Toolbar$1, {
        className: classes.toolbar
      }, React__default.createElement("div", {
        className: classes.spacer
      }), rowsPerPageOptions.length > 1 && React__default.createElement(Typography$1, {
        color: "inherit",
        variant: "caption",
        className: classes.caption
      }, labelRowsPerPage), rowsPerPageOptions.length > 1 && React__default.createElement(Select$1, _extends_1({
        classes: {
          root: classes.selectRoot,
          select: classes.select,
          icon: classes.selectIcon
        },
        input: React__default.createElement(InputBase$1, {
          className: classes.input
        }),
        value: rowsPerPage,
        onChange: onChangeRowsPerPage
      }, SelectProps), rowsPerPageOptions.map(function (rowsPerPageOption) {
        return React__default.createElement(MenuItemComponent, {
          className: classes.menuItem,
          key: rowsPerPageOption,
          value: rowsPerPageOption
        }, rowsPerPageOption);
      })), React__default.createElement(Typography$1, {
        color: "inherit",
        variant: "caption",
        className: classes.caption
      }, labelDisplayedRows({
        from: count === 0 ? 0 : page * rowsPerPage + 1,
        to: Math.min(count, (page + 1) * rowsPerPage),
        count: count,
        page: page
      })), React__default.createElement(ActionsComponent, {
        className: classes.actions,
        backIconButtonProps: backIconButtonProps,
        count: count,
        nextIconButtonProps: nextIconButtonProps,
        onChangePage: onChangePage,
        page: page,
        rowsPerPage: rowsPerPage
      })));
    });
    TablePagination.propTypes = {
      /**
       * The component used for displaying the actions.
       * Either a string to use a DOM element or a component.
       */
      ActionsComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the back arrow [`IconButton`](/api/icon-button/) component.
       */
      backIconButtonProps: PropTypes__default.object,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      colSpan: PropTypes__default.number,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * The total number of rows.
       */
      count: PropTypes__default.number.isRequired,

      /**
       * Customize the displayed rows label.
       */
      labelDisplayedRows: PropTypes__default.func,

      /**
       * Customize the rows per page label. Invoked with a `{ from, to, count, page }`
       * object.
       */
      labelRowsPerPage: PropTypes__default.node,

      /**
       * Properties applied to the next arrow [`IconButton`](/api/icon-button/) element.
       */
      nextIconButtonProps: PropTypes__default.object,

      /**
       * Callback fired when the page is changed.
       *
       * @param {object} event The event source of the callback
       * @param {number} page The page selected
       */
      onChangePage: PropTypes__default.func.isRequired,

      /**
       * Callback fired when the number of rows per page is changed.
       *
       * @param {object} event The event source of the callback
       */
      onChangeRowsPerPage: PropTypes__default.func,

      /**
       * The zero-based index of the current page.
       */
      page: chainPropTypes(PropTypes__default.number.isRequired, function (props) {
        var count = props.count,
            page = props.page,
            rowsPerPage = props.rowsPerPage;
        var newLastPage = Math.max(0, Math.ceil(count / rowsPerPage) - 1);

        if (page < 0 || page > newLastPage) {
          return new Error('Material-UI: the page prop of a TablePagination is out of range ' + "(0 to ".concat(newLastPage, ", but page is ").concat(page, ")."));
        }

        return null;
      }),

      /**
       * The number of rows per page.
       */
      rowsPerPage: PropTypes__default.number.isRequired,

      /**
       * Customizes the options of the rows per page select field. If less than two options are
       * available, no select field will be displayed.
       */
      rowsPerPageOptions: PropTypes__default.array,

      /**
       * Properties applied to the rows per page [`Select`](/api/select/) element.
       */
      SelectProps: PropTypes__default.object
    };
    withStyles(styles$1E, {
      name: 'MuiTablePagination'
    })(TablePagination);

    var styles$1F = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          color: 'inherit',
          display: 'table-row',
          verticalAlign: 'middle',
          // We disable the focus ring for mouse, touch and keyboard users.
          outline: 'none',
          '&$selected': {
            backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.04)' // grey[100]
            : 'rgba(255, 255, 255, 0.08)'
          },
          '&$hover:hover': {
            backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.07)' // grey[200]
            : 'rgba(255, 255, 255, 0.14)'
          }
        },

        /* Styles applied to the root element if `selected={true}`. */
        selected: {},

        /* Styles applied to the root element if `hover={true}`. */
        hover: {},

        /* Styles applied to the root element if table variant="head". */
        head: {},

        /* Styles applied to the root element if table variant="footer". */
        footer: {}
      };
    };
    /**
     * Will automatically set dynamic row height
     * based on the material table element parent (head, body, etc).
     */

    var TableRow = React__default.forwardRef(function TableRow(props, ref) {
      var classes = props.classes,
          className = props.className,
          _props$component = props.component,
          Component = _props$component === void 0 ? 'tr' : _props$component,
          _props$hover = props.hover,
          hover = _props$hover === void 0 ? false : _props$hover,
          _props$selected = props.selected,
          selected = _props$selected === void 0 ? false : _props$selected,
          other = objectWithoutProperties(props, ["classes", "className", "component", "hover", "selected"]);

      var tablelvl2 = React__default.useContext(Tablelvl2Context);
      return React__default.createElement(Component, _extends_1({
        ref: ref,
        className: clsx(classes.root, className, tablelvl2 && [tablelvl2.variant === 'head' && classes.head, tablelvl2.variant === 'footer' && classes.footer], hover && classes.hover, selected && classes.selected)
      }, other));
    });
    TableRow.propTypes = {
      /**
       * Should be valid <tr> children such as `TableCell`.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * If `true`, the table row will shade on hover.
       */
      hover: PropTypes__default.bool,

      /**
       * If `true`, the table row will have the selected shading.
       */
      selected: PropTypes__default.bool
    };
    withStyles(styles$1F, {
      name: 'MuiTableRow'
    })(TableRow);

    /**
     * @ignore - internal component.
     */

    var ArrowDownwardIcon = createSvgIcon(React__default.createElement("path", {
      d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
    }), 'ArrowDownward');

    var styles$1G = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          cursor: 'pointer',
          display: 'inline-flex',
          justifyContent: 'flex-start',
          flexDirection: 'inherit',
          alignItems: 'center',
          '&:focus': {
            color: theme.palette.text.primary
          },
          '&:hover': {
            color: theme.palette.text.primary,
            '& $icon': {
              opacity: 1,
              color: theme.palette.text.secondary
            }
          },
          '&$active': {
            color: theme.palette.text.primary,
            // && instead of & is a workaround for https://github.com/cssinjs/jss/issues/1045
            '&& $icon': {
              opacity: 1,
              color: theme.palette.text.primary
            }
          }
        },

        /* Styles applied to the root element if `active={true}`. */
        active: {},

        /* Styles applied to the icon component. */
        icon: {
          height: 18,
          marginRight: 4,
          marginLeft: 4,
          opacity: 0,
          transition: theme.transitions.create(['opacity', 'transform'], {
            duration: theme.transitions.duration.shorter
          }),
          userSelect: 'none',
          width: 18
        },

        /* Styles applied to the icon component if `direction="desc"`. */
        iconDirectionDesc: {
          transform: 'rotate(0deg)'
        },

        /* Styles applied to the icon component if `direction="asc"`. */
        iconDirectionAsc: {
          transform: 'rotate(180deg)'
        }
      };
    };
    /**
     * A button based label for placing inside `TableCell` for column sorting.
     */

    var TableSortLabel = React__default.forwardRef(function TableSortLabel(props, ref) {
      var _props$active = props.active,
          active = _props$active === void 0 ? false : _props$active,
          children = props.children,
          classes = props.classes,
          className = props.className,
          _props$direction = props.direction,
          direction = _props$direction === void 0 ? 'desc' : _props$direction,
          _props$hideSortIcon = props.hideSortIcon,
          hideSortIcon = _props$hideSortIcon === void 0 ? false : _props$hideSortIcon,
          _props$IconComponent = props.IconComponent,
          IconComponent = _props$IconComponent === void 0 ? ArrowDownwardIcon : _props$IconComponent,
          other = objectWithoutProperties(props, ["active", "children", "classes", "className", "direction", "hideSortIcon", "IconComponent"]);

      return React__default.createElement(ButtonBase$1, _extends_1({
        className: clsx(classes.root, active && classes.active, className),
        component: "span",
        disableRipple: true,
        ref: ref
      }, other), children, hideSortIcon && !active ? null : React__default.createElement(IconComponent, {
        className: clsx(classes.icon, classes["iconDirection".concat(capitalize(direction))])
      }));
    });
    TableSortLabel.propTypes = {
      /**
       * If `true`, the label will have the active styling (should be true for the sorted column).
       */
      active: PropTypes__default.bool,

      /**
       * Label contents, the arrow will be appended automatically.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The current sort direction.
       */
      direction: PropTypes__default.oneOf(['asc', 'desc']),

      /**
       * Hide sort icon when active is false.
       */
      hideSortIcon: PropTypes__default.bool,

      /**
       * Sort icon to use.
       */
      IconComponent: PropTypes__default.elementType
    };
    withStyles(styles$1G, {
      name: 'MuiTableSortLabel'
    })(TableSortLabel);

    var main = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    // Based on https://github.com/react-bootstrap/dom-helpers/blob/master/src/util/inDOM.js
    var inDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    var cachedType;
    function _setScrollType(type) {
        cachedType = type;
    }
    exports._setScrollType = _setScrollType;
    // Based on the jquery plugin https://github.com/othree/jquery.rtl-scroll-type
    function detectScrollType() {
        if (cachedType) {
            return cachedType;
        }
        if (!inDOM || !window.document.body) {
            return 'indeterminate';
        }
        var dummy = window.document.createElement('div');
        dummy.appendChild(document.createTextNode('ABCD'));
        dummy.dir = 'rtl';
        dummy.style.fontSize = '14px';
        dummy.style.width = '4px';
        dummy.style.height = '1px';
        dummy.style.position = 'absolute';
        dummy.style.top = '-1000px';
        dummy.style.overflow = 'scroll';
        document.body.appendChild(dummy);
        cachedType = 'reverse';
        if (dummy.scrollLeft > 0) {
            cachedType = 'default';
        }
        else {
            dummy.scrollLeft = 1;
            if (dummy.scrollLeft === 0) {
                cachedType = 'negative';
            }
        }
        document.body.removeChild(dummy);
        return cachedType;
    }
    exports.detectScrollType = detectScrollType;
    // Based on https://stackoverflow.com/a/24394376
    function getNormalizedScrollLeft(element, direction) {
        var scrollLeft = element.scrollLeft;
        // Perform the calculations only when direction is rtl to avoid messing up the ltr bahavior
        if (direction !== 'rtl') {
            return scrollLeft;
        }
        var type = detectScrollType();
        if (type === 'indeterminate') {
            return Number.NaN;
        }
        switch (type) {
            case 'negative':
                return element.scrollWidth - element.clientWidth + scrollLeft;
            case 'reverse':
                return element.scrollWidth - element.clientWidth - scrollLeft;
        }
        return scrollLeft;
    }
    exports.getNormalizedScrollLeft = getNormalizedScrollLeft;
    function setNormalizedScrollLeft(element, scrollLeft, direction) {
        // Perform the calculations only when direction is rtl to avoid messing up the ltr bahavior
        if (direction !== 'rtl') {
            element.scrollLeft = scrollLeft;
            return;
        }
        var type = detectScrollType();
        if (type === 'indeterminate') {
            return;
        }
        switch (type) {
            case 'negative':
                element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;
                break;
            case 'reverse':
                element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
                break;
            default:
                element.scrollLeft = scrollLeft;
                break;
        }
    }
    exports.setNormalizedScrollLeft = setNormalizedScrollLeft;
    });

    unwrapExports(main);
    var main_1 = main._setScrollType;
    var main_2 = main.detectScrollType;
    var main_3 = main.getNormalizedScrollLeft;
    var main_4 = main.setNormalizedScrollLeft;

    function easeInOutSin(time) {
      return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
    }

    function animate(prop, element, to) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var cb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};
      var _options$ease = options.ease,
          ease = _options$ease === void 0 ? easeInOutSin : _options$ease,
          _options$duration = options.duration,
          duration = _options$duration === void 0 ? 300 : _options$duration;
      var start = null;
      var from = element[prop];
      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      var step = function step(timestamp) {
        if (cancelled) {
          cb(new Error('Animation cancelled'));
          return;
        }

        if (start === null) {
          start = timestamp;
        }

        var time = Math.min(1, (timestamp - start) / duration);
        element[prop] = ease(time) * (to - from) + from;

        if (time >= 1) {
          requestAnimationFrame(function () {
            cb(null);
          });
          return;
        }

        requestAnimationFrame(step);
      };

      if (from === to) {
        cb(new Error('Element already at target position'));
        return cancel;
      }

      requestAnimationFrame(step);
      return cancel;
    }

    var styles$1H = {
      width: 99,
      height: 99,
      position: 'absolute',
      top: -9999,
      overflow: 'scroll'
    };
    /**
     * @ignore - internal component.
     * The component is originates from https://github.com/STORIS/react-scrollbar-size.
     * It has been moved into the core in order to minimize the bundle size.
     */

    function ScrollbarSize(props) {
      var onChange = props.onChange,
          other = objectWithoutProperties(props, ["onChange"]);

      var scrollbarHeight = React__default.useRef();
      var nodeRef = React__default.useRef(null);

      var setMeasurements = function setMeasurements() {
        scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
      };

      React__default.useEffect(function () {
        var handleResize = debounce_1(function () {
          var prevHeight = scrollbarHeight.current;
          setMeasurements();

          if (prevHeight !== scrollbarHeight.current) {
            onChange(scrollbarHeight.current);
          }
        }, 166); // Corresponds to 10 frames at 60 Hz.

        window.addEventListener('resize', handleResize);
        return function () {
          handleResize.clear();
          window.removeEventListener('resize', handleResize);
        };
      }, [onChange]);
      React__default.useEffect(function () {
        setMeasurements();
        onChange(scrollbarHeight.current);
      }, [onChange]);
      return React__default.createElement("div", _extends_1({
        style: styles$1H,
        ref: nodeRef
      }, other));
    }
    ScrollbarSize.propTypes = {
      onChange: PropTypes__default.func.isRequired
    };

    var styles$1I = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          position: 'absolute',
          height: 2,
          bottom: 0,
          width: '100%',
          transition: theme.transitions.create()
        },

        /* Styles applied to the root element if `color="primary"`. */
        colorPrimary: {
          backgroundColor: theme.palette.primary.main
        },

        /* Styles applied to the root element if `color="secondary"`. */
        colorSecondary: {
          backgroundColor: theme.palette.secondary.main
        }
      };
    };
    /**
     * @ignore - internal component.
     */

    var TabIndicator = React__default.forwardRef(function TabIndicator(props, ref) {
      var classes = props.classes,
          className = props.className,
          color = props.color,
          other = objectWithoutProperties(props, ["classes", "className", "color"]);

      return React__default.createElement("span", _extends_1({
        className: clsx(classes.root, classes["color".concat(capitalize(color))], className),
        ref: ref
      }, other));
    });
    TabIndicator.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * @ignore
       * The color of the tab indicator.
       */
      color: PropTypes__default.oneOf(['primary', 'secondary'])
    };
    var TabIndicator$1 = withStyles(styles$1I, {
      name: 'PrivateTabIndicator'
    })(TabIndicator);

    var styles$1J = {
      /* Styles applied to the root element. */
      root: {
        color: 'inherit',
        width: 40,
        flexShrink: 0
      }
    };
    /**
     * @ignore - internal component.
     */

    var _ref$3 = React__default.createElement(KeyboardArrowLeft, {
      fontSize: "small"
    });

    var _ref2$1 = React__default.createElement(KeyboardArrowRight, {
      fontSize: "small"
    });

    var TabScrollButton = React__default.forwardRef(function TabScrollButton(props, ref) {
      var classes = props.classes,
          classNameProp = props.className,
          direction = props.direction,
          onClick = props.onClick,
          _props$visible = props.visible,
          visible = _props$visible === void 0 ? true : _props$visible,
          other = objectWithoutProperties(props, ["classes", "className", "direction", "onClick", "visible"]);

      var className = clsx(classes.root, classNameProp);

      if (!visible) {
        return React__default.createElement("div", {
          className: className
        });
      }

      return React__default.createElement(ButtonBase$1, _extends_1({
        component: "div",
        className: className,
        onClick: onClick,
        ref: ref,
        role: null,
        tabIndex: null
      }, other), direction === 'left' ? _ref$3 : _ref2$1);
    });
    TabScrollButton.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * Which direction should the button indicate?
       */
      direction: PropTypes__default.oneOf(['left', 'right']),

      /**
       * Callback to execute for button press.
       */
      onClick: PropTypes__default.func,

      /**
       * Should the button be present or just consume space.
       */
      visible: PropTypes__default.bool
    };
    var TabScrollButton$1 = withStyles(styles$1J, {
      name: 'PrivateTabScrollButton'
    })(TabScrollButton);

    var styles$1K = function styles(theme) {
      return {
        /* Styles applied to the root element. */
        root: {
          overflow: 'hidden',
          minHeight: 48,
          WebkitOverflowScrolling: 'touch' // Add iOS momentum scrolling.

        },

        /* Styles applied to the flex container element. */
        flexContainer: {
          display: 'flex'
        },

        /* Styles applied to the flex container element if `centered={true}` & `!variant="scrollable"`. */
        centered: {
          justifyContent: 'center'
        },

        /* Styles applied to the tablist element. */
        scroller: {
          position: 'relative',
          display: 'inline-block',
          flex: '1 1 auto',
          whiteSpace: 'nowrap'
        },

        /* Styles applied to the tablist element if `!variant="scrollable"`. */
        fixed: {
          overflowX: 'hidden',
          width: '100%'
        },

        /* Styles applied to the tablist element if `variant="scrollable"`. */
        scrollable: {
          overflowX: 'scroll',
          // Hide dimensionless scrollbar on MacOS
          scrollbarWidth: 'none',
          // Firefox
          '&::-webkit-scrollbar': {
            display: 'none' // Safari + Chrome

          }
        },

        /* Styles applied to the `ScrollButtonComponent` component. */
        scrollButtons: {},

        /* Styles applied to the `ScrollButtonComponent` component if `scrollButtons="auto"` or scrollButtons="desktop"`. */
        scrollButtonsDesktop: defineProperty({}, theme.breakpoints.down('xs'), {
          display: 'none'
        }),

        /* Styles applied to the `TabIndicator` component. */
        indicator: {}
      };
    };

    var Tabs =
    /*#__PURE__*/
    function (_React$Component) {
      inherits(Tabs, _React$Component);

      function Tabs() {
        var _this;

        classCallCheck(this, Tabs);

        _this = possibleConstructorReturn(this, getPrototypeOf(Tabs).call(this));
        _this.state = {
          indicatorStyle: {},
          scrollerStyle: {
            overflow: 'hidden',
            marginBottom: null
          },
          showLeftScroll: false,
          showRightScroll: false,
          mounted: false
        };

        _this.getConditionalElements = function () {
          var _this$props = _this.props,
              classes = _this$props.classes,
              ScrollButtonComponent = _this$props.ScrollButtonComponent,
              scrollButtons = _this$props.scrollButtons,
              theme = _this$props.theme,
              variant = _this$props.variant;
          var _this$state = _this.state,
              showLeftScroll = _this$state.showLeftScroll,
              showRightScroll = _this$state.showRightScroll;
          var conditionalElements = {};
          var scrollable = variant === 'scrollable';
          conditionalElements.scrollbarSizeListener = scrollable ? React__default.createElement(ScrollbarSize, {
            className: classes.scrollable,
            onChange: _this.handleScrollbarSizeChange
          }) : null;
          var scrollButtonsActive = showLeftScroll || showRightScroll;
          var showScrollButtons = scrollable && (scrollButtons === 'auto' && scrollButtonsActive || scrollButtons === 'desktop' || scrollButtons === 'on');
          conditionalElements.scrollButtonLeft = showScrollButtons ? React__default.createElement(ScrollButtonComponent, {
            direction: theme.direction === 'rtl' ? 'right' : 'left',
            onClick: _this.handleLeftScrollClick,
            visible: showLeftScroll,
            className: clsx(classes.scrollButtons, scrollButtons !== 'on' && classes.scrollButtonsDesktop)
          }) : null;
          conditionalElements.scrollButtonRight = showScrollButtons ? React__default.createElement(ScrollButtonComponent, {
            direction: theme.direction === 'rtl' ? 'left' : 'right',
            onClick: _this.handleRightScrollClick,
            visible: showRightScroll,
            className: clsx(classes.scrollButtons, scrollButtons !== 'on' && classes.scrollButtonsDesktop)
          }) : null;
          return conditionalElements;
        };

        _this.getTabsMeta = function (value, direction) {
          var tabsMeta;

          if (_this.tabsRef) {
            var rect = _this.tabsRef.getBoundingClientRect(); // create a new object with ClientRect class props + scrollLeft


            tabsMeta = {
              clientWidth: _this.tabsRef.clientWidth,
              scrollLeft: _this.tabsRef.scrollLeft,
              scrollLeftNormalized: main_3(_this.tabsRef, direction),
              scrollWidth: _this.tabsRef.scrollWidth,
              left: rect.left,
              right: rect.right
            };
          }

          var tabMeta;

          if (_this.tabsRef && value !== false) {
            var children = _this.tabsRef.children[0].children;

            if (children.length > 0) {
              var tab = children[_this.valueToIndex.get(value)];

              warning_1(tab, ["Material-UI: the value provided `".concat(value, "` to the Tabs component is invalid."), 'None of the Tabs children have this value.', _this.valueToIndex.keys ? "You can provide one of the following values: ".concat(Array.from(_this.valueToIndex.keys()).join(', '), ".") : null].join('\n'));
              tabMeta = tab ? tab.getBoundingClientRect() : null;
            }
          }

          return {
            tabsMeta: tabsMeta,
            tabMeta: tabMeta
          };
        };

        _this.handleLeftScrollClick = function () {
          _this.moveTabsScroll(-_this.tabsRef.clientWidth);
        };

        _this.handleRightScrollClick = function () {
          _this.moveTabsScroll(_this.tabsRef.clientWidth);
        };

        _this.handleScrollbarSizeChange = function (scrollbarHeight) {
          _this.setState({
            scrollerStyle: {
              overflow: null,
              marginBottom: -scrollbarHeight
            }
          });
        };

        _this.handleTabsRef = function (ref) {
          _this.tabsRef = ref;
        };

        _this.moveTabsScroll = function (delta) {
          var theme = _this.props.theme;
          var multiplier = theme.direction === 'rtl' ? -1 : 1;
          var nextScrollLeft = _this.tabsRef.scrollLeft + delta * multiplier; // Fix for Edge

          var invert = theme.direction === 'rtl' && main_2() === 'reverse' ? -1 : 1;

          _this.scroll(invert * nextScrollLeft);
        };

        _this.scrollSelectedIntoView = function () {
          var _this$props2 = _this.props,
              theme = _this$props2.theme,
              value = _this$props2.value;

          var _this$getTabsMeta = _this.getTabsMeta(value, theme.direction),
              tabsMeta = _this$getTabsMeta.tabsMeta,
              tabMeta = _this$getTabsMeta.tabMeta;

          if (!tabMeta || !tabsMeta) {
            return;
          }

          if (tabMeta.left < tabsMeta.left) {
            // left side of button is out of view
            var nextScrollLeft = tabsMeta.scrollLeft + (tabMeta.left - tabsMeta.left);

            _this.scroll(nextScrollLeft);
          } else if (tabMeta.right > tabsMeta.right) {
            // right side of button is out of view
            var _nextScrollLeft = tabsMeta.scrollLeft + (tabMeta.right - tabsMeta.right);

            _this.scroll(_nextScrollLeft);
          }
        };

        _this.scroll = function (value) {
          animate('scrollLeft', _this.tabsRef, value);
        };

        _this.updateScrollButtonState = function () {
          var _this$props3 = _this.props,
              scrollButtons = _this$props3.scrollButtons,
              theme = _this$props3.theme,
              variant = _this$props3.variant;
          var scrollable = variant === 'scrollable';

          if (scrollable && scrollButtons !== 'off') {
            var _this$tabsRef = _this.tabsRef,
                scrollWidth = _this$tabsRef.scrollWidth,
                clientWidth = _this$tabsRef.clientWidth;
            var scrollLeft = main_3(_this.tabsRef, theme.direction); // use 1 for the potential rounding error with browser zooms.

            var showLeftScroll = theme.direction === 'rtl' ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
            var showRightScroll = theme.direction !== 'rtl' ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;

            if (showLeftScroll !== _this.state.showLeftScroll || showRightScroll !== _this.state.showRightScroll) {
              _this.setState({
                showLeftScroll: showLeftScroll,
                showRightScroll: showRightScroll
              });
            }
          }
        };

        if (typeof window !== 'undefined') {
          _this.handleResize = debounce_1(function () {
            _this.updateIndicatorState(_this.props);

            _this.updateScrollButtonState();
          }, 166); // Corresponds to 10 frames at 60 Hz.

          _this.handleTabsScroll = debounce_1(function () {
            _this.updateScrollButtonState();
          }, 166); // Corresponds to 10 frames at 60 Hz.
        }

        return _this;
      }

      createClass(Tabs, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.setState({
            mounted: true
          });
          this.updateIndicatorState(this.props);
          this.updateScrollButtonState();

          if (this.props.action) {
            this.props.action({
              updateIndicator: this.handleResize
            });
          }
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          // The index might have changed at the same time.
          // We need to check again the right indicator position.
          this.updateIndicatorState(this.props);
          this.updateScrollButtonState();

          if (this.state.indicatorStyle !== prevState.indicatorStyle) {
            this.scrollSelectedIntoView();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.handleResize.clear();
          this.handleTabsScroll.clear();
        }
      }, {
        key: "updateIndicatorState",
        value: function updateIndicatorState(props) {
          var theme = props.theme,
              value = props.value;

          var _this$getTabsMeta2 = this.getTabsMeta(value, theme.direction),
              tabsMeta = _this$getTabsMeta2.tabsMeta,
              tabMeta = _this$getTabsMeta2.tabMeta;

          var left = 0;

          if (tabMeta && tabsMeta) {
            var correction = theme.direction === 'rtl' ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
            left = Math.round(tabMeta.left - tabsMeta.left + correction);
          }

          var indicatorStyle = {
            left: left,
            // May be wrong until the font is loaded.
            width: tabMeta ? Math.round(tabMeta.width) : 0
          };

          if ((indicatorStyle.left !== this.state.indicatorStyle.left || indicatorStyle.width !== this.state.indicatorStyle.width) && !isNaN(indicatorStyle.left) && !isNaN(indicatorStyle.width)) {
            this.setState({
              indicatorStyle: indicatorStyle
            });
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;

          var _this$props4 = this.props,
              action = _this$props4.action,
              centered = _this$props4.centered,
              childrenProp = _this$props4.children,
              classes = _this$props4.classes,
              className = _this$props4.className,
              Component = _this$props4.component,
              indicatorColor = _this$props4.indicatorColor,
              innerRef = _this$props4.innerRef,
              onChange = _this$props4.onChange,
              ScrollButtonComponent = _this$props4.ScrollButtonComponent,
              scrollButtons = _this$props4.scrollButtons,
              _this$props4$TabIndic = _this$props4.TabIndicatorProps,
              TabIndicatorProps = _this$props4$TabIndic === void 0 ? {} : _this$props4$TabIndic,
              textColor = _this$props4.textColor,
              theme = _this$props4.theme,
              value = _this$props4.value,
              variant = _this$props4.variant,
              other = objectWithoutProperties(_this$props4, ["action", "centered", "children", "classes", "className", "component", "indicatorColor", "innerRef", "onChange", "ScrollButtonComponent", "scrollButtons", "TabIndicatorProps", "textColor", "theme", "value", "variant"]);

          var scrollable = variant === 'scrollable';
          warning_1(!centered || !scrollable, 'Material-UI: you can not use the `centered={true}` and `variant="scrollable"` properties ' + 'at the same time on a `Tabs` component.');
          var indicator = React__default.createElement(TabIndicator$1, _extends_1({
            className: classes.indicator,
            color: indicatorColor
          }, TabIndicatorProps, {
            style: _extends_1({}, this.state.indicatorStyle, TabIndicatorProps.style)
          }));
          this.valueToIndex = new Map();
          var childIndex = 0;
          var children = React__default.Children.map(childrenProp, function (child) {
            if (!React__default.isValidElement(child)) {
              return null;
            }

            warning_1(child.type !== React__default.Fragment, ["Material-UI: the Tabs component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
            var childValue = child.props.value === undefined ? childIndex : child.props.value;

            _this2.valueToIndex.set(childValue, childIndex);

            var selected = childValue === value;
            childIndex += 1;
            return React__default.cloneElement(child, {
              fullWidth: variant === 'fullWidth',
              indicator: selected && !_this2.state.mounted && indicator,
              selected: selected,
              onChange: onChange,
              textColor: textColor,
              value: childValue
            });
          });
          var conditionalElements = this.getConditionalElements();
          return React__default.createElement(Component, _extends_1({
            className: clsx(classes.root, className),
            ref: innerRef
          }, other), React__default.createElement(EventListener, {
            target: "window",
            onResize: this.handleResize
          }), React__default.createElement("div", {
            className: classes.flexContainer
          }, conditionalElements.scrollButtonLeft, conditionalElements.scrollbarSizeListener, React__default.createElement("div", {
            className: clsx(classes.scroller, !scrollable && classes.fixed, scrollable && classes.scrollable),
            style: this.state.scrollerStyle,
            ref: this.handleTabsRef,
            role: "tablist",
            onScroll: this.handleTabsScroll
          }, React__default.createElement("div", {
            className: clsx(classes.flexContainer, centered && !scrollable && classes.centered)
          }, children), this.state.mounted && indicator), conditionalElements.scrollButtonRight));
        }
      }]);

      return Tabs;
    }(React__default.Component);

    Tabs.propTypes = {
      /**
       * Callback fired when the component mounts.
       * This is useful when you want to trigger an action programmatically.
       * It currently only supports `updateIndicator()` action.
       *
       * @param {object} actions This object contains all possible actions
       * that can be triggered programmatically.
       */
      action: PropTypes__default.func,

      /**
       * If `true`, the tabs will be centered.
       * This property is intended for large views.
       */
      centered: PropTypes__default.bool,

      /**
       * The content of the component.
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The component used for the root node.
       * Either a string to use a DOM element or a component.
       */
      component: PropTypes__default.elementType,

      /**
       * Determines the color of the indicator.
       */
      indicatorColor: PropTypes__default.oneOf(['secondary', 'primary']),

      /**
       * @ignore
       * from `withForwardRef`
       */
      innerRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * Callback fired when the value changes.
       *
       * @param {object} event The event source of the callback
       * @param {any} value We default to the index of the child (number)
       */
      onChange: PropTypes__default.func,

      /**
       * The component used to render the scroll buttons.
       */
      ScrollButtonComponent: PropTypes__default.elementType,

      /**
       * Determine behavior of scroll buttons when tabs are set to scroll
       *
       * - `auto` will only present them when not all the items are visible.
       * - `desktop` will only present them on medium and larger viewports.
       * - `on` will always present them.
       * - `off` will never present them.
       */
      scrollButtons: PropTypes__default.oneOf(['auto', 'desktop', 'on', 'off']),

      /**
       * Properties applied to the `TabIndicator` element.
       */
      TabIndicatorProps: PropTypes__default.object,

      /**
       * Determines the color of the `Tab`.
       */
      textColor: PropTypes__default.oneOf(['secondary', 'primary', 'inherit']),

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The value of the currently selected `Tab`.
       * If you don't want any selected `Tab`, you can set this property to `false`.
       */
      value: PropTypes__default.any,

      /**
       *  Determines additional display behavior of the tabs:
       *
       *  - `scrollable` will invoke scrolling properties and allow for horizontally
       *  scrolling (or swiping) of the tab bar.
       *  -`fullWidth` will make the tabs grow to use all the available space,
       *  which should be used for small views, like on mobile.
       *  - `standard` will render the default state.
       */
      variant: PropTypes__default.oneOf(['standard', 'scrollable', 'fullWidth'])
    };
    Tabs.defaultProps = {
      centered: false,
      component: 'div',
      indicatorColor: 'secondary',
      ScrollButtonComponent: TabScrollButton$1,
      scrollButtons: 'auto',
      textColor: 'inherit',
      variant: 'standard'
    };
    withStyles(styles$1K, {
      name: 'MuiTabs',
      withTheme: true
    })(withForwardedRef(Tabs));

    var variantComponent = {
      standard: Input$1,
      filled: FilledInput$1,
      outlined: OutlinedInput$1
    };
    var styles$1L = {
      /* Styles applied to the root element. */
      root: {}
    };
    /**
     * The `TextField` is a convenience wrapper for the most common cases (80%).
     * It cannot be all things to all people, otherwise the API would grow out of control.
     *
     * ## Advanced Configuration
     *
     * It's important to understand that the text field is a simple abstraction
     * on top of the following components:
     *
     * - [FormControl](/api/form-control/)
     * - [InputLabel](/api/input-label/)
     * - [FilledInput](/api/filled-input/)
     * - [OutlinedInput](/api/outlined-input/)
     * - [Input](/api/input/)
     * - [FormHelperText](/api/form-helper-text/)
     *
     * If you wish to alter the properties applied to the `input` element, you can do so as follows:
     *
     * ```jsx
     * const inputProps = {
     *   step: 300,
     * };
     *
     * return <TextField id="time" type="time" inputProps={inputProps} />;
     * ```
     *
     * For advanced cases, please look at the source of TextField by clicking on the
     * "Edit this page" button above. Consider either:
     *
     * - using the upper case props for passing values directly to the components
     * - using the underlying components directly as shown in the demos
     */

    var TextField = React__default.forwardRef(function TextField(props, ref) {
      var autoComplete = props.autoComplete,
          autoFocus = props.autoFocus,
          children = props.children,
          classes = props.classes,
          classNameProp = props.className,
          defaultValue = props.defaultValue,
          error = props.error,
          FormHelperTextProps = props.FormHelperTextProps,
          fullWidth = props.fullWidth,
          helperText = props.helperText,
          id = props.id,
          InputLabelProps = props.InputLabelProps,
          inputProps = props.inputProps,
          InputProps = props.InputProps,
          inputRef = props.inputRef,
          label = props.label,
          multiline = props.multiline,
          name = props.name,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onFocus = props.onFocus,
          placeholder = props.placeholder,
          _props$required = props.required,
          required = _props$required === void 0 ? false : _props$required,
          rows = props.rows,
          rowsMax = props.rowsMax,
          _props$select = props.select,
          select = _props$select === void 0 ? false : _props$select,
          SelectProps = props.SelectProps,
          type = props.type,
          value = props.value,
          _props$variant = props.variant,
          variant = _props$variant === void 0 ? 'standard' : _props$variant,
          other = objectWithoutProperties(props, ["autoComplete", "autoFocus", "children", "classes", "className", "defaultValue", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "rowsMax", "select", "SelectProps", "type", "value", "variant"]);

      var _React$useState = React__default.useState(0),
          _React$useState2 = slicedToArray(_React$useState, 2),
          labelWidth = _React$useState2[0],
          setLabelWidth = _React$useState2[1];

      var labelRef = React__default.useRef(null);
      React__default.useEffect(function () {
        if (variant === 'outlined') {
          // #StrictMode ready
          var labelNode = ReactDOM__default.findDOMNode(labelRef.current);
          setLabelWidth(labelNode != null ? labelNode.offsetWidth : 0);
        }
      }, [variant, required]);
      warning_1(!select || Boolean(children), 'Material-UI: `children` must be passed when using the `TextField` component with `select`.');
      var InputMore = {};

      if (variant === 'outlined') {
        if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {
          InputMore.notched = InputLabelProps.shrink;
        }

        InputMore.labelWidth = labelWidth;
      }

      var helperTextId = helperText && id ? "".concat(id, "-helper-text") : undefined;
      var InputComponent = variantComponent[variant];
      var InputElement = React__default.createElement(InputComponent, _extends_1({
        "aria-describedby": helperTextId,
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        defaultValue: defaultValue,
        fullWidth: fullWidth,
        multiline: multiline,
        name: name,
        rows: rows,
        rowsMax: rowsMax,
        type: type,
        value: value,
        id: id,
        inputRef: inputRef,
        onBlur: onBlur,
        onChange: onChange,
        onFocus: onFocus,
        placeholder: placeholder,
        inputProps: inputProps
      }, InputMore, InputProps));
      return React__default.createElement(FormControl$1, _extends_1({
        className: clsx(classes.root, classNameProp),
        error: error,
        fullWidth: fullWidth,
        ref: ref,
        required: required,
        variant: variant
      }, other), label && React__default.createElement(InputLabel$1, _extends_1({
        htmlFor: id,
        ref: labelRef
      }, InputLabelProps), label), select ? React__default.createElement(Select$1, _extends_1({
        "aria-describedby": helperTextId,
        value: value,
        input: InputElement
      }, SelectProps), children) : InputElement, helperText && React__default.createElement(FormHelperText$1, _extends_1({
        id: helperTextId
      }, FormHelperTextProps), helperText));
    });
    TextField.propTypes = {
      /**
       * This property helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: PropTypes__default.string,

      /**
       * If `true`, the `input` element will be focused during the first mount.
       */
      autoFocus: PropTypes__default.bool,

      /**
       * @ignore
       */
      children: PropTypes__default.node,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * @ignore
       */
      className: PropTypes__default.string,

      /**
       * The default value of the `input` element.
       */
      defaultValue: PropTypes__default.any,

      /**
       * If `true`, the `input` element will be disabled.
       */
      disabled: PropTypes__default.bool,

      /**
       * If `true`, the label will be displayed in an error state.
       */
      error: PropTypes__default.bool,

      /**
       * Properties applied to the [`FormHelperText`](/api/form-helper-text/) element.
       */
      FormHelperTextProps: PropTypes__default.object,

      /**
       * If `true`, the input will take up the full width of its container.
       */
      fullWidth: PropTypes__default.bool,

      /**
       * The helper text content.
       */
      helperText: PropTypes__default.node,

      /**
       * The id of the `input` element.
       * Use this property to make `label` and `helperText` accessible for screen readers.
       */
      id: PropTypes__default.string,

      /**
       * Properties applied to the [`InputLabel`](/api/input-label/) element.
       */
      InputLabelProps: PropTypes__default.object,

      /**
       * Properties applied to the Input element.
       * It will be a [`FilledInput`](/api/filled-input/),
       * [`OutlinedInput`](/api/outlined-input/) or [`Input`](/api/input/)
       * component depending on the `variant` prop value.
       */
      InputProps: PropTypes__default.object,

      /**
       * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
       */
      inputProps: PropTypes__default.object,

      /**
       * This property can be used to pass a ref callback to the `input` element.
       */
      inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object]),

      /**
       * The label content.
       */
      label: PropTypes__default.node,

      /**
       * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
       */
      margin: PropTypes__default.oneOf(['none', 'dense', 'normal']),

      /**
       * If `true`, a textarea element will be rendered instead of an input.
       */
      multiline: PropTypes__default.bool,

      /**
       * Name attribute of the `input` element.
       */
      name: PropTypes__default.string,

      /**
       * @ignore
       */
      onBlur: PropTypes__default.func,

      /**
       * Callback fired when the value is changed.
       *
       * @param {object} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value`.
       */
      onChange: PropTypes__default.func,

      /**
       * @ignore
       */
      onFocus: PropTypes__default.func,

      /**
       * The short hint displayed in the input before the user enters a value.
       */
      placeholder: PropTypes__default.string,

      /**
       * If `true`, the label is displayed as required and the `input` element` will be required.
       */
      required: PropTypes__default.bool,

      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      rowsMax: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),

      /**
       * Render a [`Select`](/api/select/) element while passing the Input element to `Select` as `input` parameter.
       * If this option is set you must pass the options of the select as children.
       */
      select: PropTypes__default.bool,

      /**
       * Properties applied to the [`Select`](/api/select/) element.
       */
      SelectProps: PropTypes__default.object,

      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       */
      type: PropTypes__default.string,

      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: PropTypes__default.any,

      /**
       * The variant to use.
       */
      variant: PropTypes__default.oneOf(['standard', 'outlined', 'filled'])
    };
    withStyles(styles$1L, {
      name: 'MuiTextField'
    })(TextField);

    var styles$1M = function styles(theme) {
      return {
        /* Styles applied to the Popper component. */
        popper: {
          zIndex: theme.zIndex.tooltip,
          pointerEvents: 'none',
          position: 'absolute',
          top: 0,
          left: 0
        },

        /* Styles applied to the Popper component if `interactive={true}`. */
        popperInteractive: {
          pointerEvents: 'auto'
        },

        /* Styles applied to the tooltip (label wrapper) element. */
        tooltip: {
          backgroundColor: fade(theme.palette.grey[700], 0.9),
          borderRadius: theme.shape.borderRadius,
          color: theme.palette.common.white,
          fontFamily: theme.typography.fontFamily,
          padding: '4px 8px',
          fontSize: theme.typography.pxToRem(10),
          lineHeight: "".concat(theme.typography.round(14 / 10), "em"),
          maxWidth: 300,
          fontWeight: theme.typography.fontWeightMedium
        },

        /* Styles applied to the tooltip (label wrapper) element if the tooltip is opened by touch. */
        touch: {
          padding: '8px 16px',
          fontSize: theme.typography.pxToRem(14),
          lineHeight: "".concat(theme.typography.round(16 / 14), "em"),
          fontWeight: theme.typography.fontWeightRegular
        },

        /* Styles applied to the tooltip (label wrapper) element if `placement` contains "left". */
        tooltipPlacementLeft: defineProperty({
          transformOrigin: 'right center',
          margin: '0 24px '
        }, theme.breakpoints.up('sm'), {
          margin: '0 14px'
        }),

        /* Styles applied to the tooltip (label wrapper) element if `placement` contains "right". */
        tooltipPlacementRight: defineProperty({
          transformOrigin: 'left center',
          margin: '0 24px'
        }, theme.breakpoints.up('sm'), {
          margin: '0 14px'
        }),

        /* Styles applied to the tooltip (label wrapper) element if `placement` contains "top". */
        tooltipPlacementTop: defineProperty({
          transformOrigin: 'center bottom',
          margin: '24px 0'
        }, theme.breakpoints.up('sm'), {
          margin: '14px 0'
        }),

        /* Styles applied to the tooltip (label wrapper) element if `placement` contains "bottom". */
        tooltipPlacementBottom: defineProperty({
          transformOrigin: 'center top',
          margin: '24px 0'
        }, theme.breakpoints.up('sm'), {
          margin: '14px 0'
        })
      };
    };

    function Tooltip(props) {
      var children = props.children,
          classes = props.classes,
          _props$disableFocusLi = props.disableFocusListener,
          disableFocusListener = _props$disableFocusLi === void 0 ? false : _props$disableFocusLi,
          _props$disableHoverLi = props.disableHoverListener,
          disableHoverListener = _props$disableHoverLi === void 0 ? false : _props$disableHoverLi,
          _props$disableTouchLi = props.disableTouchListener,
          disableTouchListener = _props$disableTouchLi === void 0 ? false : _props$disableTouchLi,
          _props$enterDelay = props.enterDelay,
          enterDelay = _props$enterDelay === void 0 ? 0 : _props$enterDelay,
          _props$enterTouchDela = props.enterTouchDelay,
          enterTouchDelay = _props$enterTouchDela === void 0 ? 700 : _props$enterTouchDela,
          id = props.id,
          _props$interactive = props.interactive,
          interactive = _props$interactive === void 0 ? false : _props$interactive,
          _props$leaveDelay = props.leaveDelay,
          leaveDelay = _props$leaveDelay === void 0 ? 0 : _props$leaveDelay,
          _props$leaveTouchDela = props.leaveTouchDelay,
          leaveTouchDelay = _props$leaveTouchDela === void 0 ? 1500 : _props$leaveTouchDela,
          onClose = props.onClose,
          onOpen = props.onOpen,
          openProp = props.open,
          _props$placement = props.placement,
          placement = _props$placement === void 0 ? 'bottom' : _props$placement,
          PopperProps = props.PopperProps,
          theme = props.theme,
          title = props.title,
          _props$TransitionComp = props.TransitionComponent,
          TransitionComponent = _props$TransitionComp === void 0 ? Grow$1 : _props$TransitionComp,
          TransitionProps = props.TransitionProps,
          other = objectWithoutProperties(props, ["children", "classes", "disableFocusListener", "disableHoverListener", "disableTouchListener", "enterDelay", "enterTouchDelay", "id", "interactive", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperProps", "theme", "title", "TransitionComponent", "TransitionProps"]);

      var _React$useState = React__default.useState(false),
          _React$useState2 = slicedToArray(_React$useState, 2),
          openState = _React$useState2[0],
          setOpenState = _React$useState2[1];

      var _React$useState3 = React__default.useState(0),
          _React$useState4 = slicedToArray(_React$useState3, 2),
          forceUpdate = _React$useState4[1];

      var _React$useState5 = React__default.useState(),
          _React$useState6 = slicedToArray(_React$useState5, 2),
          childNode = _React$useState6[0],
          setChildNode = _React$useState6[1];

      var ignoreNonTouchEvents = React__default.useRef(false);

      var _React$useRef = React__default.useRef(props.open != null),
          isControlled = _React$useRef.current;

      var defaultId = React__default.useRef();
      var closeTimer = React__default.useRef();
      var enterTimer = React__default.useRef();
      var leaveTimer = React__default.useRef();
      var touchTimer = React__default.useRef();
      React__default.useEffect(function () {
        warning_1(!(childNode && childNode.disabled && !isControlled && title !== '' && childNode.tagName.toLowerCase() === 'button'), ['Material-UI: you are providing a disabled `button` child to the Tooltip component.', 'A disabled element does not fire events.', "Tooltip needs to listen to the child element's events to display the title.", '', 'Place a `div` container on top of the element.'].join('\n'));
      }, [isControlled, title, childNode]);
      React__default.useEffect(function () {
        // Fallback to this default id when possible.
        // Use the random value for client side rendering only.
        // We can't use it server-side.
        if (!defaultId.current) {
          defaultId.current = "mui-tooltip-".concat(Math.round(Math.random() * 1e5));
        } // Rerender with defaultId and childNode.


        if (openProp) {
          forceUpdate(function (n) {
            return !n;
          });
        }
      }, [openProp]);
      React__default.useEffect(function () {
        return function () {
          clearTimeout(closeTimer.current);
          clearTimeout(enterTimer.current);
          clearTimeout(leaveTimer.current);
          clearTimeout(touchTimer.current);
        };
      }, []);

      var handleOpen = function handleOpen(event) {
        // The mouseover event will trigger for every nested element in the tooltip.
        // We can skip rerendering when the tooltip is already open.
        // We are using the mouseover event instead of the mouseenter event to fix a hide/show issue.
        if (!isControlled && !openState) {
          setOpenState(true);
        }

        if (onOpen) {
          onOpen(event);
        }
      };

      var handleEnter = function handleEnter(event) {
        var childrenProps = children.props;

        if (event.type === 'mouseover' && childrenProps.onMouseOver) {
          childrenProps.onMouseOver(event);
        }

        if (ignoreNonTouchEvents.current && event.type !== 'touchstart') {
          return;
        } // Remove the title ahead of time.
        // We don't want to wait for the next render commit.
        // We would risk displaying two tooltips at the same time (native + this one).


        if (childNode) {
          childNode.setAttribute('title', '');
        }

        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);

        if (enterDelay) {
          event.persist();
          enterTimer.current = setTimeout(function () {
            handleOpen(event);
          }, enterDelay);
        } else {
          handleOpen(event);
        }
      };

      var _useIsFocusVisible = useIsFocusVisible(),
          isFocusVisible = _useIsFocusVisible.isFocusVisible,
          onBlurVisible = _useIsFocusVisible.onBlurVisible,
          focusVisibleRef = _useIsFocusVisible.ref;

      var _React$useState7 = React__default.useState(false),
          _React$useState8 = slicedToArray(_React$useState7, 2),
          childIsFocusVisible = _React$useState8[0],
          setChildIsFocusVisible = _React$useState8[1];

      function handleBlur() {
        if (childIsFocusVisible) {
          setChildIsFocusVisible(false);
          onBlurVisible();
        }
      }

      var handleFocus = function handleFocus(event) {
        // Workaround for https://github.com/facebook/react/issues/7769
        // The autoFocus of React might trigger the event before the componentDidMount.
        // We need to account for this eventuality.
        if (!childNode) {
          setChildNode(event.currentTarget);
        }

        if (isFocusVisible(event)) {
          setChildIsFocusVisible(true);
          handleEnter(event);
        }

        var childrenProps = children.props;

        if (childrenProps.onFocus) {
          childrenProps.onFocus(event);
        }
      };

      var handleClose = function handleClose(event) {
        if (!isControlled) {
          setOpenState(false);
        }

        if (onClose) {
          onClose(event);
        }

        clearTimeout(closeTimer.current);
        closeTimer.current = setTimeout(function () {
          ignoreNonTouchEvents.current = false;
        }, theme.transitions.duration.shortest);
      };

      var handleLeave = function handleLeave(event) {
        var childrenProps = children.props;

        if (event.type === 'blur') {
          if (childrenProps.onBlur) {
            childrenProps.onBlur(event);
          }

          handleBlur(event);
        }

        if (event.type === 'mouseleave' && childrenProps.onMouseLeave) {
          childrenProps.onMouseLeave(event);
        }

        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);

        if (leaveDelay) {
          event.persist();
          leaveTimer.current = setTimeout(function () {
            handleClose(event);
          }, leaveDelay);
        } else {
          handleClose(event);
        }
      };

      var handleTouchStart = function handleTouchStart(event) {
        ignoreNonTouchEvents.current = true;
        var childrenProps = children.props;

        if (childrenProps.onTouchStart) {
          childrenProps.onTouchStart(event);
        }

        clearTimeout(leaveTimer.current);
        clearTimeout(closeTimer.current);
        clearTimeout(touchTimer.current);
        event.persist();
        touchTimer.current = setTimeout(function () {
          handleEnter(event);
        }, enterTouchDelay);
      };

      var handleTouchEnd = function handleTouchEnd(event) {
        if (children.props.onTouchEnd) {
          children.props.onTouchEnd(event);
        }

        clearTimeout(touchTimer.current);
        clearTimeout(leaveTimer.current);
        event.persist();
        leaveTimer.current = setTimeout(function () {
          handleClose(event);
        }, leaveTouchDelay);
      }; // can be removed once we drop support for non ref forwarding class components


      var handleOwnRef = useForkRef(React__default.useCallback(function (instance) {
        // #StrictMode ready
        setChildNode(ReactDOM__default.findDOMNode(instance));
      }, []), focusVisibleRef);
      var handleRef = useForkRef(children.ref, handleOwnRef);
      var open = isControlled ? openProp : openState; // There is no point in displaying an empty tooltip.

      if (title === '') {
        open = false;
      } // For accessibility and SEO concerns, we render the title to the DOM node when
      // the tooltip is hidden. However, we have made a tradeoff when
      // `disableHoverListener` is set. This title logic is disabled.
      // It's allowing us to keep the implementation size minimal.
      // We are open to change the tradeoff.


      var shouldShowNativeTitle = !open && !disableHoverListener;

      var childrenProps = _extends_1({
        'aria-describedby': open ? id || defaultId.current : null,
        title: shouldShowNativeTitle && typeof title === 'string' ? title : null
      }, other, children.props, {
        className: clsx(other.className, children.props.className)
      });

      if (!disableTouchListener) {
        childrenProps.onTouchStart = handleTouchStart;
        childrenProps.onTouchEnd = handleTouchEnd;
      }

      if (!disableHoverListener) {
        childrenProps.onMouseOver = handleEnter;
        childrenProps.onMouseLeave = handleLeave;
      }

      if (!disableFocusListener) {
        childrenProps.onFocus = handleFocus;
        childrenProps.onBlur = handleLeave;
      }

      var interactiveWrapperListeners = interactive ? {
        onMouseOver: childrenProps.onMouseOver,
        onMouseLeave: childrenProps.onMouseLeave,
        onFocus: childrenProps.onFocus,
        onBlur: childrenProps.onBlur
      } : {};
      warning_1(!children.props.title, ['Material-UI: you have provided a `title` property to the child of <Tooltip />.', "Remove this title property `".concat(children.props.title, "` or the Tooltip component.")].join('\n'));
      return React__default.createElement(React__default.Fragment, null, React__default.cloneElement(children, _extends_1({
        ref: handleRef
      }, childrenProps)), React__default.createElement(Popper$1, _extends_1({
        className: clsx(classes.popper, interactive && classes.popperInteractive),
        placement: placement,
        anchorEl: childNode,
        open: childNode ? open : false,
        id: childrenProps['aria-describedby'],
        transition: true
      }, interactiveWrapperListeners, PopperProps), function (_ref) {
        var placementInner = _ref.placement,
            TransitionPropsInner = _ref.TransitionProps;
        return React__default.createElement(TransitionComponent, _extends_1({
          timeout: theme.transitions.duration.shorter
        }, TransitionPropsInner, TransitionProps), React__default.createElement("div", {
          className: clsx(classes.tooltip, ignoreNonTouchEvents.current && classes.touch, classes["tooltipPlacement".concat(capitalize(placementInner.split('-')[0]))])
        }, title));
      }));
    }

    Tooltip.propTypes = {
      /**
       * Tooltip reference element.
       */
      children: elementAcceptingRef.isRequired,

      /**
       * Override or extend the styles applied to the component.
       * See [CSS API](#css) below for more details.
       */
      classes: PropTypes__default.object.isRequired,

      /**
       * Do not respond to focus events.
       */
      disableFocusListener: PropTypes__default.bool,

      /**
       * Do not respond to hover events.
       */
      disableHoverListener: PropTypes__default.bool,

      /**
       * Do not respond to long press touch events.
       */
      disableTouchListener: PropTypes__default.bool,

      /**
       * The number of milliseconds to wait before showing the tooltip.
       * This property won't impact the enter touch delay (`enterTouchDelay`).
       */
      enterDelay: PropTypes__default.number,

      /**
       * The number of milliseconds a user must touch the element before showing the tooltip.
       */
      enterTouchDelay: PropTypes__default.number,

      /**
       * The relationship between the tooltip and the wrapper component is not clear from the DOM.
       * This property is used with aria-describedby to solve the accessibility issue.
       * If you don't provide this property. It falls back to a randomly generated id.
       */
      id: PropTypes__default.string,

      /**
       * Makes a tooltip interactive, i.e. will not close when the user
       * hovers over the tooltip before the `leaveDelay` is expired.
       */
      interactive: PropTypes__default.bool,

      /**
       * The number of milliseconds to wait before hiding the tooltip.
       * This property won't impact the leave touch delay (`leaveTouchDelay`).
       */
      leaveDelay: PropTypes__default.number,

      /**
       * The number of milliseconds after the user stops touching an element before hiding the tooltip.
       */
      leaveTouchDelay: PropTypes__default.number,

      /**
       * Callback fired when the tooltip requests to be closed.
       *
       * @param {object} event The event source of the callback
       */
      onClose: PropTypes__default.func,

      /**
       * Callback fired when the tooltip requests to be open.
       *
       * @param {object} event The event source of the callback
       */
      onOpen: PropTypes__default.func,

      /**
       * If `true`, the tooltip is shown.
       */
      open: PropTypes__default.bool,

      /**
       * Tooltip placement.
       */
      placement: PropTypes__default.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

      /**
       * Properties applied to the [`Popper`](/api/popper/) element.
       */
      PopperProps: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * Tooltip title. Zero-length titles string are never displayed.
       */
      title: PropTypes__default.node.isRequired,

      /**
       * The component used for the transition.
       */
      TransitionComponent: PropTypes__default.elementType,

      /**
       * Properties applied to the `Transition` element.
       */
      TransitionProps: PropTypes__default.object
    };
    withStyles(styles$1M, {
      name: 'MuiTooltip',
      withTheme: true
    })(Tooltip);

    var styles$1N = {
      entering: {
        transform: 'scale(1)'
      },
      entered: {
        transform: 'scale(1)'
      }
    };
    var defaultTimeout$2 = {
      enter: duration.enteringScreen,
      exit: duration.leavingScreen
    };
    /**
     * The Zoom transition can be used for the floating variant of the
     * [Button](/components/buttons/#floating-action-buttons) component.
     * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
     */

    var Zoom = React__default.forwardRef(function Zoom(props, ref) {
      var children = props.children,
          inProp = props.in,
          onEnter = props.onEnter,
          onExit = props.onExit,
          style = props.style,
          theme = props.theme,
          _props$timeout = props.timeout,
          timeout = _props$timeout === void 0 ? defaultTimeout$2 : _props$timeout,
          other = objectWithoutProperties(props, ["children", "in", "onEnter", "onExit", "style", "theme", "timeout"]);

      var handleRef = useForkRef(children.ref, ref);

      var handleEnter = function handleEnter(node) {
        reflow(node); // So the animation always start from the start.

        var transitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'enter'
        });
        node.style.webkitTransition = theme.transitions.create('transform', transitionProps);
        node.style.transition = theme.transitions.create('transform', transitionProps);

        if (onEnter) {
          onEnter(node);
        }
      };

      var handleExit = function handleExit(node) {
        var transitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'exit'
        });
        node.style.webkitTransition = theme.transitions.create('transform', transitionProps);
        node.style.transition = theme.transitions.create('transform', transitionProps);

        if (onExit) {
          onExit(node);
        }
      };

      return React__default.createElement(Transition, _extends_1({
        appear: true,
        in: inProp,
        onEnter: handleEnter,
        onExit: handleExit,
        timeout: timeout
      }, other), function (state, childProps) {
        return React__default.cloneElement(children, _extends_1({
          style: _extends_1({
            transform: 'scale(0)',
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, styles$1N[state], style, children.props.style),
          ref: handleRef
        }, childProps));
      });
    });
    Zoom.propTypes = {
      /**
       * A single child content element.
       */
      children: PropTypes__default.element,

      /**
       * If `true`, the component will transition in.
       */
      in: PropTypes__default.bool,

      /**
       * @ignore
       */
      onEnter: PropTypes__default.func,

      /**
       * @ignore
       */
      onExit: PropTypes__default.func,

      /**
       * @ignore
       */
      style: PropTypes__default.object,

      /**
       * @ignore
       */
      theme: PropTypes__default.object.isRequired,

      /**
       * The duration for the transition, in milliseconds.
       * You may specify a single timeout for all transitions, or individually with an object.
       */
      timeout: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
        enter: PropTypes__default.number,
        exit: PropTypes__default.number
      })])
    };
    withTheme(Zoom);

    /** @license Material-UI v4.0.1
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var KeyboardIcon = function (props) {
      return React__default.createElement(SvgIcon$2, __assign({}, props), React__default.createElement("path", {
        d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
      }), React__default.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }));
    };

    var KeyboardDateInput = function (_a) {
      var inputValue = _a.inputValue,
          inputVariant = _a.inputVariant,
          validationError = _a.validationError,
          KeyboardButtonProps = _a.KeyboardButtonProps,
          InputAdornmentProps = _a.InputAdornmentProps,
          onClick = _a.onClick,
          onChange = _a.onChange,
          InputProps = _a.InputProps,
          mask = _a.mask,
          _b = _a.maskChar,
          maskChar = _b === void 0 ? '_' : _b,
          _c = _a.refuse,
          refuse = _c === void 0 ? /[^\dap]+/gi : _c,
          format = _a.format,
          keyboardIcon = _a.keyboardIcon,
          disabled = _a.disabled,
          _d = _a.TextFieldComponent,
          TextFieldComponent = _d === void 0 ? TextField$1 : _d,
          other = __rest(_a, ["inputValue", "inputVariant", "validationError", "KeyboardButtonProps", "InputAdornmentProps", "onClick", "onChange", "InputProps", "mask", "maskChar", "refuse", "format", "keyboardIcon", "disabled", "TextFieldComponent"]);

      var inputMask = mask || makeMaskFromFormat(format, maskChar); // prettier-ignore

      var formatter = React.useCallback(maskedDateFormatter(inputMask, maskChar, refuse), [mask, maskChar]);
      var position = InputAdornmentProps && InputAdornmentProps.position ? InputAdornmentProps.position : 'end';
      return React.createElement(Rifm, {
        value: inputValue,
        onChange: onChange,
        refuse: refuse,
        format: formatter
      }, function (_a) {
        var _b;

        var onChange = _a.onChange,
            value = _a.value;
        return React.createElement(TextFieldComponent, __assign({
          disabled: disabled,
          error: Boolean(validationError),
          helperText: validationError
        }, other, {
          value: value,
          onChange: onChange,
          variant: inputVariant,
          InputProps: __assign({}, InputProps, (_b = {}, _b[position + "Adornment"] = React.createElement(InputAdornment$1, __assign({
            position: position
          }, InputAdornmentProps), React.createElement(IconButton$1, __assign({
            disabled: disabled
          }, KeyboardButtonProps, {
            onClick: onClick
          }), keyboardIcon)), _b))
        }));
      });
    };

    KeyboardDateInput.defaultProps = {
      keyboardIcon: React.createElement(KeyboardIcon, null)
    };

    function parseInputString(value, utils, format) {
      try {
        return utils.parse(value, format);
      } catch (_a) {
        return null;
      }
    }

    function useKeyboardPickerState(props, options) {
      var utils = useUtils();
      var format = props.format || options.getDefaultFormat();

      var _a = React.useState(getDisplayDate(props.value, format, utils, props.value === null, props)),
          innerInputValue = _a[0],
          setInnerInputValue = _a[1];

      var dateValue = props.inputValue ? parseInputString(props.inputValue, utils, format) : props.value;
      React.useEffect(function () {
        if (props.value === null || utils.isValid(props.value)) {
          setInnerInputValue(getDisplayDate(props.value, format, utils, props.value === null, props));
        }
      }, [format, props, props.value, utils]);

      function handleChange(date) {
        var dateString = date === null ? null : utils.format(date, format);
        props.onChange(date, dateString);
      }

      var _b = usePickerState(__assign({}, props, {
        value: dateValue,
        onChange: handleChange
      }), options),
          innerInputProps = _b.inputProps,
          wrapperProps = _b.wrapperProps,
          pickerProps = _b.pickerProps;

      var inputProps = React.useMemo(function () {
        return __assign({}, innerInputProps, {
          format: wrapperProps.format,
          inputValue: props.inputValue || innerInputValue,
          onChange: function (value) {
            setInnerInputValue(value);
            var date = value === '' ? null : utils.parse(value, wrapperProps.format);
            props.onChange(date, value);
          }
        });
      }, [innerInputProps, innerInputValue, props, utils, wrapperProps.format]);
      return {
        inputProps: inputProps,
        wrapperProps: wrapperProps,
        pickerProps: pickerProps
      };
    }

    function makeKeyboardPicker(_a) {
      var useOptions = _a.useOptions,
          ToolbarComponent = _a.ToolbarComponent;

      function WrappedKeyboardPicker(props) {
        var allowKeyboardControl = props.allowKeyboardControl,
            ampm = props.ampm,
            hideTabs = props.hideTabs,
            animateYearScrolling = props.animateYearScrolling,
            autoOk = props.autoOk,
            disableFuture = props.disableFuture,
            disablePast = props.disablePast,
            format = props.format,
            forwardedRef = props.forwardedRef,
            initialFocusedDate = props.initialFocusedDate,
            invalidDateMessage = props.invalidDateMessage,
            labelFunc = props.labelFunc,
            leftArrowIcon = props.leftArrowIcon,
            leftArrowButtonProps = props.leftArrowButtonProps,
            maxDate = props.maxDate,
            maxDateMessage = props.maxDateMessage,
            minDate = props.minDate,
            onOpen = props.onOpen,
            onClose = props.onClose,
            minDateMessage = props.minDateMessage,
            minutesStep = props.minutesStep,
            onAccept = props.onAccept,
            onChange = props.onChange,
            onMonthChange = props.onMonthChange,
            onYearChange = props.onYearChange,
            renderDay = props.renderDay,
            views = props.views,
            openTo = props.openTo,
            rightArrowIcon = props.rightArrowIcon,
            rightArrowButtonProps = props.rightArrowButtonProps,
            shouldDisableDate = props.shouldDisableDate,
            value = props.value,
            dateRangeIcon = props.dateRangeIcon,
            timeIcon = props.timeIcon,
            variant = props.variant,
            disableToolbar = props.disableToolbar,
            loadingIndicator = props.loadingIndicator,
            other = __rest(props, ["allowKeyboardControl", "ampm", "hideTabs", "animateYearScrolling", "autoOk", "disableFuture", "disablePast", "format", "forwardedRef", "initialFocusedDate", "invalidDateMessage", "labelFunc", "leftArrowIcon", "leftArrowButtonProps", "maxDate", "maxDateMessage", "minDate", "onOpen", "onClose", "minDateMessage", "minutesStep", "onAccept", "onChange", "onMonthChange", "onYearChange", "renderDay", "views", "openTo", "rightArrowIcon", "rightArrowButtonProps", "shouldDisableDate", "value", "dateRangeIcon", "timeIcon", "variant", "disableToolbar", "loadingIndicator"]);

        var options = useOptions(props);

        var _a = useKeyboardPickerState(props, options),
            pickerProps = _a.pickerProps,
            inputProps = _a.inputProps,
            wrapperProps = _a.wrapperProps;

        return React.createElement(Wrapper, __assign({
          variant: variant,
          InputComponent: KeyboardDateInput,
          DateInputProps: inputProps
        }, wrapperProps, other), React.createElement(Picker, __assign({}, pickerProps, {
          ToolbarComponent: ToolbarComponent,
          disableToolbar: disableToolbar,
          hideTabs: hideTabs,
          ampm: ampm,
          views: views,
          openTo: openTo,
          allowKeyboardControl: allowKeyboardControl,
          minutesStep: minutesStep,
          animateYearScrolling: animateYearScrolling,
          disableFuture: disableFuture,
          disablePast: disablePast,
          leftArrowIcon: leftArrowIcon,
          leftArrowButtonProps: leftArrowButtonProps,
          maxDate: maxDate,
          minDate: minDate,
          onMonthChange: onMonthChange,
          onYearChange: onYearChange,
          renderDay: renderDay,
          dateRangeIcon: dateRangeIcon,
          timeIcon: timeIcon,
          rightArrowIcon: rightArrowIcon,
          rightArrowButtonProps: rightArrowButtonProps,
          shouldDisableDate: shouldDisableDate,
          loadingIndicator: loadingIndicator
        })));
      }

      return WrappedKeyboardPicker;
    }

    var defaultProps$1 = __assign({}, datePickerDefaultProps, {
      openTo: 'date',
      views: ['year', 'date']
    });

    function useOptions(props) {
      var utils = useUtils();
      return {
        getDefaultFormat: function () {
          return getFormatByViews(props.views, utils);
        }
      };
    }

    var DatePicker = makePurePicker({
      useOptions: useOptions,
      ToolbarComponent: DatePickerToolbar
    });
    var KeyboardDatePicker = makeKeyboardPicker({
      useOptions: useOptions,
      ToolbarComponent: DatePickerToolbar
    });
    DatePicker.defaultProps = defaultProps$1;
    KeyboardDatePicker.defaultProps = defaultProps$1;

    var useStyles$d = makeStyles({
      toolbar: {
        flexDirection: 'row',
        alignItems: 'center'
      },
      toolbarLeftPadding: {
        paddingLeft: 50
      },
      separator: {
        margin: '0 4px 0 2px',
        cursor: 'default'
      },
      ampmSelection: {
        marginLeft: 20,
        marginRight: -20,
        display: 'flex',
        flexDirection: 'column'
      },
      ampmSelectionWithSeconds: {
        marginLeft: 15,
        marginRight: 10
      },
      ampmLabel: {
        fontSize: 18
      },
      hourMinuteLabel: {
        display: 'flex',
        justifyContent: 'flex-end',
        alignItems: 'flex-end'
      },
      hourMinuteLabelReverse: {
        display: 'flex',
        justifyContent: 'flex-end',
        alignItems: 'flex-end',
        flexDirection: 'row-reverse'
      }
    }, {
      name: 'MuiPickersTimePickerToolbar'
    });
    function useMeridiemMode(date, ampm, onChange) {
      var utils = useUtils();
      var meridiemMode = getMeridiem(date, utils);
      var handleMeridiemChange = React.useCallback(function (mode) {
        var timeWithMeridiem = convertToMeridiem(date, mode, Boolean(ampm), utils);
        onChange(timeWithMeridiem, false);
      }, [ampm, date, onChange, utils]);
      return {
        meridiemMode: meridiemMode,
        handleMeridiemChange: handleMeridiemChange
      };
    }

    var TimePickerToolbar = function (_a) {
      var _b, _c;

      var date = _a.date,
          views = _a.views,
          ampm = _a.ampm,
          openView = _a.openView,
          onChange = _a.onChange,
          setOpenView = _a.setOpenView;
      var utils = useUtils();
      var theme = useTheme();
      var classes = useStyles$d();

      var _d = useMeridiemMode(date, ampm, onChange),
          meridiemMode = _d.meridiemMode,
          handleMeridiemChange = _d.handleMeridiemChange;

      var hourMinuteClassName = theme.direction === 'rtl' ? classes.hourMinuteLabelReverse : classes.hourMinuteLabel;
      return React.createElement(PickerToolbar$1, {
        className: clsx(classes.toolbar, (_b = {}, _b[classes.toolbarLeftPadding] = ampm, _b))
      }, React.createElement("div", {
        className: hourMinuteClassName
      }, views.includes('hours') && React.createElement(React.Fragment, null, React.createElement(ToolbarButton$1, {
        variant: "h2",
        onClick: function () {
          return setOpenView(ClockType$1.HOURS);
        },
        selected: openView === ClockType$1.HOURS,
        label: utils.getHourText(date, Boolean(ampm))
      }), React.createElement(ToolbarText, {
        variant: "h2",
        label: ":",
        selected: false,
        className: classes.separator
      })), views.includes('minutes') && React.createElement(ToolbarButton$1, {
        variant: "h2",
        onClick: function () {
          return setOpenView(ClockType$1.MINUTES);
        },
        selected: openView === ClockType$1.MINUTES,
        label: utils.getMinuteText(date)
      }), views.includes('seconds') && React.createElement(React.Fragment, null, React.createElement(ToolbarText, {
        variant: "h2",
        label: ":",
        selected: false,
        className: classes.separator
      }), React.createElement(ToolbarButton$1, {
        variant: "h2",
        onClick: function () {
          return setOpenView(ClockType$1.SECONDS);
        },
        selected: openView === ClockType$1.SECONDS,
        label: utils.getSecondText(date)
      }))), ampm && React.createElement("div", {
        className: clsx(classes.ampmSelection, (_c = {}, _c[classes.ampmSelectionWithSeconds] = views.includes('seconds'), _c))
      }, React.createElement(ToolbarButton$1, {
        disableRipple: true,
        variant: "subtitle1",
        selected: meridiemMode === 'am',
        typographyClassName: classes.ampmLabel,
        label: utils.getMeridiemText('am'),
        onClick: function () {
          return handleMeridiemChange('am');
        }
      }), React.createElement(ToolbarButton$1, {
        disableRipple: true,
        variant: "subtitle1",
        selected: meridiemMode === 'pm',
        typographyClassName: classes.ampmLabel,
        label: utils.getMeridiemText('pm'),
        onClick: function () {
          return handleMeridiemChange('pm');
        }
      })));
    };

    var defaultProps$2 = __assign({}, timePickerDefaultProps, {
      openTo: 'hours',
      views: ['hours', 'minutes']
    });

    function useOptions$1(props) {
      var utils = useUtils();
      return {
        getDefaultFormat: function () {
          return pick12hOr24hFormat(props.format, props.ampm, {
            '12h': utils.time12hFormat,
            '24h': utils.time24hFormat
          });
        }
      };
    }

    var TimePicker = makePurePicker({
      useOptions: useOptions$1,
      ToolbarComponent: TimePickerToolbar
    });
    var KeyboardTimePicker = makeKeyboardPicker({
      useOptions: useOptions$1,
      ToolbarComponent: TimePickerToolbar
    });
    TimePicker.defaultProps = defaultProps$2;
    KeyboardTimePicker.defaultProps = defaultProps$2;

    var TimeIcon = function (props) {
      return React__default.createElement(SvgIcon$2, __assign({}, props), React__default.createElement("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), React__default.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }), React__default.createElement("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      }));
    };

    var DateRangeIcon = function (props) {
      return React__default.createElement(SvgIcon$2, __assign({}, props), React__default.createElement("path", {
        d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
      }), React__default.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }));
    };

    var viewToTabIndex = function (openView) {
      if (openView === 'date' || openView === 'year') {
        return 'date';
      }

      return 'time';
    };

    var tabIndexToView = function (tab) {
      if (tab === 'date') {
        return 'date';
      }

      return 'hours';
    };

    var useStyles$e = makeStyles(function (theme) {
      // prettier-ignore
      var tabsBackground = theme.palette.type === 'light' ? theme.palette.primary.main : theme.palette.background.default;
      return {
        tabs: {
          color: theme.palette.getContrastText(tabsBackground),
          backgroundColor: tabsBackground
        }
      };
    }, {
      name: 'MuiPickerDTTabs'
    });
    var DateTimePickerTabs = function (_a) {
      var view = _a.view,
          onChange = _a.onChange,
          dateRangeIcon = _a.dateRangeIcon,
          timeIcon = _a.timeIcon;
      var classes = useStyles$e();
      var theme = useTheme();
      var indicatorColor = theme.palette.type === 'light' ? 'secondary' : 'primary';

      var handleChange = function (e, value) {
        if (value !== viewToTabIndex(view)) {
          onChange(tabIndexToView(value));
        }
      };

      return React.createElement(Paper$2, null, React.createElement(Tabs$1, {
        variant: "fullWidth",
        value: viewToTabIndex(view),
        onChange: handleChange,
        className: classes.tabs,
        indicatorColor: indicatorColor
      }, React.createElement(Tab$1, {
        value: "date",
        icon: React.createElement(React.Fragment, null, dateRangeIcon)
      }), React.createElement(Tab$1, {
        value: "time",
        icon: React.createElement(React.Fragment, null, timeIcon)
      })));
    };
    DateTimePickerTabs.defaultProps = {
      dateRangeIcon: React.createElement(DateRangeIcon, null),
      timeIcon: React.createElement(TimeIcon, null)
    };

    var useStyles$f = makeStyles(function (_) {
      return {
        toolbar: {
          flexDirection: 'row',
          alignItems: 'center',
          paddingLeft: 12,
          paddingRight: 12,
          justifyContent: 'space-around'
        },
        separator: {
          margin: '0 4px 0 2px',
          cursor: 'default'
        }
      };
    }, {
      name: 'MuiPickerDTToolbar'
    });
    var DateTimePickerToolbar = function (_a) {
      var date = _a.date,
          openView = _a.openView,
          setOpenView = _a.setOpenView,
          ampm = _a.ampm,
          hideTabs = _a.hideTabs,
          dateRangeIcon = _a.dateRangeIcon,
          timeIcon = _a.timeIcon,
          onChange = _a.onChange;
      var utils = useUtils();
      var classes = useStyles$f();
      var showTabs = !hideTabs && typeof window !== 'undefined' && window.innerHeight > 667;

      var _b = useMeridiemMode(date, ampm, onChange),
          meridiemMode = _b.meridiemMode,
          handleMeridiemChange = _b.handleMeridiemChange;

      var theme = useTheme();
      var rtl = theme.direction === 'rtl';
      return React.createElement(React.Fragment, null, React.createElement(PickerToolbar$1, {
        className: classes.toolbar
      }, React.createElement(StyledGrid, {
        container: true,
        justify: "center",
        wrap: "nowrap"
      }, React.createElement(StyledGrid, {
        item: true,
        container: true,
        xs: 5,
        direction: "row"
      }, React.createElement(ToolbarButton$1, {
        variant: "subtitle1",
        onClick: function () {
          return setOpenView('year');
        },
        selected: openView === 'year',
        label: utils.getYearText(date)
      }), React.createElement(ToolbarButton$1, {
        variant: "h4",
        onClick: function () {
          return setOpenView('date');
        },
        selected: openView === 'date',
        label: utils.getDateTimePickerHeaderText(date)
      })), React.createElement(StyledGrid, {
        item: true,
        container: true,
        xs: 6,
        justify: "center",
        alignItems: "flex-end",
        direction: rtl ? 'row-reverse' : 'row'
      }, React.createElement(ToolbarButton$1, {
        variant: "h3",
        onClick: function () {
          return setOpenView('hours');
        },
        selected: openView === 'hours',
        label: utils.getHourText(date, ampm)
      }), React.createElement(ToolbarText, {
        variant: "h3",
        label: ":",
        className: classes.separator
      }), React.createElement(ToolbarButton$1, {
        variant: "h3",
        onClick: function () {
          return setOpenView('minutes');
        },
        selected: openView === 'minutes',
        label: utils.getMinuteText(date)
      })), ampm && React.createElement(StyledGrid, {
        item: true,
        container: true,
        xs: 1,
        direction: "column",
        justify: "flex-end"
      }, React.createElement(ToolbarButton$1, {
        variant: "subtitle1",
        selected: meridiemMode === 'am',
        label: utils.getMeridiemText('am'),
        onClick: function () {
          return handleMeridiemChange('am');
        }
      }), React.createElement(ToolbarButton$1, {
        variant: "subtitle1",
        selected: meridiemMode === 'pm',
        label: utils.getMeridiemText('pm'),
        onClick: function () {
          return handleMeridiemChange('pm');
        }
      })))), showTabs && React.createElement(DateTimePickerTabs, {
        dateRangeIcon: dateRangeIcon,
        timeIcon: timeIcon,
        view: openView,
        onChange: setOpenView
      }));
    };

    var defaultProps$3 = __assign({}, dateTimePickerDefaultProps, {
      wider: true,
      openTo: 'date',
      views: ['year', 'date', 'hours', 'minutes']
    });

    function useOptions$2(props) {
      var utils = useUtils();
      return {
        getDefaultFormat: function () {
          return pick12hOr24hFormat(props.format, props.ampm, {
            '12h': utils.dateTime12hFormat,
            '24h': utils.dateTime24hFormat
          });
        }
      };
    }

    var DateTimePicker = makePurePicker({
      useOptions: useOptions$2,
      ToolbarComponent: DateTimePickerToolbar
    });
    var KeyboardDateTimePicker = makeKeyboardPicker({
      useOptions: useOptions$2,
      ToolbarComponent: DateTimePickerToolbar
    });
    DateTimePicker.defaultProps = defaultProps$3;
    KeyboardDateTimePicker.defaultProps = defaultProps$3;

    exports.Calendar = Calendar$1;
    exports.Clock = Clock$1;
    exports.DatePicker = DatePicker;
    exports.DateTimePicker = DateTimePicker;
    exports.Day = Day;
    exports.KeyboardDatePicker = KeyboardDatePicker;
    exports.KeyboardDateTimePicker = KeyboardDateTimePicker;
    exports.KeyboardTimePicker = KeyboardTimePicker;
    exports.MuiPickersContext = MuiPickersContext;
    exports.MuiPickersUtilsProvider = MuiPickersUtilsProvider;
    exports.Picker = Picker;
    exports.TimePicker = TimePicker;
    exports.TimePickerView = TimePickerView$1;
    exports.makeKeyboardPicker = makeKeyboardPicker;
    exports.makePurePicker = makePurePicker;
    exports.useKeyboardPickerState = useKeyboardPickerState;
    exports.usePickerState = usePickerState;
    exports.useUtils = useUtils;
    exports.validate = validate;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
