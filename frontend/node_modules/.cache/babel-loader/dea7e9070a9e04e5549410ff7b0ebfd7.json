{"ast":null,"code":"import { b as addTraps, c as instanceOfAny, d as reverseTransformCache, e as unwrap } from './chunk.js';\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n  get(target, prop) {\n    if (!advanceMethodProps.includes(prop)) return target[prop];\n    let cachedFunc = methodMap[prop];\n\n    if (!cachedFunc) {\n      cachedFunc = methodMap[prop] = function (...args) {\n        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n      };\n    }\n\n    return cachedFunc;\n  }\n\n};\n\nasync function* iterate(...args) {\n  // tslint:disable-next-line:no-this-assignment\n  let cursor = this;\n\n  if (!(cursor instanceof IDBCursor)) {\n    cursor = await cursor.openCursor(...args);\n  }\n\n  if (!cursor) return;\n  cursor = cursor;\n  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor); // Map this double-proxy back to the original, so other cursor methods work.\n\n  reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n\n  while (cursor) {\n    yield proxiedCursor; // If one of the advancing methods was not called, call continue().\n\n    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n    advanceResults.delete(proxiedCursor);\n  }\n}\n\nfunction isIteratorProp(target, prop) {\n  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore]);\n}\n\naddTraps(oldTraps => ({\n  get(target, prop, receiver) {\n    if (isIteratorProp(target, prop)) return iterate;\n    return oldTraps.get(target, prop, receiver);\n  },\n\n  has(target, prop) {\n    return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n  }\n\n}));","map":null,"metadata":{},"sourceType":"module"}